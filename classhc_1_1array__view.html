<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>HCC: hc::array_view&lt; T, N &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HCC
   </div>
   <div id="projectbrief">HCC is a single-source, C/C++ compiler for heterogeneous computing.  It&#39;s optimized with HSA (http://www.hsafoundation.com/).</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacehc.html">hc</a></li><li class="navelem"><a class="el" href="classhc_1_1array__view.html">array_view</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classhc_1_1array__view-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">hc::array_view&lt; T, N &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T,N&gt;, or a section thereof.  
 <a href="classhc_1_1array__view.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="hc_8hpp_source.html">hc.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for hc::array_view&lt; T, N &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classhc_1_1array__view__coll__graph.png" border="0" usemap="#hc_1_1array__view_3_01T_00_01N_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="hc_1_1array__view_3_01T_00_01N_01_4_coll__map" id="hc_1_1array__view_3_01T_00_01N_01_4_coll__map">
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0afdf806bba8fec07dbd8ea152612196"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0afdf806bba8fec07dbd8ea152612196"></a>
typedef std::remove_const&lt; T &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>nc_T</b></td></tr>
<tr class="separator:a0afdf806bba8fec07dbd8ea152612196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a830367dcbe6d6beefb0f7a090750e168"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a830367dcbe6d6beefb0f7a090750e168"></a>
typedef Kalmar::_data_host&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>acc_buffer_t</b></td></tr>
<tr class="separator:a830367dcbe6d6beefb0f7a090750e168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9bbaec6741a5697622466edc80fecc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c9bbaec6741a5697622466edc80fecc"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#a1c9bbaec6741a5697622466edc80fecc">value_type</a></td></tr>
<tr class="memdesc:a1c9bbaec6741a5697622466edc80fecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The element type of this array. <br /></td></tr>
<tr class="separator:a1c9bbaec6741a5697622466edc80fecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1a4cc9ed0cbcf765f23f12b7dd70c33d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a4cc9ed0cbcf765f23f12b7dd70c33d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#a1a4cc9ed0cbcf765f23f12b7dd70c33d">array_view</a> ()=delete</td></tr>
<tr class="memdesc:a1a4cc9ed0cbcf765f23f12b7dd70c33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">There is no default constructor for array_view&lt;T,N&gt;. <br /></td></tr>
<tr class="separator:a1a4cc9ed0cbcf765f23f12b7dd70c33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c7de67a6973ab158c8e09eab195fda"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#a96c7de67a6973ab158c8e09eab195fda">array_view</a> (<a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;src) __CPU__ __HC__</td></tr>
<tr class="memdesc:a96c7de67a6973ab158c8e09eab195fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> which is bound to the data contained in the "src" array.  <a href="#a96c7de67a6973ab158c8e09eab195fda">More...</a><br /></td></tr>
<tr class="separator:a96c7de67a6973ab158c8e09eab195fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01b4274cb0da9614f149f2e4406b9b4"><td class="memTemplParams" colspan="2">template&lt;typename Container , class  = typename std::enable_if&lt;__is_container&lt;Container&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:af01b4274cb0da9614f149f2e4406b9b4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#af01b4274cb0da9614f149f2e4406b9b4">array_view</a> (const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;<a class="el" href="classhc_1_1extent.html">extent</a>, Container &amp;src)</td></tr>
<tr class="memdesc:af01b4274cb0da9614f149f2e4406b9b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> which is bound to the data contained in the "src" container.  <a href="#af01b4274cb0da9614f149f2e4406b9b4">More...</a><br /></td></tr>
<tr class="separator:af01b4274cb0da9614f149f2e4406b9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7b5d0cee6c3e28e40f78edf822a779"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#a0e7b5d0cee6c3e28e40f78edf822a779">array_view</a> (const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;ext, <a class="el" href="classhc_1_1array__view.html#a1c9bbaec6741a5697622466edc80fecc">value_type</a> *src) __CPU__ __HC__</td></tr>
<tr class="memdesc:a0e7b5d0cee6c3e28e40f78edf822a779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> which is bound to the data contained in the "src" container.  <a href="#a0e7b5d0cee6c3e28e40f78edf822a779">More...</a><br /></td></tr>
<tr class="separator:a0e7b5d0cee6c3e28e40f78edf822a779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f76dfeac9a8901c89e8ea316060921f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#a3f76dfeac9a8901c89e8ea316060921f">array_view</a> (const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;ext)</td></tr>
<tr class="memdesc:a3f76dfeac9a8901c89e8ea316060921f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> which is not bound to a data source.  <a href="#a3f76dfeac9a8901c89e8ea316060921f">More...</a><br /></td></tr>
<tr class="separator:a3f76dfeac9a8901c89e8ea316060921f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84969223ecf2b3594a7ac30f0d89dbdf"><td class="memTemplParams" colspan="2">template&lt;typename Container , class  = typename std::enable_if&lt;__is_container&lt;Container&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a84969223ecf2b3594a7ac30f0d89dbdf"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#a84969223ecf2b3594a7ac30f0d89dbdf">array_view</a> (int e0, Container &amp;src)</td></tr>
<tr class="memdesc:a84969223ecf2b3594a7ac30f0d89dbdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to construction using "array_view(extent&lt;N&gt;(e0 [, e1 [, e2 ]]), src)".  <a href="#a84969223ecf2b3594a7ac30f0d89dbdf">More...</a><br /></td></tr>
<tr class="separator:a84969223ecf2b3594a7ac30f0d89dbdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56da1e3c0bb526975c6fe8bb7bf7ffe9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a56da1e3c0bb526975c6fe8bb7bf7ffe9"></a>
template&lt;typename Container , class  = typename std::enable_if&lt;__is_container&lt;Container&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a56da1e3c0bb526975c6fe8bb7bf7ffe9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>array_view</b> (int e0, int e1, Container &amp;src)</td></tr>
<tr class="separator:a56da1e3c0bb526975c6fe8bb7bf7ffe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afffff1250af81f0e9c1a2beaeb949297"><td class="memTemplParams" colspan="2"><a class="anchor" id="afffff1250af81f0e9c1a2beaeb949297"></a>
template&lt;typename Container , class  = typename std::enable_if&lt;__is_container&lt;Container&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:afffff1250af81f0e9c1a2beaeb949297"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>array_view</b> (int e0, int e1, int e2, Container &amp;src)</td></tr>
<tr class="separator:afffff1250af81f0e9c1a2beaeb949297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669b2f992839647b4ebe8ec3008e8691"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#a669b2f992839647b4ebe8ec3008e8691">array_view</a> (int e0, <a class="el" href="classhc_1_1array__view.html#a1c9bbaec6741a5697622466edc80fecc">value_type</a> *src) __CPU__ __HC__</td></tr>
<tr class="memdesc:a669b2f992839647b4ebe8ec3008e8691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to construction using "array_view(extent&lt;N&gt;(e0 [, e1 [, e2 ]]), src)".  <a href="#a669b2f992839647b4ebe8ec3008e8691">More...</a><br /></td></tr>
<tr class="separator:a669b2f992839647b4ebe8ec3008e8691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e377cf222605151887e35cae9dbc22e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e377cf222605151887e35cae9dbc22e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>array_view</b> (int e0, int e1, <a class="el" href="classhc_1_1array__view.html#a1c9bbaec6741a5697622466edc80fecc">value_type</a> *src) __CPU__ __HC__</td></tr>
<tr class="separator:a9e377cf222605151887e35cae9dbc22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d57a05d165809b3d9f4c2900b4b7413"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d57a05d165809b3d9f4c2900b4b7413"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>array_view</b> (int e0, int e1, int e2, <a class="el" href="classhc_1_1array__view.html#a1c9bbaec6741a5697622466edc80fecc">value_type</a> *src) __CPU__ __HC__</td></tr>
<tr class="separator:a0d57a05d165809b3d9f4c2900b4b7413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc08cb24d46ecc71a61df30eb5ee824"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#a9dc08cb24d46ecc71a61df30eb5ee824">array_view</a> (int e0)</td></tr>
<tr class="memdesc:a9dc08cb24d46ecc71a61df30eb5ee824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to construction using "array_view(extent&lt;N&gt;(e0 [, e1 [, e2 ]]))".  <a href="#a9dc08cb24d46ecc71a61df30eb5ee824">More...</a><br /></td></tr>
<tr class="separator:a9dc08cb24d46ecc71a61df30eb5ee824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652b792bce99e7e4410d075ece8a4a9c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a652b792bce99e7e4410d075ece8a4a9c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>array_view</b> (int e0, int e1)</td></tr>
<tr class="separator:a652b792bce99e7e4410d075ece8a4a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb84efe26b836edc064def3830dc889"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bb84efe26b836edc064def3830dc889"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>array_view</b> (int e0, int e1, int e2)</td></tr>
<tr class="separator:a8bb84efe26b836edc064def3830dc889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4901e78e7ce6c2a11f828e378f5e5e81"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#a4901e78e7ce6c2a11f828e378f5e5e81">array_view</a> (const <a class="el" href="classhc_1_1array__view.html">array_view</a> &amp;other) __CPU__ __HC__</td></tr>
<tr class="memdesc:a4901e78e7ce6c2a11f828e378f5e5e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a4901e78e7ce6c2a11f828e378f5e5e81">More...</a><br /></td></tr>
<tr class="separator:a4901e78e7ce6c2a11f828e378f5e5e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb513133615616bad75ee61aec8f2f5d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb513133615616bad75ee61aec8f2f5d"></a>
<a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#aeb513133615616bad75ee61aec8f2f5d">get_extent</a> () const __CPU__ __HC__</td></tr>
<tr class="memdesc:aeb513133615616bad75ee61aec8f2f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the extent that defines the shape of this <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a>. <br /></td></tr>
<tr class="separator:aeb513133615616bad75ee61aec8f2f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd2fa5a42b3c75ebd1ee37632b35de3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#adbd2fa5a42b3c75ebd1ee37632b35de3">get_source_accelerator_view</a> () const </td></tr>
<tr class="memdesc:adbd2fa5a42b3c75ebd1ee37632b35de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> where the data source of the <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> is located.  <a href="#adbd2fa5a42b3c75ebd1ee37632b35de3">More...</a><br /></td></tr>
<tr class="separator:adbd2fa5a42b3c75ebd1ee37632b35de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c39586c424b32effdb28325c9b39c76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1array__view.html">array_view</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#a4c39586c424b32effdb28325c9b39c76">operator=</a> (const <a class="el" href="classhc_1_1array__view.html">array_view</a> &amp;other) __CPU__ __HC__</td></tr>
<tr class="memdesc:a4c39586c424b32effdb28325c9b39c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the contents of the <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> "other" to this <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a>, using a shallow copy.  <a href="#a4c39586c424b32effdb28325c9b39c76">More...</a><br /></td></tr>
<tr class="separator:a4c39586c424b32effdb28325c9b39c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c9bbd83803a522396c077c35ba33cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#a48c9bbd83803a522396c077c35ba33cb">copy_to</a> (<a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;dest) const </td></tr>
<tr class="memdesc:a48c9bbd83803a522396c077c35ba33cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data referred to by this <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> to the array given by "dest", as if by calling "copy(*this, dest)".  <a href="#a48c9bbd83803a522396c077c35ba33cb">More...</a><br /></td></tr>
<tr class="separator:a48c9bbd83803a522396c077c35ba33cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae523c2e7263591a9b50f0d56cff2920a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#ae523c2e7263591a9b50f0d56cff2920a">copy_to</a> (const <a class="el" href="classhc_1_1array__view.html">array_view</a> &amp;dest) const </td></tr>
<tr class="memdesc:ae523c2e7263591a9b50f0d56cff2920a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the contents of this <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> to the <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> given by "dest", as if by calling "copy(*this, dest)".  <a href="#ae523c2e7263591a9b50f0d56cff2920a">More...</a><br /></td></tr>
<tr class="separator:ae523c2e7263591a9b50f0d56cff2920a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a22c62add287cca017c1c87a117c9ea"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#a9a22c62add287cca017c1c87a117c9ea">data</a> () const __CPU__ __HC__</td></tr>
<tr class="memdesc:a9a22c62add287cca017c1c87a117c9ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the first data element underlying this <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a>.  <a href="#a9a22c62add287cca017c1c87a117c9ea">More...</a><br /></td></tr>
<tr class="separator:a9a22c62add287cca017c1c87a117c9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf41a0d8c4aa8dc56f8b5cbec302ec9a"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#abf41a0d8c4aa8dc56f8b5cbec302ec9a">accelerator_pointer</a> () const __CPU__ __HC__</td></tr>
<tr class="memdesc:abf41a0d8c4aa8dc56f8b5cbec302ec9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the device memory underlying this <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a>.  <a href="#abf41a0d8c4aa8dc56f8b5cbec302ec9a">More...</a><br /></td></tr>
<tr class="separator:abf41a0d8c4aa8dc56f8b5cbec302ec9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16311987bccaadd258c6c718cc581263"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#a16311987bccaadd258c6c718cc581263">refresh</a> () const </td></tr>
<tr class="memdesc:a16311987bccaadd258c6c718cc581263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calling this member function informs the <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> that its bound memory has been modified outside the <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> interface.  <a href="#a16311987bccaadd258c6c718cc581263">More...</a><br /></td></tr>
<tr class="separator:a16311987bccaadd258c6c718cc581263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91256fd57dd172ac91f47b95265d7353"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#a91256fd57dd172ac91f47b95265d7353">synchronize</a> () const </td></tr>
<tr class="memdesc:a91256fd57dd172ac91f47b95265d7353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calling this member function synchronizes any modifications made to the data underlying "this" <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> to its source data container.  <a href="#a91256fd57dd172ac91f47b95265d7353">More...</a><br /></td></tr>
<tr class="separator:a91256fd57dd172ac91f47b95265d7353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10e5fd406b3c851b7700ac67f4c4fce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#ad10e5fd406b3c851b7700ac67f4c4fce">synchronize_async</a> () const </td></tr>
<tr class="memdesc:ad10e5fd406b3c851b7700ac67f4c4fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">An asynchronous version of synchronize, which returns a completion future object.  <a href="#ad10e5fd406b3c851b7700ac67f4c4fce">More...</a><br /></td></tr>
<tr class="separator:ad10e5fd406b3c851b7700ac67f4c4fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e3550e5b40ccc9240f24c7f376eece"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#a34e3550e5b40ccc9240f24c7f376eece">synchronize_to</a> (const <a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a> &amp;av) const </td></tr>
<tr class="memdesc:a34e3550e5b40ccc9240f24c7f376eece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calling this member function synchronizes any modifications made to the data underlying "this" <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> to the specified <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> "av".  <a href="#a34e3550e5b40ccc9240f24c7f376eece">More...</a><br /></td></tr>
<tr class="separator:a34e3550e5b40ccc9240f24c7f376eece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113caab9854212638c5efeaeb968c637"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#a113caab9854212638c5efeaeb968c637">synchronize_to_async</a> (const <a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a> &amp;av) const </td></tr>
<tr class="memdesc:a113caab9854212638c5efeaeb968c637"><td class="mdescLeft">&#160;</td><td class="mdescRight">An asynchronous version of synchronize_to, which returns a completion future object.  <a href="#a113caab9854212638c5efeaeb968c637">More...</a><br /></td></tr>
<tr class="separator:a113caab9854212638c5efeaeb968c637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4852ac14c9ccf3914c36be12dd4c2faf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#a4852ac14c9ccf3914c36be12dd4c2faf">discard_data</a> () const </td></tr>
<tr class="memdesc:a4852ac14c9ccf3914c36be12dd4c2faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates to the runtime that it may discard the current logical contents of this <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a>.  <a href="#a4852ac14c9ccf3914c36be12dd4c2faf">More...</a><br /></td></tr>
<tr class="separator:a4852ac14c9ccf3914c36be12dd4c2faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c44e7bae852861424052e00a49002bc"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#a5c44e7bae852861424052e00a49002bc">get_ref</a> (const <a class="el" href="namespacehc.html#a76d71e557b828b0789b178426021e066">index</a>&lt; N &gt; &amp;idx) const __CPU__ __HC__</td></tr>
<tr class="memdesc:a5c44e7bae852861424052e00a49002bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element of this <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> that is at the location in N-dimensional space specified by "idx".  <a href="#a5c44e7bae852861424052e00a49002bc">More...</a><br /></td></tr>
<tr class="separator:a5c44e7bae852861424052e00a49002bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d972f15fdebc8cc42ed758d92ae9b9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#a4d972f15fdebc8cc42ed758d92ae9b9a">section</a> (const <a class="el" href="namespacehc.html#a76d71e557b828b0789b178426021e066">index</a>&lt; N &gt; &amp;idx, const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;ext) const __CPU__ __HC__</td></tr>
<tr class="memdesc:a4d972f15fdebc8cc42ed758d92ae9b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a subsection of the source array view at the origin specified by "idx" and with the extent specified by "ext".  <a href="#a4d972f15fdebc8cc42ed758d92ae9b9a">More...</a><br /></td></tr>
<tr class="separator:a4d972f15fdebc8cc42ed758d92ae9b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f0d998a3a8457385083b8168ec6c81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84f0d998a3a8457385083b8168ec6c81"></a>
<a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#a84f0d998a3a8457385083b8168ec6c81">section</a> (const <a class="el" href="namespacehc.html#a76d71e557b828b0789b178426021e066">index</a>&lt; N &gt; &amp;idx) const __CPU__ __HC__</td></tr>
<tr class="memdesc:a84f0d998a3a8457385083b8168ec6c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to "section(idx, this-&gt;extent – idx)". <br /></td></tr>
<tr class="separator:a84f0d998a3a8457385083b8168ec6c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda132407b08ca8006d597e367a38e46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abda132407b08ca8006d597e367a38e46"></a>
<a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#abda132407b08ca8006d597e367a38e46">section</a> (const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;ext) const __CPU__ __HC__</td></tr>
<tr class="memdesc:abda132407b08ca8006d597e367a38e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to "section(index&lt;N&gt;(), ext)". <br /></td></tr>
<tr class="separator:abda132407b08ca8006d597e367a38e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0139ec6d7f8608baf062f9373a5195a3"><td class="memTemplParams" colspan="2">template&lt;typename ElementType &gt; </td></tr>
<tr class="memitem:a0139ec6d7f8608baf062f9373a5195a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; ElementType, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#a0139ec6d7f8608baf062f9373a5195a3">reinterpret_as</a> () const __CPU__ __HC__</td></tr>
<tr class="memdesc:a0139ec6d7f8608baf062f9373a5195a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This member function is similar to "array&lt;T,N&gt;::reinterpret_as", although it only supports array_views of rank 1 (only those guarantee that all elements are laid out contiguously).  <a href="#a0139ec6d7f8608baf062f9373a5195a3">More...</a><br /></td></tr>
<tr class="separator:a0139ec6d7f8608baf062f9373a5195a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea0281f34efd256986e1692613b43fd"><td class="memTemplParams" colspan="2">template&lt;int K&gt; </td></tr>
<tr class="memitem:adea0281f34efd256986e1692613b43fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, K &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#adea0281f34efd256986e1692613b43fd">view_as</a> (<a class="el" href="classhc_1_1extent.html">extent</a>&lt; K &gt; viewExtent) const __CPU__ __HC__</td></tr>
<tr class="memdesc:adea0281f34efd256986e1692613b43fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This member function is similar to "array&lt;T,N&gt;::view_as", although it only supports array_views of rank 1 (only those guarantee that all elements are laid out contiguously).  <a href="#adea0281f34efd256986e1692613b43fd">More...</a><br /></td></tr>
<tr class="separator:adea0281f34efd256986e1692613b43fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503677c8f7f4177b9cdd9a66eedbbdb0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a503677c8f7f4177b9cdd9a66eedbbdb0"></a>
const acc_buffer_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>internal</b> () const __CPU__ __HC__</td></tr>
<tr class="separator:a503677c8f7f4177b9cdd9a66eedbbdb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24631e999cec19e444937d58441d23e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24631e999cec19e444937d58441d23e4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>get_offset</b> () const __CPU__ __HC__</td></tr>
<tr class="separator:a24631e999cec19e444937d58441d23e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bc8bda9bdd3d57599f612f7ccfe27d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64bc8bda9bdd3d57599f612f7ccfe27d"></a>
<a class="el" href="namespacehc.html#a76d71e557b828b0789b178426021e066">index</a>&lt; N &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_index_base</b> () const __CPU__ __HC__</td></tr>
<tr class="separator:a64bc8bda9bdd3d57599f612f7ccfe27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a67ba8d7271fa10e927e1bfc2cc759420"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#a67ba8d7271fa10e927e1bfc2cc759420">operator[]</a> (const <a class="el" href="namespacehc.html#a76d71e557b828b0789b178426021e066">index</a>&lt; N &gt; &amp;idx) const __CPU__ __HC__</td></tr>
<tr class="memdesc:a67ba8d7271fa10e927e1bfc2cc759420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element of this <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> that is at the location in N-dimensional space specified by "idx".  <a href="#a67ba8d7271fa10e927e1bfc2cc759420">More...</a><br /></td></tr>
<tr class="separator:a67ba8d7271fa10e927e1bfc2cc759420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4647ad1d742680f862cc7aa71079952f"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#a4647ad1d742680f862cc7aa71079952f">operator()</a> (const <a class="el" href="namespacehc.html#a76d71e557b828b0789b178426021e066">index</a>&lt; N &gt; &amp;idx) const __CPU__ __HC__</td></tr>
<tr class="memdesc:a4647ad1d742680f862cc7aa71079952f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element of this <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> that is at the location in N-dimensional space specified by "idx".  <a href="#a4647ad1d742680f862cc7aa71079952f">More...</a><br /></td></tr>
<tr class="separator:a4647ad1d742680f862cc7aa71079952f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa09e4efb49a6ccfb0d76b8736ca20b54"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#aa09e4efb49a6ccfb0d76b8736ca20b54">operator()</a> (int i0, int i1) const __CPU__ __HC__</td></tr>
<tr class="memdesc:aa09e4efb49a6ccfb0d76b8736ca20b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to "array_view&lt;T,N&gt;::operator()(index&lt;N&gt;(i0 [, i1 [, i2 ]]))".  <a href="#aa09e4efb49a6ccfb0d76b8736ca20b54">More...</a><br /></td></tr>
<tr class="separator:aa09e4efb49a6ccfb0d76b8736ca20b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ee0df2a2c1135dcba1cfe5ec717d4c"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#ac5ee0df2a2c1135dcba1cfe5ec717d4c">operator()</a> (int i0, int i1, int i2) const __CPU__ __HC__</td></tr>
<tr class="memdesc:ac5ee0df2a2c1135dcba1cfe5ec717d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to "array_view&lt;T,N&gt;::operator()(index&lt;N&gt;(i0 [, i1 [, i2 ]]))".  <a href="#ac5ee0df2a2c1135dcba1cfe5ec717d4c">More...</a><br /></td></tr>
<tr class="separator:ac5ee0df2a2c1135dcba1cfe5ec717d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae33f7f5ce1bedfb899a7003c8e482f6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhc_1_1projection__helper.html">projection_helper</a>&lt; T, N &gt;::result_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#ae33f7f5ce1bedfb899a7003c8e482f6c">operator[]</a> (int i) const __CPU__ __HC__</td></tr>
<tr class="memdesc:ae33f7f5ce1bedfb899a7003c8e482f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This overload is defined for array_view&lt;T,N&gt; where <img class="formulaInl" alt="$N \ge 2$" src="form_7.png"/>.  <a href="#ae33f7f5ce1bedfb899a7003c8e482f6c">More...</a><br /></td></tr>
<tr class="separator:ae33f7f5ce1bedfb899a7003c8e482f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac051a0ce840c0b14f42ea7cbc0b696e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhc_1_1projection__helper.html">projection_helper</a>&lt; T, N &gt;::result_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#ac051a0ce840c0b14f42ea7cbc0b696e9">operator()</a> (int i0) const __CPU__ __HC__</td></tr>
<tr class="memdesc:ac051a0ce840c0b14f42ea7cbc0b696e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This overload is defined for array_view&lt;T,N&gt; where <img class="formulaInl" alt="$N \ge 2$" src="form_7.png"/>.  <a href="#ac051a0ce840c0b14f42ea7cbc0b696e9">More...</a><br /></td></tr>
<tr class="separator:ac051a0ce840c0b14f42ea7cbc0b696e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2592f21f9f595017aa86c2a22d03bbef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#a2592f21f9f595017aa86c2a22d03bbef">section</a> (int i0, int e0) const __CPU__ __HC__</td></tr>
<tr class="memdesc:a2592f21f9f595017aa86c2a22d03bbef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to "section(index&lt;N&gt;(i0 [, i1 [, i2 ]]), extent&lt;N&gt;(e0 [, e1 [, e2 ]]))".  <a href="#a2592f21f9f595017aa86c2a22d03bbef">More...</a><br /></td></tr>
<tr class="separator:a2592f21f9f595017aa86c2a22d03bbef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae102c3e56df04a3e60a58c35247d1866"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#ae102c3e56df04a3e60a58c35247d1866">section</a> (int i0, int i1, int e0, int e1) const __CPU__ __HC__</td></tr>
<tr class="memdesc:ae102c3e56df04a3e60a58c35247d1866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to "section(index&lt;N&gt;(i0 [, i1 [, i2 ]]), extent&lt;N&gt;(e0 [, e1 [, e2 ]]))".  <a href="#ae102c3e56df04a3e60a58c35247d1866">More...</a><br /></td></tr>
<tr class="separator:ae102c3e56df04a3e60a58c35247d1866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43af8e85d341798b7ed2941ae09929e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#a43af8e85d341798b7ed2941ae09929e6">section</a> (int i0, int i1, int i2, int e0, int e1, int e2) const __CPU__ __HC__</td></tr>
<tr class="memdesc:a43af8e85d341798b7ed2941ae09929e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to "section(index&lt;N&gt;(i0 [, i1 [, i2 ]]), extent&lt;N&gt;(e0 [, e1 [, e2 ]]))".  <a href="#a43af8e85d341798b7ed2941ae09929e6">More...</a><br /></td></tr>
<tr class="separator:a43af8e85d341798b7ed2941ae09929e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:accc97624c01cbf1633fc2f30535d475c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="accc97624c01cbf1633fc2f30535d475c"></a>
static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html#accc97624c01cbf1633fc2f30535d475c">rank</a> = N</td></tr>
<tr class="memdesc:accc97624c01cbf1633fc2f30535d475c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rank of this array. <br /></td></tr>
<tr class="separator:accc97624c01cbf1633fc2f30535d475c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a20592c0d8f5fdc6da8e193be1bd7d201"><td class="memTemplParams" colspan="2"><a class="anchor" id="a20592c0d8f5fdc6da8e193be1bd7d201"></a>
template&lt;typename K , int Q&gt; </td></tr>
<tr class="memitem:a20592c0d8f5fdc6da8e193be1bd7d201"><td class="memTemplItemLeft" align="right" valign="top">struct&#160;</td><td class="memTemplItemRight" valign="bottom"><b>projection_helper</b></td></tr>
<tr class="separator:a20592c0d8f5fdc6da8e193be1bd7d201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3828da46bcd244a8b65e70db0c208a"><td class="memTemplParams" colspan="2"><a class="anchor" id="aad3828da46bcd244a8b65e70db0c208a"></a>
template&lt;typename K , int Q&gt; </td></tr>
<tr class="memitem:aad3828da46bcd244a8b65e70db0c208a"><td class="memTemplItemLeft" align="right" valign="top">struct&#160;</td><td class="memTemplItemRight" valign="bottom"><b>array_projection_helper</b></td></tr>
<tr class="separator:aad3828da46bcd244a8b65e70db0c208a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5c2ff8d26f3e271ca30322cba48e55"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7a5c2ff8d26f3e271ca30322cba48e55"></a>
template&lt;typename Q , int K&gt; </td></tr>
<tr class="memitem:a7a5c2ff8d26f3e271ca30322cba48e55"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>array</b></td></tr>
<tr class="separator:a7a5c2ff8d26f3e271ca30322cba48e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1428cb4ad41918c12d64cc0bb4b2445d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1428cb4ad41918c12d64cc0bb4b2445d"></a>
template&lt;typename Q , int K&gt; </td></tr>
<tr class="memitem:a1428cb4ad41918c12d64cc0bb4b2445d"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>array_view</b></td></tr>
<tr class="separator:a1428cb4ad41918c12d64cc0bb4b2445d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5830ced8641f2fde584b6d3efa020c2f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5830ced8641f2fde584b6d3efa020c2f"></a>
template&lt;typename Q , int K&gt; </td></tr>
<tr class="memitem:a5830ced8641f2fde584b6d3efa020c2f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_flat</b> (const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; Q, K &gt; &amp;) noexcept</td></tr>
<tr class="separator:a5830ced8641f2fde584b6d3efa020c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ef6fc0226d4b1f135b91a5c982f94f"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae4ef6fc0226d4b1f135b91a5c982f94f"></a>
template&lt;typename Q , int K&gt; </td></tr>
<tr class="memitem:ae4ef6fc0226d4b1f135b91a5c982f94f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy</b> (const <a class="el" href="classhc_1_1array.html">array</a>&lt; Q, K &gt; &amp;, const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; Q, K &gt; &amp;)</td></tr>
<tr class="separator:ae4ef6fc0226d4b1f135b91a5c982f94f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5567adc8b4e37b50cce4a1d95db8f421"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5567adc8b4e37b50cce4a1d95db8f421"></a>
template&lt;typename InputIter , typename Q , int K&gt; </td></tr>
<tr class="memitem:a5567adc8b4e37b50cce4a1d95db8f421"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy</b> (InputIter, InputIter, const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; Q, K &gt; &amp;)</td></tr>
<tr class="separator:a5567adc8b4e37b50cce4a1d95db8f421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1cee1eeca61020c040d1ec94330ba7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0c1cee1eeca61020c040d1ec94330ba7"></a>
template&lt;typename Q , int K&gt; </td></tr>
<tr class="memitem:a0c1cee1eeca61020c040d1ec94330ba7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy</b> (const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; const Q, K &gt; &amp;, <a class="el" href="classhc_1_1array.html">array</a>&lt; Q, K &gt; &amp;)</td></tr>
<tr class="separator:a0c1cee1eeca61020c040d1ec94330ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ae71aaeb057908d5bfa41d774ba670"><td class="memTemplParams" colspan="2"><a class="anchor" id="a65ae71aaeb057908d5bfa41d774ba670"></a>
template&lt;typename OutputIter , typename Q , int K&gt; </td></tr>
<tr class="memitem:a65ae71aaeb057908d5bfa41d774ba670"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy</b> (const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; Q, K &gt; &amp;, OutputIter)</td></tr>
<tr class="separator:a65ae71aaeb057908d5bfa41d774ba670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f0baae6bcafbd6c8c600262add12df"><td class="memTemplParams" colspan="2"><a class="anchor" id="a40f0baae6bcafbd6c8c600262add12df"></a>
template&lt;typename Q , int K&gt; </td></tr>
<tr class="memitem:a40f0baae6bcafbd6c8c600262add12df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy</b> (const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; const Q, K &gt; &amp;src, const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; Q, K &gt; &amp;dest)</td></tr>
<tr class="separator:a40f0baae6bcafbd6c8c600262add12df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, int N = 1&gt;<br />
class hc::array_view&lt; T, N &gt;</h3>

<p>The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T,N&gt;, or a section thereof. </p>
<p>It also provides such views over native CPU data. It exposes an indexing interface congruent to that of array&lt;T,N&gt;. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a96c7de67a6973ab158c8e09eab195fda"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1array__view.html">hc::array_view</a>&lt; T, N &gt;::<a class="el" href="classhc_1_1array__view.html">array_view</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> which is bound to the data contained in the "src" array. </p>
<p>The extent of the <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> is that of the src array, and the origin of the array view is at zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An array which contains the data that this <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> is bound to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af01b4274cb0da9614f149f2e4406b9b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N = 1&gt; </div>
<div class="memtemplate">
template&lt;typename Container , class  = typename std::enable_if&lt;__is_container&lt;Container&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1array__view.html">hc::array_view</a>&lt; T, N &gt;::<a class="el" href="classhc_1_1array__view.html">array_view</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> which is bound to the data contained in the "src" container. </p>
<p>The extent of the <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> is that given by the "extent" argument, and the origin of the array view is at zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>A template argument that must resolve to a linear container that supports .<a class="el" href="classhc_1_1array__view.html#a9a22c62add287cca017c1c87a117c9ea" title="Returns a pointer to the first data element underlying this array_view. ">data()</a> and .size() members (such as std::vector or std::array) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">extent</td><td>The extent of this <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0e7b5d0cee6c3e28e40f78edf822a779"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1array__view.html">hc::array_view</a>&lt; T, N &gt;::<a class="el" href="classhc_1_1array__view.html">array_view</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhc_1_1array__view.html#a1c9bbaec6741a5697622466edc80fecc">value_type</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> which is bound to the data contained in the "src" container. </p>
<p>The extent of the <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> is that given by the "extent" argument, and the origin of the array view is at zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>A pointer to the source data this <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> will bind to. If the number of elements pointed to is less than the size of extent, the behavior is undefined. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ext</td><td>The extent of this <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classhc_1_1extent.html#abea07ecd32585b4c5778986e9f6b0f08">hc::extent&lt; N &gt;::size()</a>.</p>

</div>
</div>
<a class="anchor" id="a3f76dfeac9a8901c89e8ea316060921f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1array__view.html">hc::array_view</a>&lt; T, N &gt;::<a class="el" href="classhc_1_1array__view.html">array_view</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>ext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> which is not bound to a data source. </p>
<p>The extent of the <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> is that given by the "extent" argument, and the origin of the array view is at zero. An <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> thus constructed represents uninitialized data and the underlying allocations are created lazily as the <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> is accessed on different locations (on an <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> or on the CPU).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ext</td><td>The extent of this <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a84969223ecf2b3594a7ac30f0d89dbdf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N = 1&gt; </div>
<div class="memtemplate">
template&lt;typename Container , class  = typename std::enable_if&lt;__is_container&lt;Container&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1array__view.html">hc::array_view</a>&lt; T, N &gt;::<a class="el" href="classhc_1_1array__view.html">array_view</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>e0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to construction using "array_view(extent&lt;N&gt;(e0 [, e1 [, e2 ]]), src)". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e0,e1,e2</td><td>The component values that will form the extent of this <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>A template argument that must resolve to a contiguousi container that supports .<a class="el" href="classhc_1_1array__view.html#a9a22c62add287cca017c1c87a117c9ea" title="Returns a pointer to the first data element underlying this array_view. ">data()</a> and .size() members (such as std::vector or std::array) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a669b2f992839647b4ebe8ec3008e8691"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1array__view.html">hc::array_view</a>&lt; T, N &gt;::<a class="el" href="classhc_1_1array__view.html">array_view</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>e0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhc_1_1array__view.html#a1c9bbaec6741a5697622466edc80fecc">value_type</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to construction using "array_view(extent&lt;N&gt;(e0 [, e1 [, e2 ]]), src)". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e0,e1,e2</td><td>The component values that will form the extent of this <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>A pointer to the source data this <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> will bind to. If the number of elements pointed to is less than the size of extent, the behavior is undefined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9dc08cb24d46ecc71a61df30eb5ee824"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1array__view.html">hc::array_view</a>&lt; T, N &gt;::<a class="el" href="classhc_1_1array__view.html">array_view</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>e0</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to construction using "array_view(extent&lt;N&gt;(e0 [, e1 [, e2 ]]))". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e0,e1,e2</td><td>The component values that will form the extent of this <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4901e78e7ce6c2a11f828e378f5e5e81"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1array__view.html">hc::array_view</a>&lt; T, N &gt;::<a class="el" href="classhc_1_1array__view.html">array_view</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Constructs an <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> from the supplied argument other. A shallow copy is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>An object of type array_view&lt;T,N&gt; or <a class="el" href="classhc_1_1array__view_3_01const_01T_00_01N_01_4.html" title="The partial specialization array_view&lt;const T,N&gt; represents a view over elements of type const T with...">array_view&lt;const T,N&gt;</a> from which to initialize this new <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="abf41a0d8c4aa8dc56f8b5cbec302ec9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classhc_1_1array__view.html">hc::array_view</a>&lt; T, N &gt;::accelerator_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the device memory underlying this <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A (const) pointer to the first element in the <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> on the device memory. </dd></dl>

</div>
</div>
<a class="anchor" id="a48c9bbd83803a522396c077c35ba33cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhc_1_1array__view.html">hc::array_view</a>&lt; T, N &gt;::copy_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the data referred to by this <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> to the array given by "dest", as if by calling "copy(*this, dest)". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>An object of type array &lt;T,N&gt; to which to copy data from this array. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespacehc.html#a33b400529b72d0e9c26c4b9083e2d681">hc::copy()</a>, and <a class="el" href="classhc_1_1array.html#a81381e99ff73f2314e2c32a5f196aa6a">hc::array&lt; T, N &gt;::get_extent()</a>.</p>

</div>
</div>
<a class="anchor" id="ae523c2e7263591a9b50f0d56cff2920a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhc_1_1array__view.html">hc::array_view</a>&lt; T, N &gt;::copy_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the contents of this <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> to the <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> given by "dest", as if by calling "copy(*this, dest)". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>An object of type array_view&lt;T,N&gt; to which to copy data from this array. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespacehc.html#a33b400529b72d0e9c26c4b9083e2d681">hc::copy()</a>.</p>

</div>
</div>
<a class="anchor" id="a9a22c62add287cca017c1c87a117c9ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classhc_1_1array__view.html">hc::array_view</a>&lt; T, N &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the first data element underlying this <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a>. </p>
<p>This is only available on array_views of rank 1.</p>
<p>When the data source of the <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> is native CPU memory, the pointer returned by <a class="el" href="classhc_1_1array__view.html#a9a22c62add287cca017c1c87a117c9ea" title="Returns a pointer to the first data element underlying this array_view. ">data()</a> is valid for the lifetime of the data source.</p>
<p>When the data source underlying the <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> is an array, or the array view is created without a data source, the pointer returned by <a class="el" href="classhc_1_1array__view.html#a9a22c62add287cca017c1c87a117c9ea" title="Returns a pointer to the first data element underlying this array_view. ">data()</a> in CPU context is ephemeral and is invalidated when the original data source or any of its views are accessed on an <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> through a parallel_for_each or a copy operation.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first element in the linearized array. </dd></dl>

</div>
</div>
<a class="anchor" id="a4852ac14c9ccf3914c36be12dd4c2faf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhc_1_1array__view.html">hc::array_view</a>&lt; T, N &gt;::discard_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates to the runtime that it may discard the current logical contents of this <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a>. </p>
<p>This is an optimization hint to the runtime used to avoid copying the current contents of the view to a target <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a>, and its use is recommended if the existing content is not needed. </p>

</div>
</div>
<a class="anchor" id="a5c44e7bae852861424052e00a49002bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classhc_1_1array__view.html">hc::array_view</a>&lt; T, N &gt;::get_ref </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehc.html#a76d71e557b828b0789b178426021e066">index</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the element of this <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> that is at the location in N-dimensional space specified by "idx". </p>
<p>Unlike the other indexing operators for accessing the <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> on the CPU, this method does not implicitly synchronize this <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a>'s contents to the CPU. After accessing the <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> on a remote location or performing a copy operation involving this <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a>, users are responsible to explicitly synchronize the <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> to the CPU before calling this method. Failure to do so results in undefined behavior. </p>

</div>
</div>
<a class="anchor" id="adbd2fa5a42b3c75ebd1ee37632b35de3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a> <a class="el" href="classhc_1_1array__view.html">hc::array_view</a>&lt; T, N &gt;::get_source_accelerator_view </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> where the data source of the <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> is located. </p>
<p>When the data source of the <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> is native CPU memory, the method returns accelerator(accelerator::cpu_accelerator).default_view. When the data source underlying the <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> is an array, the method returns the <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> where the source array is located. </p>

</div>
</div>
<a class="anchor" id="a4647ad1d742680f862cc7aa71079952f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classhc_1_1array__view.html">hc::array_view</a>&lt; T, N &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehc.html#a76d71e557b828b0789b178426021e066">index</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element of this <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> that is at the location in N-dimensional space specified by "idx". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>An object of type index&lt;N&gt; that specifies the location of the element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa09e4efb49a6ccfb0d76b8736ca20b54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classhc_1_1array__view.html">hc::array_view</a>&lt; T, N &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to "array_view&lt;T,N&gt;::operator()(index&lt;N&gt;(i0 [, i1 [, i2 ]]))". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i0,i1,i2</td><td>The component values that will form the index into this array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac5ee0df2a2c1135dcba1cfe5ec717d4c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classhc_1_1array__view.html">hc::array_view</a>&lt; T, N &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to "array_view&lt;T,N&gt;::operator()(index&lt;N&gt;(i0 [, i1 [, i2 ]]))". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i0,i1,i2</td><td>The component values that will form the index into this array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac051a0ce840c0b14f42ea7cbc0b696e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhc_1_1projection__helper.html">projection_helper</a>&lt;T, N&gt;::result_type <a class="el" href="classhc_1_1array__view.html">hc::array_view</a>&lt; T, N &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This overload is defined for array_view&lt;T,N&gt; where <img class="formulaInl" alt="$N \ge 2$" src="form_7.png"/>. </p>
<p>This mode of indexing is equivalent to projecting on the most-significant dimension. It allows C-style indexing. For example:</p>
<div class="fragment"><div class="line">array&lt;float,4&gt; myArray(myExtents, ...);</div><div class="line"></div><div class="line">myArray[index&lt;4&gt;(5,4,3,2)] = 7;</div><div class="line">assert(myArray[5][4][3][2] == 7);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i0</td><td>An integer that is the index into the most-significant dimension of this array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> whose dimension is one lower than that of this <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a4c39586c424b32effdb28325c9b39c76"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1array__view.html">array_view</a>&amp; <a class="el" href="classhc_1_1array__view.html">hc::array_view</a>&lt; T, N &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the contents of the <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> "other" to this <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a>, using a shallow copy. </p>
<p>Both array_views will refer to the same data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>An object of type array_view&lt;T,N&gt; from which to copy into this array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns *this. </dd></dl>

<p>References <a class="el" href="classhc_1_1extent.html#a3f6f2e14790b1a997fc11a6b5d38a86d">hc::extent&lt; N &gt;::extent()</a>.</p>

</div>
</div>
<a class="anchor" id="a67ba8d7271fa10e927e1bfc2cc759420"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classhc_1_1array__view.html">hc::array_view</a>&lt; T, N &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehc.html#a76d71e557b828b0789b178426021e066">index</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element of this <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> that is at the location in N-dimensional space specified by "idx". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>An object of type index&lt;N&gt; that specifies the location of the element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae33f7f5ce1bedfb899a7003c8e482f6c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhc_1_1projection__helper.html">projection_helper</a>&lt;T, N&gt;::result_type <a class="el" href="classhc_1_1array__view.html">hc::array_view</a>&lt; T, N &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This overload is defined for array_view&lt;T,N&gt; where <img class="formulaInl" alt="$N \ge 2$" src="form_7.png"/>. </p>
<p>This mode of indexing is equivalent to projecting on the most-significant dimension. It allows C-style indexing. For example:</p>
<div class="fragment"><div class="line">array&lt;float,4&gt; myArray(myExtents, ...);</div><div class="line"></div><div class="line">myArray[index&lt;4&gt;(5,4,3,2)] = 7;</div><div class="line">assert(myArray[5][4][3][2] == 7);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i0</td><td>An integer that is the index into the most-significant dimension of this array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> whose dimension is one lower than that of this <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a16311987bccaadd258c6c718cc581263"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhc_1_1array__view.html">hc::array_view</a>&lt; T, N &gt;::refresh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calling this member function informs the <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> that its bound memory has been modified outside the <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> interface. </p>
<p>This will render all cached information stale. </p>

</div>
</div>
<a class="anchor" id="a0139ec6d7f8608baf062f9373a5195a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N = 1&gt; </div>
<div class="memtemplate">
template&lt;typename ElementType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1array__view.html">array_view</a>&lt;ElementType, N&gt; <a class="el" href="classhc_1_1array__view.html">hc::array_view</a>&lt; T, N &gt;::reinterpret_as </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This member function is similar to "array&lt;T,N&gt;::reinterpret_as", although it only supports array_views of rank 1 (only those guarantee that all elements are laid out contiguously). </p>
<p>The size of the reinterpreted ElementType must evenly divide into the total size of this <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns an <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> from this array_view&lt;T,1&gt; with the element type reinterpreted from T to ElementType. </dd></dl>

<p>References <a class="el" href="classhc_1_1extent.html#abea07ecd32585b4c5778986e9f6b0f08">hc::extent&lt; N &gt;::size()</a>.</p>

</div>
</div>
<a class="anchor" id="a4d972f15fdebc8cc42ed758d92ae9b9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1array__view.html">array_view</a>&lt;T, N&gt; <a class="el" href="classhc_1_1array__view.html">hc::array_view</a>&lt; T, N &gt;::section </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehc.html#a76d71e557b828b0789b178426021e066">index</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>ext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a subsection of the source array view at the origin specified by "idx" and with the extent specified by "ext". </p>
<p>Example:</p>
<div class="fragment"><div class="line">array&lt;float,2&gt; a(extent&lt;2&gt;(200,100));</div><div class="line">array_view&lt;float,2&gt; v1(a); <span class="comment">// v1.extent = &lt;200,100&gt;</span></div><div class="line">array_view&lt;float,2&gt; v2 = v1.section(index&lt;2&gt;(15,25), extent&lt;2&gt;(40,50));</div><div class="line">assert(v2(0,0) == v1(15,25));</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Provides the offset/origin of the resulting section. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ext</td><td>Provides the extent of the resulting section. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a subsection of the source array at specified origin, and with the specified extent. </dd></dl>

<p>Referenced by <a class="el" href="classhc_1_1array.html#a47d13ba36d048eafedc50500b6b6b3cf">hc::array&lt; T, N &gt;::section()</a>.</p>

</div>
</div>
<a class="anchor" id="a2592f21f9f595017aa86c2a22d03bbef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1array__view.html">array_view</a>&lt;T, 1&gt; <a class="el" href="classhc_1_1array__view.html">hc::array_view</a>&lt; T, N &gt;::section </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>e0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to "section(index&lt;N&gt;(i0 [, i1 [, i2 ]]), extent&lt;N&gt;(e0 [, e1 [, e2 ]]))". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i0,i1,i2</td><td>The component values that will form the origin of the section </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e0,e1,e2</td><td>The component values that will form the extent of the section </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae102c3e56df04a3e60a58c35247d1866"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1array__view.html">array_view</a>&lt;T, 2&gt; <a class="el" href="classhc_1_1array__view.html">hc::array_view</a>&lt; T, N &gt;::section </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>e0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>e1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to "section(index&lt;N&gt;(i0 [, i1 [, i2 ]]), extent&lt;N&gt;(e0 [, e1 [, e2 ]]))". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i0,i1,i2</td><td>The component values that will form the origin of the section </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e0,e1,e2</td><td>The component values that will form the extent of the section </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a43af8e85d341798b7ed2941ae09929e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1array__view.html">array_view</a>&lt;T, 3&gt; <a class="el" href="classhc_1_1array__view.html">hc::array_view</a>&lt; T, N &gt;::section </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>e0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to "section(index&lt;N&gt;(i0 [, i1 [, i2 ]]), extent&lt;N&gt;(e0 [, e1 [, e2 ]]))". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i0,i1,i2</td><td>The component values that will form the origin of the section </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e0,e1,e2</td><td>The component values that will form the extent of the section </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a91256fd57dd172ac91f47b95265d7353"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhc_1_1array__view.html">hc::array_view</a>&lt; T, N &gt;::synchronize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calling this member function synchronizes any modifications made to the data underlying "this" <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> to its source data container. </p>
<p>For example, for an <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> on system memory, if the data underlying the view are modified on a remote <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> through a parallel_for_each invocation, calling synchronize ensures that the modifications are synchronized to the source data and will be visible through the system memory pointer which the <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> was created over.</p>
<p>For writable <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> objects, callers of this functional can optionally specify the type of access desired on the source data container through the "type" parameter. For example specifying a "access_type_read" (which is also the default value of the parameter) indicates that the data has been synchronized to its source location only for reading. On the other hand, specifying an access_type of "access_type_read_write" synchronizes the data to its source location both for reading and writing; i.e. any modifications to the source data directly through the source data container are legal after synchronizing the <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> with write access and before subsequently accessing the <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> on another remote location.</p>
<p>It is advisable to be precise about the access_type specified in the synchronize call; i.e. if only write access it required, specifying access_type_write may yield better performance that calling synchronize with "access_type_read_write" since the later may require any modifications made to the data on remote locations to be synchronized to the source location, which is unnecessary if the contents are intended to be overwritten without reading.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>An argument of type "access_type" which specifies the type of access on the data source that the <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> is synchronized for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad10e5fd406b3c851b7700ac67f4c4fce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1completion__future.html">completion_future</a> <a class="el" href="classhc_1_1array__view.html">hc::array_view</a>&lt; T, N &gt;::synchronize_async </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An asynchronous version of synchronize, which returns a completion future object. </p>
<p>When the future is ready, the synchronization operation is complete.</p>
<dl class="section return"><dt>Returns</dt><dd>An object of type <a class="el" href="classhc_1_1completion__future.html" title="This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_...">completion_future</a> that can be used to determine the status of the asynchronous operation or can be used to chain other operations to be executed after the completion of the asynchronous operation. </dd></dl>

</div>
</div>
<a class="anchor" id="a34e3550e5b40ccc9240f24c7f376eece"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhc_1_1array__view.html">hc::array_view</a>&lt; T, N &gt;::synchronize_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a> &amp;&#160;</td>
          <td class="paramname"><em>av</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calling this member function synchronizes any modifications made to the data underlying "this" <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> to the specified <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> "av". </p>
<p>For example, for an <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> on system memory, if the data underlying the view is modified on the CPU, and synchronize_to is called on "this" <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a>, then the <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> contents are cached on the specified <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> location.</p>
<p>For writable <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> objects, callers of this functional can optionally specify the type of access desired on the specified target <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> "av", through the "type" parameter. For example specifying a "access_type_read" (which is also the default value of the parameter) indicates that the data has been synchronized to "av" only for reading. On the other hand, specifying an access_type of "access_type_read_write" synchronizes the data to "av" both for reading and writing; i.e. any modifications to the data on "av" are legal after synchronizing the <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> with write access and before subsequently accessing the <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> on a location other than "av".</p>
<p>It is advisable to be precise about the access_type specified in the synchronize call; i.e. if only write access it required, specifying access_type_write may yield better performance that calling synchronize with "access_type_read_write" since the later may require any modifications made to the data on remote locations to be synchronized to "av", which is unnecessary if the contents are intended to be immediately overwritten without reading.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">av</td><td>The target <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> that "this" <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> is synchronized for access on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>An argument of type "access_type" which specifies the type of access on the data source that the <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> is synchronized for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a113caab9854212638c5efeaeb968c637"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1completion__future.html">completion_future</a> <a class="el" href="classhc_1_1array__view.html">hc::array_view</a>&lt; T, N &gt;::synchronize_to_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a> &amp;&#160;</td>
          <td class="paramname"><em>av</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An asynchronous version of synchronize_to, which returns a completion future object. </p>
<p>When the future is ready, the synchronization operation is complete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">av</td><td>The target <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> that "this" <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> is synchronized for access on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>An argument of type "access_type" which specifies the type of access on the data source that the <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> is synchronized for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object of type <a class="el" href="classhc_1_1completion__future.html" title="This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_...">completion_future</a> that can be used to determine the status of the asynchronous operation or can be used to chain other operations to be executed after the completion of the asynchronous operation. </dd></dl>

</div>
</div>
<a class="anchor" id="adea0281f34efd256986e1692613b43fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N = 1&gt; </div>
<div class="memtemplate">
template&lt;int K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1array__view.html">array_view</a>&lt;T, K&gt; <a class="el" href="classhc_1_1array__view.html">hc::array_view</a>&lt; T, N &gt;::view_as </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhc_1_1extent.html">extent</a>&lt; K &gt;&#160;</td>
          <td class="paramname"><em>viewExtent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This member function is similar to "array&lt;T,N&gt;::view_as", although it only supports array_views of rank 1 (only those guarantee that all elements are laid out contiguously). </p>
<dl class="section return"><dt>Returns</dt><dd>Returns an <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">array_view</a> from this array_view&lt;T,1&gt; with the rank changed to K from 1. </dd></dl>

<p>References <a class="el" href="namespacehc.html#a33b400529b72d0e9c26c4b9083e2d681">hc::copy()</a>, and <a class="el" href="classhc_1_1extent.html#abea07ecd32585b4c5778986e9f6b0f08">hc::extent&lt; N &gt;::size()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/scchan/code/hcc/include/<a class="el" href="hc_8hpp_source.html">hc.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 13 2017 13:11:18 for HCC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
