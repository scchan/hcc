<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>HCC: HC API : Moving Beyond C++AMP for Accelerated GPU Computing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HCC
   </div>
   <div id="projectbrief">HCC is a single-source, C/C++ compiler for heterogeneous computing.  It&#39;s optimized with HSA (http://www.hsafoundation.com/).</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">HC API : Moving Beyond C++AMP for Accelerated GPU Computing </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>HC is a C++ API for accelerated computing provided by the HCC compiler. It has some similarities to C++ AMP and therefore, reference materials (blogs, articles, books) that describe C++ AMP also proivide an excellent way to become familiar with HC. For example, both APIs use a parallel_for_each construct to specify a parallel execution region that runs on accelerator. However, HC has several important differences from C++ AMP, including the removal of the "restrict" keyword to annotate device code, an explicit asynchronous launch behavior for parallel_for_each, the support for non-constant tile size, the support for memory pointer, etc.. </p><hr/>
<h1>HC API</h1>
<p>HC comes with two header files as of now:</p>
<ul>
<li>&lt;<a class="el" href="hc_8hpp.html" title="Heterogeneous C++ (HC) API. ">hc.hpp</a>&gt; : Main header file for HC</li>
<li>&lt;<a class="el" href="hc__math_8hpp_source.html">hc_math.hpp</a>&gt; : Math functions for HC</li>
</ul>
<p>Most HC APIs are stored under "hc" namespace, and the class name is the same as their counterpart in C++AMP "Concurrency" namespace. Users of C++AMP should find it easy to switch from C++AMP to HC.</p>
<table class="doxtable">
<tr>
<th>C++AMP </th><th>HC  </th></tr>
<tr>
<td><a class="el" href="classConcurrency_1_1accelerator.html" title="Represents a physical accelerated computing device. ">Concurrency::accelerator</a> </td><td><a class="el" href="classhc_1_1accelerator.html" title="Represents a physical accelerated computing device. ">hc::accelerator</a> </td></tr>
<tr>
<td><a class="el" href="classConcurrency_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">Concurrency::accelerator_view</a> </td><td><a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">hc::accelerator_view</a> </td></tr>
<tr>
<td><a class="el" href="classConcurrency_1_1extent.html" title="Represents a unique position in N-dimensional space. ">Concurrency::extent</a> </td><td><a class="el" href="classhc_1_1extent.html" title="Represents a unique position in N-dimensional space. ">hc::extent</a> </td></tr>
<tr>
<td><a class="el" href="namespaceConcurrency.html#a4dd2162c732649580363efdf787e71c5" title="Represents a unique position in N-dimensional space. ">Concurrency::index</a> </td><td><a class="el" href="namespacehc.html#a76d71e557b828b0789b178426021e066" title="Represents a unique position in N-dimensional space. ">hc::index</a> </td></tr>
<tr>
<td><a class="el" href="classConcurrency_1_1completion__future.html" title="This class is the return type of all C++ AMP asynchronous APIs and has an interface analogous to std:...">Concurrency::completion_future</a> </td><td><a class="el" href="classhc_1_1completion__future.html" title="This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_...">hc::completion_future</a> </td></tr>
<tr>
<td><a class="el" href="classConcurrency_1_1array.html" title="Represents an N-dimensional region of memory (with type T) located on an accelerator. ">Concurrency::array</a> </td><td><a class="el" href="classhc_1_1array.html" title="Represents an N-dimensional region of memory (with type T) located on an accelerator. ">hc::array</a> </td></tr>
<tr>
<td><a class="el" href="classConcurrency_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">Concurrency::array_view</a> </td><td><a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">hc::array_view</a> </td></tr>
</table>
<hr/>
<h1>How to build programs with HC API</h1>
<p>Use "hcc-config", instead of "clamp-config", or you could manually add "-hc" when you invoke clang++. Also, "hcc" is added as an alias for "clang++".</p>
<p>For example:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hcc `hcc-config --cxxflags --ldflags` foo.cpp -o foo</div></div><!-- fragment --> <hr/>
<h1>HCC built-in macros</h1>
<p>Built-in macros:</p>
<table class="doxtable">
<tr>
<th>Macro </th><th>Meaning  </th></tr>
<tr>
<td><code>__HCC__</code> </td><td>always be 1 </td></tr>
<tr>
<td><code>__hcc_major__</code> </td><td>major version number of HCC </td></tr>
<tr>
<td><code>__hcc_minor__</code> </td><td>minor version number of HCC </td></tr>
<tr>
<td><code>__hcc_patchlevel__</code> </td><td>patchlevel of HCC </td></tr>
<tr>
<td><code>__hcc_version__</code> </td><td>combined string of <code>__hcc_major__</code>, <code>__hcc_minor__</code>, <code>__hcc_patchlevel__</code> </td></tr>
</table>
<p>The rule for <code>__hcc_patchlevel__</code> is: yyWW-(HCC driver git commit #)-(HCC clang git commit #)</p><ul>
<li>yy stands for the last 2 digits of the year</li>
<li>WW stands for the week number of the year</li>
</ul>
<p>Macros for language modes in use:</p>
<table class="doxtable">
<tr>
<th>Macro </th><th>Meaning  </th></tr>
<tr>
<td><code>__HCC_AMP__</code> </td><td>1 in case in C++ AMP mode (-std=c++amp) </td></tr>
<tr>
<td><code>__HCC_HC__</code> </td><td>1 in case in HC mode (-hc) </td></tr>
</table>
<p>Compilation mode: HCC is a single-source compiler where kernel codes and host codes can reside in the same file. Internally HCC would trigger 2 compilation iterations, and the following macros can be user by user programs to determine which mode the compiler is in.</p>
<table class="doxtable">
<tr>
<th>Macro </th><th>Meaning  </th></tr>
<tr>
<td><code>__HCC_ACCELERATOR__</code> </td><td>not 0 in case the compiler runs in kernel code compilation mode </td></tr>
<tr>
<td><code>__HCC_CPU__</code> </td><td>not 0 in case the compiler runs in host code compilation mode </td></tr>
</table>
<hr/>
<h1>HC-specific features</h1>
<ul>
<li>relaxed rules in operations allowed in kernels</li>
<li>new syntax of tiled_extent and tiled_index</li>
<li>dynamic group segment memory allocation</li>
<li>true asynchronous kernel launching behavior</li>
<li>additional HSA-specific APIs</li>
</ul>
<h1>Differences between HC API and C++ AMP</h1>
<p>Despite HC and C++ AMP share a lot of similarities in terms of programming constructs (e.g. parallel_for_each, array, array_view, etc.), there are several significant differences between the two APIs.</p>
<h2>Support for explicit asynchronous <code>parallel_for_each</code></h2>
<p>In C++ AMP, the <code>parallel_for_each</code> appears as a synchronous function call in a program (i.e. the host waits for the kernel to complete); howevever, the compiler may optimize it to execute the kernel asynchronously and the host would synchronize with the device on the first access of the data modified by the kernel. For example, if a <code>parallel_for_each</code> writes the an array_view, then the first access to this array_view on the host after the <code>parallel_for_each</code> would block until the <code>parallel_for_each</code> completes.</p>
<p>HC supports the automatic synchronization behavior as in C++ AMP. In addition, HC's <code>parallel_for_each</code> supports explicit asynchronous execution. It returns a <code>completion_future</code> (similar to C++ std::future) object that other asynchronous operations could synchronize with, which provides better flexibility on task graph construction and enables more precise control on optimization.</p>
<h2>Annotation of device functions</h2>
<p>C++ AMP uses the <code>restrict(amp)</code> keyword to annotatate functions that runs on the device.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void foo() restrict(amp) {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;..</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;}</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;...</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;parallel_for_each(...,[=] () restrict(amp) {</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160; foo();</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;});</div></div><!-- fragment --><p>HC uses a function attribute (<code>[[hc]]</code> or <code>__attribute__((hc))</code> ) to annotate a device function.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void foo()  [[hc]] {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;..</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;}</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;...</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;parallel_for_each(...,[=] () [[hc]] {</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160; foo();</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;});</div></div><!-- fragment --><p>The [[hc]] annotation for the kernel function called by <code>parallel_for_each</code> is optional as it is automatically annotated as a device function by the hcc compiler. The compiler also supports partial automatic [[hc]] annotation for functions that are called by other device functions within the same source file:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;// Since bar is called by foo, which is a device function, the hcc compiler</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;// will automatically annotate bar as a device function</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;void bar() {</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;...</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;void foo() [[hc]] {</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  bar();</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div></div><!-- fragment --><h2>Dynamic tile size</h2>
<p>C++ AMP doesn't support dynamic tile size. The size of each tile dimensions has to be a compile-time constant specified as template arguments to the tile_extent object:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;extent&lt;2&gt; ex(x, y);</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;// create a tile extent of 8x8 from the extent object</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;// note that the tile dimensions have to be constant values</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;tiled_extent&lt;8,8&gt; t_ex(ex);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;parallel_for_each(t_ex, [=](tiled_index&lt;8,8&gt; t_id) restrict(amp) {</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;...</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;});</div></div><!-- fragment --><p> HC supports both static and dynamic tile size: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;extent&lt;2&gt; ex(x,y)</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;// create a tile extent from dynamically calculated values</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;// note that the the tiled_extent template takes the rank instead of dimensions</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;tx = test_x ? tx_a : tx_b;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;ty = test_y ? ty_a : ty_b;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;tiled_extent&lt;2&gt; t_ex(ex, tx, ty);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;parallel_for_each(t_ex, [=](tiled_index&lt;2&gt; t_id) [[hc]] {</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;...</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;});</div></div><!-- fragment --><h2>Support for memory pointer</h2>
<p>C++ AMP doens't support lambda capture of memory pointer into a GPU kernel.</p>
<p>HC supports capturing memory pointer by a GPU kernel.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;// allocate GPU memory through the HSA API</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;int* gpu_pointer;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;hsa_memory_allocate(..., &amp;gpu_pointer);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;...</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;parallel_for_each(ext, [=](index i) [[hc]] {</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  gpu_pointer[i[0]]++;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div></div><!-- fragment --><p> For HSA APUs that supports system wide shared virtual memory, a GPU kernel can directly access system memory allocated by the host: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;int* cpu_memory = (int*) malloc(...);</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;...</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;parallel_for_each(ext, [=](index i) [[hc]] {</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  cpu_memory[i[0]]++;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;});</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 13 2017 13:11:18 for HCC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
