<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>HCC: Concurrency Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HCC
   </div>
   <div id="projectbrief">HCC is a single-source, C/C++ compiler for heterogeneous computing.  It&#39;s optimized with HSA (http://www.hsafoundation.com/).</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Concurrency Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>C++ AMP namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConcurrency_1_1____has__data.html">__has_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConcurrency_1_1____has__size.html">__has_size</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConcurrency_1_1____is__container.html">__is_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConcurrency_1_1accelerator.html">accelerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a physical accelerated computing device.  <a href="classConcurrency_1_1accelerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConcurrency_1_1accelerator__view.html">accelerator_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a logical (isolated) accelerator view of a compute accelerator.  <a href="classConcurrency_1_1accelerator__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConcurrency_1_1array.html">array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an N-dimensional region of memory (with type T) located on an accelerator.  <a href="classConcurrency_1_1array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConcurrency_1_1array__projection__helper.html">array_projection_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConcurrency_1_1array__projection__helper_3_01T_00_011_01_4.html">array_projection_helper&lt; T, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConcurrency_1_1array__view.html">array_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T,N&gt;, or a section thereof.  <a href="classConcurrency_1_1array__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConcurrency_1_1array__view_3_01const_01T_00_01N_01_4.html">array_view&lt; const T, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The partial specialization <a class="el" href="classConcurrency_1_1array__view_3_01const_01T_00_01N_01_4.html" title="The partial specialization array_view&lt;const T,N&gt; represents a view over elements of type const T with...">array_view&lt;const T,N&gt;</a> represents a view over elements of type const T with rank N.  <a href="classConcurrency_1_1array__view_3_01const_01T_00_01N_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is the return type of all C++ AMP asynchronous APIs and has an interface analogous to std::shared_future&lt;void&gt;.  <a href="classConcurrency_1_1completion__future.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConcurrency_1_1copy__bidir.html">copy_bidir</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConcurrency_1_1copy__bidir_3_01T_00_01N_00_01N_01_4.html">copy_bidir&lt; T, N, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConcurrency_1_1copy__input.html">copy_input</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConcurrency_1_1copy__input_3_01InputIter_00_01T_00_01N_00_01N_01_4.html">copy_input&lt; InputIter, T, N, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConcurrency_1_1copy__output.html">copy_output</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConcurrency_1_1copy__output_3_01OutputIter_00_01T_00_01N_00_01N_01_4.html">copy_output&lt; OutputIter, T, N, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConcurrency_1_1do__copy.html">do_copy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConcurrency_1_1do__copy_3_01Iter_00_01T_00_011_01_4.html">do_copy&lt; Iter, T, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConcurrency_1_1do__copy_3_01T_01_5_00_01T_00_011_01_4.html">do_copy&lt; T *, T, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConcurrency_1_1do__copy_3_01T_01_5_00_01T_00_01N_01_4.html">do_copy&lt; T *, T, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConcurrency_1_1extent.html">extent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a unique position in N-dimensional space.  <a href="classConcurrency_1_1extent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConcurrency_1_1pfe__helper.html">pfe_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConcurrency_1_1pfe__helper_3_010_00_01Kernel_00_01__Tp_01_4.html">pfe_helper&lt; 0, Kernel, _Tp &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConcurrency_1_1pfe__wrapper.html">pfe_wrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConcurrency_1_1projection__helper.html">projection_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConcurrency_1_1projection__helper_3_01const_01T_00_011_01_4.html">projection_helper&lt; const T, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConcurrency_1_1projection__helper_3_01const_01T_00_01N_01_4.html">projection_helper&lt; const T, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConcurrency_1_1projection__helper_3_01T_00_011_01_4.html">projection_helper&lt; T, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConcurrency_1_1tile__barrier.html">tile_barrier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classConcurrency_1_1tile__barrier.html" title="The tile_barrier class is a capability class that is only creatable by the system, and passed to a tiled parallel_for_each function object as part of the tiled_index parameter. ">tile_barrier</a> class is a capability class that is only creatable by the system, and passed to a tiled parallel_for_each function object as part of the <a class="el" href="classConcurrency_1_1tiled__index.html" title="Represents a set of related indices subdivided into 1-, 2-, or 3-dimensional tiles. ">tiled_index</a> parameter.  <a href="classConcurrency_1_1tile__barrier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConcurrency_1_1tiled__extent.html">tiled_extent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an extent subdivided into 1-, 2-, or 3-dimensional tiles.  <a href="classConcurrency_1_1tiled__extent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConcurrency_1_1tiled__extent_3_01D0_00_010_00_010_01_4.html">tiled_extent&lt; D0, 0, 0 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an extent subdivided into 1-, 2-, or 3-dimensional tiles.  <a href="classConcurrency_1_1tiled__extent_3_01D0_00_010_00_010_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConcurrency_1_1tiled__extent_3_01D0_00_01D1_00_010_01_4.html">tiled_extent&lt; D0, D1, 0 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an extent subdivided into 1-, 2-, or 3-dimensional tiles.  <a href="classConcurrency_1_1tiled__extent_3_01D0_00_01D1_00_010_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConcurrency_1_1tiled__index.html">tiled_index</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a set of related indices subdivided into 1-, 2-, or 3-dimensional tiles.  <a href="classConcurrency_1_1tiled__index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConcurrency_1_1tiled__index_3_01D0_00_010_00_010_01_4.html">tiled_index&lt; D0, 0, 0 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a set of related indices subdivided into 1-, 2-, or 3-dimensional tiles.  <a href="classConcurrency_1_1tiled__index_3_01D0_00_010_00_010_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConcurrency_1_1tiled__index_3_01D0_00_01D1_00_010_01_4.html">tiled_index&lt; D0, D1, 0 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a set of related indices subdivided into 1-, 2-, or 3-dimensional tiles.  <a href="classConcurrency_1_1tiled__index_3_01D0_00_01D1_00_010_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4dd2162c732649580363efdf787e71c5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4dd2162c732649580363efdf787e71c5"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:a4dd2162c732649580363efdf787e71c5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a4dd2162c732649580363efdf787e71c5">index</a> = <a class="el" href="classKalmar_1_1index.html">Kalmar::index</a>&lt; N &gt;</td></tr>
<tr class="memdesc:a4dd2162c732649580363efdf787e71c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a unique position in N-dimensional space. <br /></td></tr>
<tr class="separator:a4dd2162c732649580363efdf787e71c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9033ff687bbfde883ac3e9d8e6ea203b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9033ff687bbfde883ac3e9d8e6ea203b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>runtime_exception</b> = <a class="el" href="classKalmar_1_1runtime__exception.html">Kalmar::runtime_exception</a></td></tr>
<tr class="separator:a9033ff687bbfde883ac3e9d8e6ea203b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d46f8395148066152157f565ce2e47"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7d46f8395148066152157f565ce2e47"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>invalid_compute_domain</b> = <a class="el" href="classKalmar_1_1invalid__compute__domain.html">Kalmar::invalid_compute_domain</a></td></tr>
<tr class="separator:ad7d46f8395148066152157f565ce2e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a10327013ffee303a73c4fa5200e33"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96a10327013ffee303a73c4fa5200e33"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>accelerator_view_removed</b> = <a class="el" href="classKalmar_1_1accelerator__view__removed.html">Kalmar::accelerator_view_removed</a></td></tr>
<tr class="separator:a96a10327013ffee303a73c4fa5200e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a937d14ca3ae392aebd5ba5c2b6b955a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a937d14ca3ae392aebd5ba5c2b6b955a2">all_memory_fence</a> (const <a class="el" href="classConcurrency_1_1tile__barrier.html">tile_barrier</a> &amp;)</td></tr>
<tr class="memdesc:a937d14ca3ae392aebd5ba5c2b6b955a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a thread-tile scoped memory fence for both global and tile-static memory operations.  <a href="#a937d14ca3ae392aebd5ba5c2b6b955a2">More...</a><br /></td></tr>
<tr class="separator:a937d14ca3ae392aebd5ba5c2b6b955a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfaa3abffa348ab345a95ad0335df59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a8dfaa3abffa348ab345a95ad0335df59">global_memory_fence</a> (const <a class="el" href="classConcurrency_1_1tile__barrier.html">tile_barrier</a> &amp;)</td></tr>
<tr class="memdesc:a8dfaa3abffa348ab345a95ad0335df59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a thread-tile scoped memory fence for global (but not tile-static) memory operations.  <a href="#a8dfaa3abffa348ab345a95ad0335df59">More...</a><br /></td></tr>
<tr class="separator:a8dfaa3abffa348ab345a95ad0335df59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0114fedd0ff8d9946be0cd817208600"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#ac0114fedd0ff8d9946be0cd817208600">tile_static_memory_fence</a> (const <a class="el" href="classConcurrency_1_1tile__barrier.html">tile_barrier</a> &amp;)</td></tr>
<tr class="memdesc:ac0114fedd0ff8d9946be0cd817208600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a thread-tile scoped memory fence for tile-static (but not global) memory operations.  <a href="#ac0114fedd0ff8d9946be0cd817208600">More...</a><br /></td></tr>
<tr class="separator:ac0114fedd0ff8d9946be0cd817208600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7ff4703e9f209590b295272621bbc6"><td class="memTemplParams" colspan="2"><a class="anchor" id="acd7ff4703e9f209590b295272621bbc6"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:acd7ff4703e9f209590b295272621bbc6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classConcurrency_1_1extent.html">Concurrency::extent</a>&lt; N &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>check</b> (const <a class="el" href="classConcurrency_1_1extent.html">Concurrency::extent</a>&lt; N &gt; &amp;ext)</td></tr>
<tr class="separator:acd7ff4703e9f209590b295272621bbc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23adc223892aad81641fe55e501000a"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:ab23adc223892aad81641fe55e501000a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#ab23adc223892aad81641fe55e501000a">copy</a> (const <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;src, <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:ab23adc223892aad81641fe55e501000a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#ab23adc223892aad81641fe55e501000a">More...</a><br /></td></tr>
<tr class="separator:ab23adc223892aad81641fe55e501000a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb46bca2c652e1723cfd55d4e1f2071"><td class="memTemplParams" colspan="2">template&lt;typename OutputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:a1fb46bca2c652e1723cfd55d4e1f2071"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a1fb46bca2c652e1723cfd55d4e1f2071">copy</a> (const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;src, OutputIter destBegin)</td></tr>
<tr class="memdesc:a1fb46bca2c652e1723cfd55d4e1f2071"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of a source array are copied into "dest" starting with iterator destBegin.  <a href="#a1fb46bca2c652e1723cfd55d4e1f2071">More...</a><br /></td></tr>
<tr class="separator:a1fb46bca2c652e1723cfd55d4e1f2071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d765a0305f2b3a84c8f4fdc754c8e11"><td class="memTemplParams" colspan="2">template&lt;typename OutputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:a2d765a0305f2b3a84c8f4fdc754c8e11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a2d765a0305f2b3a84c8f4fdc754c8e11">copy</a> (const <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;src, OutputIter destBegin)</td></tr>
<tr class="memdesc:a2d765a0305f2b3a84c8f4fdc754c8e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of a source array are copied into "dest" starting with iterator destBegin.  <a href="#a2d765a0305f2b3a84c8f4fdc754c8e11">More...</a><br /></td></tr>
<tr class="separator:a2d765a0305f2b3a84c8f4fdc754c8e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f8f54d8e9be7bedddaeb40b3fe10c0"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:a79f8f54d8e9be7bedddaeb40b3fe10c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a79f8f54d8e9be7bedddaeb40b3fe10c0">copy_async</a> (const <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;src, <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:a79f8f54d8e9be7bedddaeb40b3fe10c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#a79f8f54d8e9be7bedddaeb40b3fe10c0">More...</a><br /></td></tr>
<tr class="separator:a79f8f54d8e9be7bedddaeb40b3fe10c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38037cf830a55d87004d0d7105f369d"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:ad38037cf830a55d87004d0d7105f369d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#ad38037cf830a55d87004d0d7105f369d">copy_async</a> (const <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;src, const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:ad38037cf830a55d87004d0d7105f369d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#ad38037cf830a55d87004d0d7105f369d">More...</a><br /></td></tr>
<tr class="separator:ad38037cf830a55d87004d0d7105f369d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9dd1c69e5c4383903d2686339fe722"><td class="memTemplParams" colspan="2">template&lt;typename OutputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:abf9dd1c69e5c4383903d2686339fe722"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#abf9dd1c69e5c4383903d2686339fe722">copy_async</a> (const <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;src, OutputIter destBegin)</td></tr>
<tr class="memdesc:abf9dd1c69e5c4383903d2686339fe722"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of a source array are copied into "dest" starting with iterator destBegin.  <a href="#abf9dd1c69e5c4383903d2686339fe722">More...</a><br /></td></tr>
<tr class="separator:abf9dd1c69e5c4383903d2686339fe722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404eae30679d066e133ae799b3ef3339"><td class="memTemplParams" colspan="2">template&lt;typename OutputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:a404eae30679d066e133ae799b3ef3339"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a404eae30679d066e133ae799b3ef3339">copy_async</a> (const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;src, OutputIter destBegin)</td></tr>
<tr class="memdesc:a404eae30679d066e133ae799b3ef3339"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of a source array are copied into "dest" starting with iterator destBegin.  <a href="#a404eae30679d066e133ae799b3ef3339">More...</a><br /></td></tr>
<tr class="separator:a404eae30679d066e133ae799b3ef3339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad936164f13dfdcf32703630b009477"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2ad936164f13dfdcf32703630b009477"></a>
template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:a2ad936164f13dfdcf32703630b009477"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_async</b> (const <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;src, const <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="separator:a2ad936164f13dfdcf32703630b009477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7f9ebbe5f267db492592b4a329fd16"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3f7f9ebbe5f267db492592b4a329fd16"></a>
template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:a3f7f9ebbe5f267db492592b4a329fd16"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_async</b> (const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; const T, N &gt; &amp;src, const <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="separator:a3f7f9ebbe5f267db492592b4a329fd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78e128bdcfc8e4083f499759ad4c493"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa78e128bdcfc8e4083f499759ad4c493"></a>
template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:aa78e128bdcfc8e4083f499759ad4c493"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_async</b> (const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;src, const <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="separator:aa78e128bdcfc8e4083f499759ad4c493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859061882a3d5a3c62d021caca358bfb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a859061882a3d5a3c62d021caca358bfb"></a>
template&lt;int N, typename Kernel &gt; </td></tr>
<tr class="memitem:a859061882a3d5a3c62d021caca358bfb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_for_each</b> (const <a class="el" href="classConcurrency_1_1accelerator__view.html">accelerator_view</a> &amp;, <a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt; compute_domain, const Kernel &amp;f)</td></tr>
<tr class="separator:a859061882a3d5a3c62d021caca358bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5a49a853be78e6cf8b4d02bcb08db2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4f5a49a853be78e6cf8b4d02bcb08db2"></a>
template&lt;int D0, int D1, int D2, typename Kernel &gt; </td></tr>
<tr class="memitem:a4f5a49a853be78e6cf8b4d02bcb08db2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_for_each</b> (const <a class="el" href="classConcurrency_1_1accelerator__view.html">accelerator_view</a> &amp;accl_view, <a class="el" href="classConcurrency_1_1tiled__extent.html">tiled_extent</a>&lt; D0, D1, D2 &gt; compute_domain, const Kernel &amp;f)</td></tr>
<tr class="separator:a4f5a49a853be78e6cf8b4d02bcb08db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f752eb451f4cc0318886ce53f63138b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5f752eb451f4cc0318886ce53f63138b"></a>
template&lt;int D0, int D1, typename Kernel &gt; </td></tr>
<tr class="memitem:a5f752eb451f4cc0318886ce53f63138b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_for_each</b> (const <a class="el" href="classConcurrency_1_1accelerator__view.html">accelerator_view</a> &amp;accl_view, <a class="el" href="classConcurrency_1_1tiled__extent.html">tiled_extent</a>&lt; D0, D1 &gt; compute_domain, const Kernel &amp;f)</td></tr>
<tr class="separator:a5f752eb451f4cc0318886ce53f63138b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0913bffaade123acf78d70c6342d4f"><td class="memTemplParams" colspan="2"><a class="anchor" id="aca0913bffaade123acf78d70c6342d4f"></a>
template&lt;int D0, typename Kernel &gt; </td></tr>
<tr class="memitem:aca0913bffaade123acf78d70c6342d4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_for_each</b> (const <a class="el" href="classConcurrency_1_1accelerator__view.html">accelerator_view</a> &amp;accl_view, <a class="el" href="classConcurrency_1_1tiled__extent.html">tiled_extent</a>&lt; D0 &gt; compute_domain, const Kernel &amp;f)</td></tr>
<tr class="separator:aca0913bffaade123acf78d70c6342d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16260e74c0887e693f115259a650b54"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae16260e74c0887e693f115259a650b54"></a>
template&lt;int N, typename Kernel &gt; </td></tr>
<tr class="memitem:ae16260e74c0887e693f115259a650b54"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_for_each</b> (<a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt; compute_domain, const Kernel &amp;f)</td></tr>
<tr class="separator:ae16260e74c0887e693f115259a650b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf5e8315a2609afb2b14eb0d286630d"><td class="memTemplParams" colspan="2"><a class="anchor" id="adbf5e8315a2609afb2b14eb0d286630d"></a>
template&lt;int D0, int D1, int D2, typename Kernel &gt; </td></tr>
<tr class="memitem:adbf5e8315a2609afb2b14eb0d286630d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_for_each</b> (<a class="el" href="classConcurrency_1_1tiled__extent.html">tiled_extent</a>&lt; D0, D1, D2 &gt; compute_domain, const Kernel &amp;f)</td></tr>
<tr class="separator:adbf5e8315a2609afb2b14eb0d286630d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9ff19a349e76e3f1f61c41f2b8b45b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9c9ff19a349e76e3f1f61c41f2b8b45b"></a>
template&lt;int D0, int D1, typename Kernel &gt; </td></tr>
<tr class="memitem:a9c9ff19a349e76e3f1f61c41f2b8b45b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_for_each</b> (<a class="el" href="classConcurrency_1_1tiled__extent.html">tiled_extent</a>&lt; D0, D1 &gt; compute_domain, const Kernel &amp;f)</td></tr>
<tr class="separator:a9c9ff19a349e76e3f1f61c41f2b8b45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af632fc086dae1968746ee2253a67fa76"><td class="memTemplParams" colspan="2"><a class="anchor" id="af632fc086dae1968746ee2253a67fa76"></a>
template&lt;int D0, typename Kernel &gt; </td></tr>
<tr class="memitem:af632fc086dae1968746ee2253a67fa76"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_for_each</b> (<a class="el" href="classConcurrency_1_1tiled__extent.html">tiled_extent</a>&lt; D0 &gt; compute_domain, const Kernel &amp;f)</td></tr>
<tr class="separator:af632fc086dae1968746ee2253a67fa76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32a946b96df39e13eef62bca0b52af4"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac32a946b96df39e13eef62bca0b52af4"></a>
template&lt;int N, typename Kernel &gt; </td></tr>
<tr class="memitem:ac32a946b96df39e13eef62bca0b52af4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>__attribute__</b> ((noinline, used)) void parallel_for_each(const <a class="el" href="classConcurrency_1_1accelerator__view.html">accelerator_view</a> &amp;av</td></tr>
<tr class="separator:ac32a946b96df39e13eef62bca0b52af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af069cf53e770b7917295098ff61e5c95"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af069cf53e770b7917295098ff61e5c95"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>for</b> (int i=0;i&lt; N;i++)</td></tr>
<tr class="separator:af069cf53e770b7917295098ff61e5c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba31baf00e8d5b2ee9152ae9c2a0ccb5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba31baf00e8d5b2ee9152ae9c2a0ccb5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (av.get_accelerator().get_device_path()==L&quot;cpu&quot;)</td></tr>
<tr class="separator:aba31baf00e8d5b2ee9152ae9c2a0ccb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2faaaeb099eac1bf85320aeaba98a2bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2faaaeb099eac1bf85320aeaba98a2bb"></a>
const <a class="el" href="classConcurrency_1_1pfe__wrapper.html">pfe_wrapper</a>&lt; N, Kernel &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_pf</b> (compute_domain, f)</td></tr>
<tr class="separator:a2faaaeb099eac1bf85320aeaba98a2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab6da1f54b301f099ee10eaebfb448a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4ab6da1f54b301f099ee10eaebfb448a"></a>
template&lt;typename Kernel &gt; </td></tr>
<tr class="memitem:a4ab6da1f54b301f099ee10eaebfb448a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>__attribute__</b> ((noinline, used)) void parallel_for_each(const <a class="el" href="classConcurrency_1_1accelerator__view.html">accelerator_view</a> &amp;av</td></tr>
<tr class="separator:a4ab6da1f54b301f099ee10eaebfb448a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67da848498ca6267cce2a22fc0eaed9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67da848498ca6267cce2a22fc0eaed9a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (static_cast&lt; size_t &gt;(compute_domain[1])*static_cast&lt; size_t &gt;(compute_domain[2]) &gt; 4294967295L) throw invalid_compute_domain(&quot;Extent size too large.&quot;)</td></tr>
<tr class="separator:a67da848498ca6267cce2a22fc0eaed9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c598369e99972e874890baef54795f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c598369e99972e874890baef54795f8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (static_cast&lt; size_t &gt;(compute_domain[0])*static_cast&lt; size_t &gt;(compute_domain[2]) &gt; 4294967295L) throw invalid_compute_domain(&quot;Extent size too large.&quot;)</td></tr>
<tr class="separator:a1c598369e99972e874890baef54795f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c488ecb13804b367ec5897eac66f8df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c488ecb13804b367ec5897eac66f8df"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (static_cast&lt; size_t &gt;(compute_domain[0])*static_cast&lt; size_t &gt;(compute_domain[1])*static_cast&lt; size_t &gt;(compute_domain[2]) &gt; 4294967295L) throw invalid_compute_domain(&quot;Extent size too large.&quot;)</td></tr>
<tr class="separator:a4c488ecb13804b367ec5897eac66f8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f07c37987e7d462dd300b021157453c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f07c37987e7d462dd300b021157453c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (ext%tile!=0)</td></tr>
<tr class="separator:a6f07c37987e7d462dd300b021157453c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c092ec0001875baa8da749189a058c4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9c092ec0001875baa8da749189a058c4"></a>
template&lt;int D0, int D1, typename Kernel &gt; </td></tr>
<tr class="memitem:a9c092ec0001875baa8da749189a058c4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>__attribute__</b> ((noinline, used)) void parallel_for_each(const <a class="el" href="classConcurrency_1_1accelerator__view.html">accelerator_view</a> &amp;av</td></tr>
<tr class="separator:a9c092ec0001875baa8da749189a058c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170848968e42585b224464a9c254bc25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a170848968e42585b224464a9c254bc25"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> ((ext[0]%tile[0]!=0)||(ext[1]%tile[1]!=0))</td></tr>
<tr class="separator:a170848968e42585b224464a9c254bc25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0a77d22ee5b3346792c6c617bc2ebe"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9d0a77d22ee5b3346792c6c617bc2ebe"></a>
template&lt;int D0, int D1, int D2, typename Kernel &gt; </td></tr>
<tr class="memitem:a9d0a77d22ee5b3346792c6c617bc2ebe"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>__attribute__</b> ((noinline, used)) void parallel_for_each(const <a class="el" href="classConcurrency_1_1accelerator__view.html">accelerator_view</a> &amp;av</td></tr>
<tr class="separator:a9d0a77d22ee5b3346792c6c617bc2ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95bab20d52673825a829f169cdde3424"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95bab20d52673825a829f169cdde3424"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> ((ext[0]%tile[0]!=0)||(ext[1]%tile[1]!=0)||(ext[2]%tile[2]!=0))</td></tr>
<tr class="separator:a95bab20d52673825a829f169cdde3424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a23f7bbd6e1bd4f6b6356f90adc8ea03f"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:a23f7bbd6e1bd4f6b6356f90adc8ea03f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a23f7bbd6e1bd4f6b6356f90adc8ea03f">copy</a> (const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; const T, N &gt; &amp;src, const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:a23f7bbd6e1bd4f6b6356f90adc8ea03f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#a23f7bbd6e1bd4f6b6356f90adc8ea03f">More...</a><br /></td></tr>
<tr class="separator:a23f7bbd6e1bd4f6b6356f90adc8ea03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0e2c07a98b85283c1c686139a5445f"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:a4d0e2c07a98b85283c1c686139a5445f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a4d0e2c07a98b85283c1c686139a5445f">copy</a> (const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;src, const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:a4d0e2c07a98b85283c1c686139a5445f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#a4d0e2c07a98b85283c1c686139a5445f">More...</a><br /></td></tr>
<tr class="separator:a4d0e2c07a98b85283c1c686139a5445f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd39928b6ae19239d955a9f78bc6cb8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4bd39928b6ae19239d955a9f78bc6cb8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a4bd39928b6ae19239d955a9f78bc6cb8">copy</a> (const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; const T, 1 &gt; &amp;src, const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, 1 &gt; &amp;dest)</td></tr>
<tr class="memdesc:a4bd39928b6ae19239d955a9f78bc6cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#a4bd39928b6ae19239d955a9f78bc6cb8">More...</a><br /></td></tr>
<tr class="separator:a4bd39928b6ae19239d955a9f78bc6cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aef51b57d2c9747b99e0e7a7dafc877d6"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:aef51b57d2c9747b99e0e7a7dafc877d6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#aef51b57d2c9747b99e0e7a7dafc877d6">copy</a> (const <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;src, const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:aef51b57d2c9747b99e0e7a7dafc877d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#aef51b57d2c9747b99e0e7a7dafc877d6">More...</a><br /></td></tr>
<tr class="separator:aef51b57d2c9747b99e0e7a7dafc877d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6d7497b0b983fdc7736c7356d00b7a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7b6d7497b0b983fdc7736c7356d00b7a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a7b6d7497b0b983fdc7736c7356d00b7a">copy</a> (const <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, 1 &gt; &amp;src, const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, 1 &gt; &amp;dest)</td></tr>
<tr class="memdesc:a7b6d7497b0b983fdc7736c7356d00b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#a7b6d7497b0b983fdc7736c7356d00b7a">More...</a><br /></td></tr>
<tr class="separator:a7b6d7497b0b983fdc7736c7356d00b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af24df9aabe7ffb92707603857f9970a9"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:af24df9aabe7ffb92707603857f9970a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#af24df9aabe7ffb92707603857f9970a9">copy</a> (const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; const T, N &gt; &amp;src, <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:af24df9aabe7ffb92707603857f9970a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#af24df9aabe7ffb92707603857f9970a9">More...</a><br /></td></tr>
<tr class="separator:af24df9aabe7ffb92707603857f9970a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0cb942b5308f0dabafb70992964be8"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:a4e0cb942b5308f0dabafb70992964be8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a4e0cb942b5308f0dabafb70992964be8">copy</a> (const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;src, <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:a4e0cb942b5308f0dabafb70992964be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#a4e0cb942b5308f0dabafb70992964be8">More...</a><br /></td></tr>
<tr class="separator:a4e0cb942b5308f0dabafb70992964be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482316212fd67380e214b5e17b6a6f10"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a482316212fd67380e214b5e17b6a6f10"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a482316212fd67380e214b5e17b6a6f10">copy</a> (const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; const T, 1 &gt; &amp;src, <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, 1 &gt; &amp;dest)</td></tr>
<tr class="memdesc:a482316212fd67380e214b5e17b6a6f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#a482316212fd67380e214b5e17b6a6f10">More...</a><br /></td></tr>
<tr class="separator:a482316212fd67380e214b5e17b6a6f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aab33beea5f006352370d18e0b127bb70"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:aab33beea5f006352370d18e0b127bb70"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#aab33beea5f006352370d18e0b127bb70">copy</a> (InputIter srcBegin, InputIter srcEnd, const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:aab33beea5f006352370d18e0b127bb70"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest".  <a href="#aab33beea5f006352370d18e0b127bb70">More...</a><br /></td></tr>
<tr class="separator:aab33beea5f006352370d18e0b127bb70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb988af963a7055faf0a9b00d19fee0"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:a9eb988af963a7055faf0a9b00d19fee0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a9eb988af963a7055faf0a9b00d19fee0">copy</a> (InputIter srcBegin, const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:a9eb988af963a7055faf0a9b00d19fee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest".  <a href="#a9eb988af963a7055faf0a9b00d19fee0">More...</a><br /></td></tr>
<tr class="separator:a9eb988af963a7055faf0a9b00d19fee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af028bde2ae43a052841f70b168910660"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:af028bde2ae43a052841f70b168910660"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#af028bde2ae43a052841f70b168910660">copy</a> (InputIter srcBegin, InputIter srcEnd, <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:af028bde2ae43a052841f70b168910660"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest".  <a href="#af028bde2ae43a052841f70b168910660">More...</a><br /></td></tr>
<tr class="separator:af028bde2ae43a052841f70b168910660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af840ca638732df054bfb58cf8067c618"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:af840ca638732df054bfb58cf8067c618"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#af840ca638732df054bfb58cf8067c618">copy</a> (InputIter srcBegin, <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:af840ca638732df054bfb58cf8067c618"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest".  <a href="#af840ca638732df054bfb58cf8067c618">More...</a><br /></td></tr>
<tr class="separator:af840ca638732df054bfb58cf8067c618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a54da7310acb21651d3352675f3f5871f"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a54da7310acb21651d3352675f3f5871f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a54da7310acb21651d3352675f3f5871f">operator+</a> (const <a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt; &amp;lhs, const <a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a54da7310acb21651d3352675f3f5871f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds (or subtracts) two objects of extent&lt;N&gt; to form a new extent.  <a href="#a54da7310acb21651d3352675f3f5871f">More...</a><br /></td></tr>
<tr class="separator:a54da7310acb21651d3352675f3f5871f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885a06a33e9d9e9c5866609bfaf202fd"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a885a06a33e9d9e9c5866609bfaf202fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a885a06a33e9d9e9c5866609bfaf202fd">operator-</a> (const <a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt; &amp;lhs, const <a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a885a06a33e9d9e9c5866609bfaf202fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds (or subtracts) two objects of extent&lt;N&gt; to form a new extent.  <a href="#a885a06a33e9d9e9c5866609bfaf202fd">More...</a><br /></td></tr>
<tr class="separator:a885a06a33e9d9e9c5866609bfaf202fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0a775ec79532dbcec7a408c87cee1fa1"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a0a775ec79532dbcec7a408c87cee1fa1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a0a775ec79532dbcec7a408c87cee1fa1">operator+</a> (const <a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt; &amp;ext, int value)</td></tr>
<tr class="memdesc:a0a775ec79532dbcec7a408c87cee1fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands.  <a href="#a0a775ec79532dbcec7a408c87cee1fa1">More...</a><br /></td></tr>
<tr class="separator:a0a775ec79532dbcec7a408c87cee1fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090732e407973bbc9b36317314975655"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a090732e407973bbc9b36317314975655"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a090732e407973bbc9b36317314975655">operator+</a> (int value, const <a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt; &amp;ext)</td></tr>
<tr class="memdesc:a090732e407973bbc9b36317314975655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands.  <a href="#a090732e407973bbc9b36317314975655">More...</a><br /></td></tr>
<tr class="separator:a090732e407973bbc9b36317314975655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf180fdbb091cf2380d63c4ebb70f48"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a9bf180fdbb091cf2380d63c4ebb70f48"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a9bf180fdbb091cf2380d63c4ebb70f48">operator-</a> (const <a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt; &amp;ext, int value)</td></tr>
<tr class="memdesc:a9bf180fdbb091cf2380d63c4ebb70f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands.  <a href="#a9bf180fdbb091cf2380d63c4ebb70f48">More...</a><br /></td></tr>
<tr class="separator:a9bf180fdbb091cf2380d63c4ebb70f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ba7f3d50a003f24bedcde77d8be630"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a71ba7f3d50a003f24bedcde77d8be630"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a71ba7f3d50a003f24bedcde77d8be630">operator-</a> (int value, const <a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt; &amp;ext)</td></tr>
<tr class="memdesc:a71ba7f3d50a003f24bedcde77d8be630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands.  <a href="#a71ba7f3d50a003f24bedcde77d8be630">More...</a><br /></td></tr>
<tr class="separator:a71ba7f3d50a003f24bedcde77d8be630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7493e7215b072e1e80a640f17922c24d"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a7493e7215b072e1e80a640f17922c24d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a7493e7215b072e1e80a640f17922c24d">operator*</a> (const <a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt; &amp;ext, int value)</td></tr>
<tr class="memdesc:a7493e7215b072e1e80a640f17922c24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands.  <a href="#a7493e7215b072e1e80a640f17922c24d">More...</a><br /></td></tr>
<tr class="separator:a7493e7215b072e1e80a640f17922c24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0bc34f9115f337a0afb5319b563e73d"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:af0bc34f9115f337a0afb5319b563e73d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#af0bc34f9115f337a0afb5319b563e73d">operator*</a> (int value, const <a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt; &amp;ext)</td></tr>
<tr class="memdesc:af0bc34f9115f337a0afb5319b563e73d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands.  <a href="#af0bc34f9115f337a0afb5319b563e73d">More...</a><br /></td></tr>
<tr class="separator:af0bc34f9115f337a0afb5319b563e73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadfb76947a6c066dcd54b8680ab8444b"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:aadfb76947a6c066dcd54b8680ab8444b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#aadfb76947a6c066dcd54b8680ab8444b">operator/</a> (const <a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt; &amp;ext, int value)</td></tr>
<tr class="memdesc:aadfb76947a6c066dcd54b8680ab8444b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands.  <a href="#aadfb76947a6c066dcd54b8680ab8444b">More...</a><br /></td></tr>
<tr class="separator:aadfb76947a6c066dcd54b8680ab8444b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15753ae8369c689d57b16969ed3edad"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:aa15753ae8369c689d57b16969ed3edad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#aa15753ae8369c689d57b16969ed3edad">operator/</a> (int value, const <a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt; &amp;ext)</td></tr>
<tr class="memdesc:aa15753ae8369c689d57b16969ed3edad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands.  <a href="#aa15753ae8369c689d57b16969ed3edad">More...</a><br /></td></tr>
<tr class="separator:aa15753ae8369c689d57b16969ed3edad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39224f2c07629d70a56774237c720677"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a39224f2c07629d70a56774237c720677"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a39224f2c07629d70a56774237c720677">operator%</a> (const <a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt; &amp;ext, int value)</td></tr>
<tr class="memdesc:a39224f2c07629d70a56774237c720677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands.  <a href="#a39224f2c07629d70a56774237c720677">More...</a><br /></td></tr>
<tr class="separator:a39224f2c07629d70a56774237c720677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf191993e54b44a4f624f515d7e3c47e"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:aaf191993e54b44a4f624f515d7e3c47e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#aaf191993e54b44a4f624f515d7e3c47e">operator%</a> (int value, const <a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt; &amp;ext)</td></tr>
<tr class="memdesc:aaf191993e54b44a4f624f515d7e3c47e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands.  <a href="#aaf191993e54b44a4f624f515d7e3c47e">More...</a><br /></td></tr>
<tr class="separator:aaf191993e54b44a4f624f515d7e3c47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a52a59b1d64c7352ea25df066ca96fb7a"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:a52a59b1d64c7352ea25df066ca96fb7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a52a59b1d64c7352ea25df066ca96fb7a">copy_async</a> (const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; const T, N &gt; &amp;src, <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:a52a59b1d64c7352ea25df066ca96fb7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#a52a59b1d64c7352ea25df066ca96fb7a">More...</a><br /></td></tr>
<tr class="separator:a52a59b1d64c7352ea25df066ca96fb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775b40af107bc76d06a06a71a3bff90e"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:a775b40af107bc76d06a06a71a3bff90e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a775b40af107bc76d06a06a71a3bff90e">copy_async</a> (const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;src, <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:a775b40af107bc76d06a06a71a3bff90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#a775b40af107bc76d06a06a71a3bff90e">More...</a><br /></td></tr>
<tr class="separator:a775b40af107bc76d06a06a71a3bff90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa408eae8e1076ae29df7a13fa8ed22dd"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:aa408eae8e1076ae29df7a13fa8ed22dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#aa408eae8e1076ae29df7a13fa8ed22dd">copy_async</a> (const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; const T, N &gt; &amp;src, const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:aa408eae8e1076ae29df7a13fa8ed22dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#aa408eae8e1076ae29df7a13fa8ed22dd">More...</a><br /></td></tr>
<tr class="separator:aa408eae8e1076ae29df7a13fa8ed22dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e4329e39ebe6a2d26e04171597e422"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:ae2e4329e39ebe6a2d26e04171597e422"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#ae2e4329e39ebe6a2d26e04171597e422">copy_async</a> (const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;src, const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:ae2e4329e39ebe6a2d26e04171597e422"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#ae2e4329e39ebe6a2d26e04171597e422">More...</a><br /></td></tr>
<tr class="separator:ae2e4329e39ebe6a2d26e04171597e422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab37afd6f06aebca4b05f03a6b42c64a0"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:ab37afd6f06aebca4b05f03a6b42c64a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#ab37afd6f06aebca4b05f03a6b42c64a0">copy_async</a> (InputIter srcBegin, InputIter srcEnd, <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:ab37afd6f06aebca4b05f03a6b42c64a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest".  <a href="#ab37afd6f06aebca4b05f03a6b42c64a0">More...</a><br /></td></tr>
<tr class="separator:ab37afd6f06aebca4b05f03a6b42c64a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99b1ed04dfb0f4585a9845135ec795d"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:ac99b1ed04dfb0f4585a9845135ec795d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#ac99b1ed04dfb0f4585a9845135ec795d">copy_async</a> (InputIter srcBegin, <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:ac99b1ed04dfb0f4585a9845135ec795d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest".  <a href="#ac99b1ed04dfb0f4585a9845135ec795d">More...</a><br /></td></tr>
<tr class="separator:ac99b1ed04dfb0f4585a9845135ec795d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a72d25dfe0d16563fe09845badd69ac25"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:a72d25dfe0d16563fe09845badd69ac25"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a72d25dfe0d16563fe09845badd69ac25">copy_async</a> (InputIter srcBegin, InputIter srcEnd, const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:a72d25dfe0d16563fe09845badd69ac25"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest".  <a href="#a72d25dfe0d16563fe09845badd69ac25">More...</a><br /></td></tr>
<tr class="separator:a72d25dfe0d16563fe09845badd69ac25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad897f9d3f7206a3de6afef32c21025a6"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:ad897f9d3f7206a3de6afef32c21025a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#ad897f9d3f7206a3de6afef32c21025a6">copy_async</a> (InputIter srcBegin, const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:ad897f9d3f7206a3de6afef32c21025a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest".  <a href="#ad897f9d3f7206a3de6afef32c21025a6">More...</a><br /></td></tr>
<tr class="separator:ad897f9d3f7206a3de6afef32c21025a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa08d903bd9a76aa4a28ae65b601d9ac5"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#aa08d903bd9a76aa4a28ae65b601d9ac5">atomic_exchange</a> (unsigned int *dest, unsigned int val)</td></tr>
<tr class="memdesc:aa08d903bd9a76aa4a28ae65b601d9ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest , replace it with the value given in val and return the old value to the caller.  <a href="#aa08d903bd9a76aa4a28ae65b601d9ac5">More...</a><br /></td></tr>
<tr class="separator:aa08d903bd9a76aa4a28ae65b601d9ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e58c0917e696ae4f419b0dfeeb14cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#ae9e58c0917e696ae4f419b0dfeeb14cd">atomic_exchange</a> (int *dest, int val)</td></tr>
<tr class="memdesc:ae9e58c0917e696ae4f419b0dfeeb14cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest , replace it with the value given in val and return the old value to the caller.  <a href="#ae9e58c0917e696ae4f419b0dfeeb14cd">More...</a><br /></td></tr>
<tr class="separator:ae9e58c0917e696ae4f419b0dfeeb14cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ead58b4239fce2cfd240715275ff9a"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a71ead58b4239fce2cfd240715275ff9a">atomic_exchange</a> (float *dest, float val)</td></tr>
<tr class="memdesc:a71ead58b4239fce2cfd240715275ff9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest , replace it with the value given in val and return the old value to the caller.  <a href="#a71ead58b4239fce2cfd240715275ff9a">More...</a><br /></td></tr>
<tr class="separator:a71ead58b4239fce2cfd240715275ff9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac4963a736f7f3f962feee058138ad336"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#ac4963a736f7f3f962feee058138ad336">atomic_compare_exchange</a> (unsigned int *dest, unsigned int *expected_val, unsigned int val)</td></tr>
<tr class="memdesc:ac4963a736f7f3f962feee058138ad336"><td class="mdescLeft">&#160;</td><td class="mdescRight">These functions attempt to perform these three steps atomically:  <a href="#ac4963a736f7f3f962feee058138ad336">More...</a><br /></td></tr>
<tr class="separator:ac4963a736f7f3f962feee058138ad336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad222d42f392203b6b1ce5808ae544cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#aad222d42f392203b6b1ce5808ae544cf">atomic_compare_exchange</a> (int *dest, int *expected_val, int val)</td></tr>
<tr class="memdesc:aad222d42f392203b6b1ce5808ae544cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">These functions attempt to perform these three steps atomically:  <a href="#aad222d42f392203b6b1ce5808ae544cf">More...</a><br /></td></tr>
<tr class="separator:aad222d42f392203b6b1ce5808ae544cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6aec3e82ae71f4c8758a38fd5bf7375c"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a6aec3e82ae71f4c8758a38fd5bf7375c">atomic_fetch_add</a> (unsigned *x, unsigned y)</td></tr>
<tr class="memdesc:a6aec3e82ae71f4c8758a38fd5bf7375c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#a6aec3e82ae71f4c8758a38fd5bf7375c">More...</a><br /></td></tr>
<tr class="separator:a6aec3e82ae71f4c8758a38fd5bf7375c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d4d1eac3a9774c7454ccb0cc7a583e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a82d4d1eac3a9774c7454ccb0cc7a583e">atomic_fetch_add</a> (int *x, int y)</td></tr>
<tr class="memdesc:a82d4d1eac3a9774c7454ccb0cc7a583e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#a82d4d1eac3a9774c7454ccb0cc7a583e">More...</a><br /></td></tr>
<tr class="separator:a82d4d1eac3a9774c7454ccb0cc7a583e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014338a2ba98269a253e133424780a98"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a014338a2ba98269a253e133424780a98">atomic_fetch_add</a> (float *x, float y)</td></tr>
<tr class="memdesc:a014338a2ba98269a253e133424780a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#a014338a2ba98269a253e133424780a98">More...</a><br /></td></tr>
<tr class="separator:a014338a2ba98269a253e133424780a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7200b80cfdb1df576f95b84645bfba77"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a7200b80cfdb1df576f95b84645bfba77">atomic_fetch_sub</a> (unsigned *x, unsigned y)</td></tr>
<tr class="memdesc:a7200b80cfdb1df576f95b84645bfba77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#a7200b80cfdb1df576f95b84645bfba77">More...</a><br /></td></tr>
<tr class="separator:a7200b80cfdb1df576f95b84645bfba77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb05aaedaeb53037a5219c3e922c82b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#acb05aaedaeb53037a5219c3e922c82b2">atomic_fetch_sub</a> (int *x, int y)</td></tr>
<tr class="memdesc:acb05aaedaeb53037a5219c3e922c82b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#acb05aaedaeb53037a5219c3e922c82b2">More...</a><br /></td></tr>
<tr class="separator:acb05aaedaeb53037a5219c3e922c82b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0948dcb94b08baf35097f8dd0a757e6"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#ae0948dcb94b08baf35097f8dd0a757e6">atomic_fetch_sub</a> (float *x, float y)</td></tr>
<tr class="memdesc:ae0948dcb94b08baf35097f8dd0a757e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#ae0948dcb94b08baf35097f8dd0a757e6">More...</a><br /></td></tr>
<tr class="separator:ae0948dcb94b08baf35097f8dd0a757e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab291ab92bfc923e13ef20bdae1300c0e"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#ab291ab92bfc923e13ef20bdae1300c0e">atomic_fetch_and</a> (unsigned *x, unsigned y)</td></tr>
<tr class="memdesc:ab291ab92bfc923e13ef20bdae1300c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#ab291ab92bfc923e13ef20bdae1300c0e">More...</a><br /></td></tr>
<tr class="separator:ab291ab92bfc923e13ef20bdae1300c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346a0255687f10028dde960e92fea5a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a346a0255687f10028dde960e92fea5a2">atomic_fetch_and</a> (int *x, int y)</td></tr>
<tr class="memdesc:a346a0255687f10028dde960e92fea5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#a346a0255687f10028dde960e92fea5a2">More...</a><br /></td></tr>
<tr class="separator:a346a0255687f10028dde960e92fea5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9e4443497cda8803a6f34abccf56a8"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a1b9e4443497cda8803a6f34abccf56a8">atomic_fetch_or</a> (unsigned *x, unsigned y)</td></tr>
<tr class="memdesc:a1b9e4443497cda8803a6f34abccf56a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#a1b9e4443497cda8803a6f34abccf56a8">More...</a><br /></td></tr>
<tr class="separator:a1b9e4443497cda8803a6f34abccf56a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab522fc34ad5e24d945cc363a5b61cfd3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#ab522fc34ad5e24d945cc363a5b61cfd3">atomic_fetch_or</a> (int *x, int y)</td></tr>
<tr class="memdesc:ab522fc34ad5e24d945cc363a5b61cfd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#ab522fc34ad5e24d945cc363a5b61cfd3">More...</a><br /></td></tr>
<tr class="separator:ab522fc34ad5e24d945cc363a5b61cfd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f58bfe291785a11015f71f1b150a60"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a85f58bfe291785a11015f71f1b150a60">atomic_fetch_xor</a> (unsigned *x, unsigned y)</td></tr>
<tr class="memdesc:a85f58bfe291785a11015f71f1b150a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#a85f58bfe291785a11015f71f1b150a60">More...</a><br /></td></tr>
<tr class="separator:a85f58bfe291785a11015f71f1b150a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab39d7837d89a7d5c15b7c799378a55c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#aab39d7837d89a7d5c15b7c799378a55c">atomic_fetch_xor</a> (int *x, int y)</td></tr>
<tr class="memdesc:aab39d7837d89a7d5c15b7c799378a55c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#aab39d7837d89a7d5c15b7c799378a55c">More...</a><br /></td></tr>
<tr class="separator:aab39d7837d89a7d5c15b7c799378a55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08594956cf951eb1edcf5e49c2d4e07b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a08594956cf951eb1edcf5e49c2d4e07b">atomic_fetch_max</a> (int *dest, int val)</td></tr>
<tr class="memdesc:a08594956cf951eb1edcf5e49c2d4e07b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#a08594956cf951eb1edcf5e49c2d4e07b">More...</a><br /></td></tr>
<tr class="separator:a08594956cf951eb1edcf5e49c2d4e07b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bddc3804f8eac279f6c9cb404d5d6d1"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a7bddc3804f8eac279f6c9cb404d5d6d1">atomic_fetch_max</a> (unsigned int *dest, unsigned int val)</td></tr>
<tr class="memdesc:a7bddc3804f8eac279f6c9cb404d5d6d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#a7bddc3804f8eac279f6c9cb404d5d6d1">More...</a><br /></td></tr>
<tr class="separator:a7bddc3804f8eac279f6c9cb404d5d6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5654581052107ecd509aefaf6b28ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#aef5654581052107ecd509aefaf6b28ce">atomic_fetch_min</a> (int *dest, int val)</td></tr>
<tr class="memdesc:aef5654581052107ecd509aefaf6b28ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#aef5654581052107ecd509aefaf6b28ce">More...</a><br /></td></tr>
<tr class="separator:aef5654581052107ecd509aefaf6b28ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40651118cb6f0fbf70305dede96ad3d3"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#a40651118cb6f0fbf70305dede96ad3d3">atomic_fetch_min</a> (unsigned int *dest, unsigned int val)</td></tr>
<tr class="memdesc:a40651118cb6f0fbf70305dede96ad3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#a40651118cb6f0fbf70305dede96ad3d3">More...</a><br /></td></tr>
<tr class="separator:a40651118cb6f0fbf70305dede96ad3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acfc19c1397a87d1a60c77a137696f63b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#acfc19c1397a87d1a60c77a137696f63b">atomic_fetch_inc</a> (int *_Dest)</td></tr>
<tr class="memdesc:acfc19c1397a87d1a60c77a137696f63b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically increment or decrement the value stored at the location point to by dest.  <a href="#acfc19c1397a87d1a60c77a137696f63b">More...</a><br /></td></tr>
<tr class="separator:acfc19c1397a87d1a60c77a137696f63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4faca99cf4d949f6d371805b4c13059"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#ab4faca99cf4d949f6d371805b4c13059">atomic_fetch_inc</a> (unsigned int *_Dest)</td></tr>
<tr class="memdesc:ab4faca99cf4d949f6d371805b4c13059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically increment or decrement the value stored at the location point to by dest.  <a href="#ab4faca99cf4d949f6d371805b4c13059">More...</a><br /></td></tr>
<tr class="separator:ab4faca99cf4d949f6d371805b4c13059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab595028ab29c1004089d56dd95f8b00b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#ab595028ab29c1004089d56dd95f8b00b">atomic_fetch_dec</a> (int *_Dest)</td></tr>
<tr class="memdesc:ab595028ab29c1004089d56dd95f8b00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically increment or decrement the value stored at the location point to by dest.  <a href="#ab595028ab29c1004089d56dd95f8b00b">More...</a><br /></td></tr>
<tr class="separator:ab595028ab29c1004089d56dd95f8b00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87f2afb7ac4ed928be066c03f610821"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceConcurrency.html#ad87f2afb7ac4ed928be066c03f610821">atomic_fetch_dec</a> (unsigned int *_Dest)</td></tr>
<tr class="memdesc:ad87f2afb7ac4ed928be066c03f610821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically increment or decrement the value stored at the location point to by dest.  <a href="#ad87f2afb7ac4ed928be066c03f610821">More...</a><br /></td></tr>
<tr class="separator:ad87f2afb7ac4ed928be066c03f610821"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aff7535e6cf24a2ccf3680645c2115674"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff7535e6cf24a2ccf3680645c2115674"></a>
<a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>compute_domain</b></td></tr>
<tr class="separator:aff7535e6cf24a2ccf3680645c2115674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5338a6b22aa53c87f448ad4d14b7708b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt; const Kernel &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>f</b></td></tr>
<tr class="separator:a5338a6b22aa53c87f448ad4d14b7708b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3441d68da380628a2319cdf2e510be2b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ext</b> [3]</td></tr>
<tr class="separator:a3441d68da380628a2319cdf2e510be2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa93776c82e1783e75bb15875add3aef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa93776c82e1783e75bb15875add3aef"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>tile</b> = compute_domain.tile_dim0</td></tr>
<tr class="separator:afa93776c82e1783e75bb15875add3aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>C++ AMP namespace. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a937d14ca3ae392aebd5ba5c2b6b955a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Concurrency::all_memory_fence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1tile__barrier.html">tile_barrier</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a thread-tile scoped memory fence for both global and tile-static memory operations. </p>
<p>This function does not imply a barrier and is therefore permitted in divergent code. </p>

<p>Referenced by <a class="el" href="classConcurrency_1_1tile__barrier.html#a175e2832e0530f493632ae79b89af912">Concurrency::tile_barrier::wait_with_tile_static_memory_fence()</a>.</p>

</div>
</div>
<a class="anchor" id="ac4963a736f7f3f962feee058138ad336"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Concurrency::atomic_compare_exchange </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>expected_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These functions attempt to perform these three steps atomically: </p>
<ol type="1">
<li>Read the value stored in the location pointed to by dest</li>
<li>Compare the value read in the previous step with the value contained in the location pointed by expected_val</li>
<li>Carry the following operations depending on the result of the comparison of the previous step: a. If the values are identical, then the function tries to atomically change the value pointed by dest to the value in val. The function indicates by its return value whether this transformation has been successful or not. b. If the values are not identical, then the function stores the value read in step (1) into the location pointed to by expected_val, and returns false.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">expected_val</td><td>A pointer to a local variable or function parameter. Upon calling the function, the location pointed by expected_val contains the value the caller expects dest to contain. Upon return from the function, expected_val will contain the most recent value read from dest. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The new value to be stored in the location pointed to be dest </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value indicates whether the function has been successful in atomically reading, comparing and modifying the contents of the memory location. </dd></dl>

<p>Referenced by <a class="el" href="namespaceConcurrency.html#a404eae30679d066e133ae799b3ef3339">copy_async()</a>.</p>

</div>
</div>
<a class="anchor" id="aad222d42f392203b6b1ce5808ae544cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Concurrency::atomic_compare_exchange </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>expected_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These functions attempt to perform these three steps atomically: </p>
<ol type="1">
<li>Read the value stored in the location pointed to by dest</li>
<li>Compare the value read in the previous step with the value contained in the location pointed by expected_val</li>
<li>Carry the following operations depending on the result of the comparison of the previous step: a. If the values are identical, then the function tries to atomically change the value pointed by dest to the value in val. The function indicates by its return value whether this transformation has been successful or not. b. If the values are not identical, then the function stores the value read in step (1) into the location pointed to by expected_val, and returns false.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">expected_val</td><td>A pointer to a local variable or function parameter. Upon calling the function, the location pointed by expected_val contains the value the caller expects dest to contain. Upon return from the function, expected_val will contain the most recent value read from dest. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The new value to be stored in the location pointed to be dest </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value indicates whether the function has been successful in atomically reading, comparing and modifying the contents of the memory location. </dd></dl>

</div>
</div>
<a class="anchor" id="aa08d903bd9a76aa4a28ae65b601d9ac5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Concurrency::atomic_exchange </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest , replace it with the value given in val and return the old value to the caller. </p>
<p>This function provides overloads for int , unsigned int and float parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>A pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The new value to be stored in the location pointed to be dest </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

<p>Referenced by <a class="el" href="namespaceConcurrency.html#a404eae30679d066e133ae799b3ef3339">copy_async()</a>.</p>

</div>
</div>
<a class="anchor" id="ae9e58c0917e696ae4f419b0dfeeb14cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Concurrency::atomic_exchange </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest , replace it with the value given in val and return the old value to the caller. </p>
<p>This function provides overloads for int , unsigned int and float parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>A pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The new value to be stored in the location pointed to be dest </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

</div>
</div>
<a class="anchor" id="a71ead58b4239fce2cfd240715275ff9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Concurrency::atomic_exchange </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest , replace it with the value given in val and return the old value to the caller. </p>
<p>This function provides overloads for int , unsigned int and float parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>A pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The new value to be stored in the location pointed to be dest </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

</div>
</div>
<a class="anchor" id="a6aec3e82ae71f4c8758a38fd5bf7375c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Concurrency::atomic_fetch_add </td>
          <td>(</td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

<p>Referenced by <a class="el" href="namespaceConcurrency.html#a404eae30679d066e133ae799b3ef3339">copy_async()</a>.</p>

</div>
</div>
<a class="anchor" id="a82d4d1eac3a9774c7454ccb0cc7a583e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Concurrency::atomic_fetch_add </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

</div>
</div>
<a class="anchor" id="a014338a2ba98269a253e133424780a98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Concurrency::atomic_fetch_add </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

</div>
</div>
<a class="anchor" id="ab291ab92bfc923e13ef20bdae1300c0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Concurrency::atomic_fetch_and </td>
          <td>(</td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

<p>Referenced by <a class="el" href="namespaceConcurrency.html#a404eae30679d066e133ae799b3ef3339">copy_async()</a>.</p>

</div>
</div>
<a class="anchor" id="a346a0255687f10028dde960e92fea5a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Concurrency::atomic_fetch_and </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

</div>
</div>
<a class="anchor" id="ab595028ab29c1004089d56dd95f8b00b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Concurrency::atomic_fetch_dec </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>_Dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically increment or decrement the value stored at the location point to by dest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

<p>Referenced by <a class="el" href="namespaceConcurrency.html#a404eae30679d066e133ae799b3ef3339">copy_async()</a>.</p>

</div>
</div>
<a class="anchor" id="ad87f2afb7ac4ed928be066c03f610821"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Concurrency::atomic_fetch_dec </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>_Dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically increment or decrement the value stored at the location point to by dest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

</div>
</div>
<a class="anchor" id="acfc19c1397a87d1a60c77a137696f63b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Concurrency::atomic_fetch_inc </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>_Dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically increment or decrement the value stored at the location point to by dest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

<p>Referenced by <a class="el" href="namespaceConcurrency.html#a404eae30679d066e133ae799b3ef3339">copy_async()</a>.</p>

</div>
</div>
<a class="anchor" id="ab4faca99cf4d949f6d371805b4c13059"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Concurrency::atomic_fetch_inc </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>_Dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically increment or decrement the value stored at the location point to by dest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

</div>
</div>
<a class="anchor" id="a08594956cf951eb1edcf5e49c2d4e07b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Concurrency::atomic_fetch_max </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

<p>Referenced by <a class="el" href="namespaceConcurrency.html#a404eae30679d066e133ae799b3ef3339">copy_async()</a>.</p>

</div>
</div>
<a class="anchor" id="a7bddc3804f8eac279f6c9cb404d5d6d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Concurrency::atomic_fetch_max </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

</div>
</div>
<a class="anchor" id="aef5654581052107ecd509aefaf6b28ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Concurrency::atomic_fetch_min </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

<p>Referenced by <a class="el" href="namespaceConcurrency.html#a404eae30679d066e133ae799b3ef3339">copy_async()</a>.</p>

</div>
</div>
<a class="anchor" id="a40651118cb6f0fbf70305dede96ad3d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Concurrency::atomic_fetch_min </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

</div>
</div>
<a class="anchor" id="a1b9e4443497cda8803a6f34abccf56a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Concurrency::atomic_fetch_or </td>
          <td>(</td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

<p>Referenced by <a class="el" href="namespaceConcurrency.html#a404eae30679d066e133ae799b3ef3339">copy_async()</a>.</p>

</div>
</div>
<a class="anchor" id="ab522fc34ad5e24d945cc363a5b61cfd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Concurrency::atomic_fetch_or </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

</div>
</div>
<a class="anchor" id="a7200b80cfdb1df576f95b84645bfba77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Concurrency::atomic_fetch_sub </td>
          <td>(</td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

<p>Referenced by <a class="el" href="namespaceConcurrency.html#a404eae30679d066e133ae799b3ef3339">copy_async()</a>.</p>

</div>
</div>
<a class="anchor" id="acb05aaedaeb53037a5219c3e922c82b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Concurrency::atomic_fetch_sub </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

</div>
</div>
<a class="anchor" id="ae0948dcb94b08baf35097f8dd0a757e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Concurrency::atomic_fetch_sub </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

</div>
</div>
<a class="anchor" id="a85f58bfe291785a11015f71f1b150a60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Concurrency::atomic_fetch_xor </td>
          <td>(</td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

<p>Referenced by <a class="el" href="namespaceConcurrency.html#a404eae30679d066e133ae799b3ef3339">copy_async()</a>.</p>

</div>
</div>
<a class="anchor" id="aab39d7837d89a7d5c15b7c799378a55c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Concurrency::atomic_fetch_xor </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

</div>
</div>
<a class="anchor" id="a23f7bbd6e1bd4f6b6356f90adc8ea03f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Concurrency::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; const T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array_view&lt;T,N&gt; (or <a class="el" href="classConcurrency_1_1array__view_3_01const_01T_00_01N_01_4.html" title="The partial specialization array_view&lt;const T,N&gt; represents a view over elements of type const T with...">array_view&lt;const T, N&gt;</a>) to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array_view&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classConcurrency_1_1array__view.html#a082f1c2babb9f0706ff7445980f69f80">Concurrency::array_view&lt; T, N &gt;::get_extent()</a>.</p>

<p>Referenced by <a class="el" href="classConcurrency_1_1array.html#afab9e695d0bb5652081db932be97a656">Concurrency::array&lt; T, N &gt;::array()</a>, <a class="el" href="namespaceConcurrency.html#a4e0cb942b5308f0dabafb70992964be8">copy()</a>, <a class="el" href="namespaceConcurrency.html#a79f8f54d8e9be7bedddaeb40b3fe10c0">copy_async()</a>, <a class="el" href="classConcurrency_1_1array.html#a4bdb6ef5f3f7676b317573821a3ac769">Concurrency::array&lt; T, N &gt;::copy_to()</a>, <a class="el" href="classConcurrency_1_1array__view.html#a7b204daf3162f705ed9973d3b383e5fd">Concurrency::array_view&lt; T, N &gt;::copy_to()</a>, <a class="el" href="classConcurrency_1_1array__view_3_01const_01T_00_01N_01_4.html#ad826dcce80a779450f22dfa1c8b7a7c4">Concurrency::array_view&lt; const T, N &gt;::copy_to()</a>, <a class="el" href="classConcurrency_1_1array.html#a2b81c58f7dc848d92a0c64f4e7d14df2">Concurrency::array&lt; T, N &gt;::operator std::vector&lt; T &gt;()</a>, <a class="el" href="classConcurrency_1_1array.html#ad3d062711f63b5bf1e57e6cc0e4b04b0">Concurrency::array&lt; T, N &gt;::view_as()</a>, <a class="el" href="classConcurrency_1_1array__view.html#a48d0ef260940da258988c81436e46474">Concurrency::array_view&lt; T, N &gt;::view_as()</a>, and <a class="el" href="classConcurrency_1_1array__view_3_01const_01T_00_01N_01_4.html#a03608651c133993649e717bfa3f73f22">Concurrency::array_view&lt; const T, N &gt;::view_as()</a>.</p>

</div>
</div>
<a class="anchor" id="a4d0e2c07a98b85283c1c686139a5445f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Concurrency::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array_view&lt;T,N&gt; (or <a class="el" href="classConcurrency_1_1array__view_3_01const_01T_00_01N_01_4.html" title="The partial specialization array_view&lt;const T,N&gt; represents a view over elements of type const T with...">array_view&lt;const T, N&gt;</a>) to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array_view&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespaceConcurrency.html#a23f7bbd6e1bd4f6b6356f90adc8ea03f">copy()</a>.</p>

</div>
</div>
<a class="anchor" id="aef51b57d2c9747b99e0e7a7dafc877d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Concurrency::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array&lt;T,N&gt; to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array_view&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classConcurrency_1_1array__view.html#a082f1c2babb9f0706ff7445980f69f80">Concurrency::array_view&lt; T, N &gt;::get_extent()</a>.</p>

</div>
</div>
<a class="anchor" id="ab23adc223892aad81641fe55e501000a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Concurrency::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>The source and destination may reside on different accelerators. If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array&lt;T,N&gt; to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af24df9aabe7ffb92707603857f9970a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Concurrency::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; const T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array_view&lt;T,N&gt; (or <a class="el" href="classConcurrency_1_1array__view_3_01const_01T_00_01N_01_4.html" title="The partial specialization array_view&lt;const T,N&gt; represents a view over elements of type const T with...">array_view&lt;const T, N&gt;</a>) to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classConcurrency_1_1array.html#adc02a9112098af6c7e3d98988baeceb5">Concurrency::array&lt; T, N &gt;::get_extent()</a>.</p>

</div>
</div>
<a class="anchor" id="a4e0cb942b5308f0dabafb70992964be8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Concurrency::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array_view&lt;T,N&gt; (or <a class="el" href="classConcurrency_1_1array__view_3_01const_01T_00_01N_01_4.html" title="The partial specialization array_view&lt;const T,N&gt; represents a view over elements of type const T with...">array_view&lt;const T, N&gt;</a>) to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespaceConcurrency.html#a23f7bbd6e1bd4f6b6356f90adc8ea03f">copy()</a>.</p>

</div>
</div>
<a class="anchor" id="aab33beea5f006352370d18e0b127bb70"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIter , typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Concurrency::copy </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>srcBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>srcEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest". </p>
<p>If the number of elements in the iterator range is not equal to "dest.extent.size()", an exception is thrown.</p>
<p>In the overloads which don't take an end-iterator it is assumed that the source iterator is able to provide at least dest.extent.size() elements, but no checking is performed (nor possible).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBegin</td><td>An iterator to the first element of a source container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcEnd</td><td>An interator to the end of a source container. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array_view&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af028bde2ae43a052841f70b168910660"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIter , typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Concurrency::copy </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>srcBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>srcEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest". </p>
<p>If the number of elements in the iterator range is not equal to "dest.extent.size()", an exception is thrown.</p>
<p>In the overloads which don't take an end-iterator it is assumed that the source iterator is able to provide at least dest.extent.size() elements, but no checking is performed (nor possible).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBegin</td><td>An iterator to the first element of a source container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcEnd</td><td>An interator to the end of a source container. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classConcurrency_1_1array.html#adc02a9112098af6c7e3d98988baeceb5">Concurrency::array&lt; T, N &gt;::get_extent()</a>.</p>

</div>
</div>
<a class="anchor" id="a9eb988af963a7055faf0a9b00d19fee0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIter , typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Concurrency::copy </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>srcBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest". </p>
<p>If the number of elements in the iterator range is not equal to "dest.extent.size()", an exception is thrown.</p>
<p>In the overloads which don't take an end-iterator it is assumed that the source iterator is able to provide at least dest.extent.size() elements, but no checking is performed (nor possible).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBegin</td><td>An iterator to the first element of a source container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcEnd</td><td>An interator to the end of a source container. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array_view&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespaceConcurrency.html#a23f7bbd6e1bd4f6b6356f90adc8ea03f">copy()</a>, and <a class="el" href="classConcurrency_1_1array__view.html#a082f1c2babb9f0706ff7445980f69f80">Concurrency::array_view&lt; T, N &gt;::get_extent()</a>.</p>

</div>
</div>
<a class="anchor" id="af840ca638732df054bfb58cf8067c618"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIter , typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Concurrency::copy </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>srcBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest". </p>
<p>If the number of elements in the iterator range is not equal to "dest.extent.size()", an exception is thrown.</p>
<p>In the overloads which don't take an end-iterator it is assumed that the source iterator is able to provide at least dest.extent.size() elements, but no checking is performed (nor possible).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBegin</td><td>An iterator to the first element of a source container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcEnd</td><td>An interator to the end of a source container. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespaceConcurrency.html#a23f7bbd6e1bd4f6b6356f90adc8ea03f">copy()</a>, and <a class="el" href="classConcurrency_1_1array.html#adc02a9112098af6c7e3d98988baeceb5">Concurrency::array&lt; T, N &gt;::get_extent()</a>.</p>

</div>
</div>
<a class="anchor" id="a1fb46bca2c652e1723cfd55d4e1f2071"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputIter , typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Concurrency::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIter&#160;</td>
          <td class="paramname"><em>destBegin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of a source array are copied into "dest" starting with iterator destBegin. </p>
<p>If the number of elements in the range starting destBegin in the destination container is smaller than "src.extent.size()", the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array_view&lt;T,N&gt; to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destBegin</td><td>An output iterator addressing the position of the first element in the destination container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2d765a0305f2b3a84c8f4fdc754c8e11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputIter , typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Concurrency::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIter&#160;</td>
          <td class="paramname"><em>destBegin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of a source array are copied into "dest" starting with iterator destBegin. </p>
<p>If the number of elements in the range starting destBegin in the destination container is smaller than "src.extent.size()", the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array&lt;T,N&gt; to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destBegin</td><td>An output iterator addressing the position of the first element in the destination container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7b6d7497b0b983fdc7736c7356d00b7a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Concurrency::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array&lt;T,N&gt; to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array_view&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classConcurrency_1_1array__view.html#a082f1c2babb9f0706ff7445980f69f80">Concurrency::array_view&lt; T, N &gt;::get_extent()</a>.</p>

</div>
</div>
<a class="anchor" id="a482316212fd67380e214b5e17b6a6f10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Concurrency::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; const T, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array_view&lt;T,N&gt; (or <a class="el" href="classConcurrency_1_1array__view_3_01const_01T_00_01N_01_4.html" title="The partial specialization array_view&lt;const T,N&gt; represents a view over elements of type const T with...">array_view&lt;const T, N&gt;</a>) to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classConcurrency_1_1array.html#adc02a9112098af6c7e3d98988baeceb5">Concurrency::array&lt; T, N &gt;::get_extent()</a>.</p>

</div>
</div>
<a class="anchor" id="a4bd39928b6ae19239d955a9f78bc6cb8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Concurrency::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; const T, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array_view&lt;T,N&gt; (or <a class="el" href="classConcurrency_1_1array__view_3_01const_01T_00_01N_01_4.html" title="The partial specialization array_view&lt;const T,N&gt; represents a view over elements of type const T with...">array_view&lt;const T, N&gt;</a>) to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array_view&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classConcurrency_1_1array__view.html#a082f1c2babb9f0706ff7445980f69f80">Concurrency::array_view&lt; T, N &gt;::get_extent()</a>.</p>

</div>
</div>
<a class="anchor" id="a79f8f54d8e9be7bedddaeb40b3fe10c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a> Concurrency::copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>The source and destination may reside on different accelerators. If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array&lt;T,N&gt; to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespaceConcurrency.html#a23f7bbd6e1bd4f6b6356f90adc8ea03f">copy()</a>.</p>

<p>Referenced by <a class="el" href="namespaceConcurrency.html#a404eae30679d066e133ae799b3ef3339">copy_async()</a>, and <a class="el" href="classConcurrency_1_1completion__future.html#a6aad7e5156b54ca337cdfeea69840771">Concurrency::completion_future::then()</a>.</p>

</div>
</div>
<a class="anchor" id="ad38037cf830a55d87004d0d7105f369d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a> Concurrency::copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array&lt;T,N&gt; to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array_view&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespaceConcurrency.html#a23f7bbd6e1bd4f6b6356f90adc8ea03f">copy()</a>.</p>

</div>
</div>
<a class="anchor" id="a52a59b1d64c7352ea25df066ca96fb7a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a> Concurrency::copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; const T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array_view&lt;T,N&gt; (or <a class="el" href="classConcurrency_1_1array__view_3_01const_01T_00_01N_01_4.html" title="The partial specialization array_view&lt;const T,N&gt; represents a view over elements of type const T with...">array_view&lt;const T, N&gt;</a>) to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespaceConcurrency.html#a23f7bbd6e1bd4f6b6356f90adc8ea03f">copy()</a>.</p>

</div>
</div>
<a class="anchor" id="a775b40af107bc76d06a06a71a3bff90e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a> Concurrency::copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array_view&lt;T,N&gt; (or <a class="el" href="classConcurrency_1_1array__view_3_01const_01T_00_01N_01_4.html" title="The partial specialization array_view&lt;const T,N&gt; represents a view over elements of type const T with...">array_view&lt;const T, N&gt;</a>) to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespaceConcurrency.html#a23f7bbd6e1bd4f6b6356f90adc8ea03f">copy()</a>.</p>

</div>
</div>
<a class="anchor" id="aa408eae8e1076ae29df7a13fa8ed22dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a> Concurrency::copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; const T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array_view&lt;T,N&gt; (or <a class="el" href="classConcurrency_1_1array__view_3_01const_01T_00_01N_01_4.html" title="The partial specialization array_view&lt;const T,N&gt; represents a view over elements of type const T with...">array_view&lt;const T, N&gt;</a>) to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array_view&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespaceConcurrency.html#a23f7bbd6e1bd4f6b6356f90adc8ea03f">copy()</a>.</p>

</div>
</div>
<a class="anchor" id="ae2e4329e39ebe6a2d26e04171597e422"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a> Concurrency::copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array_view&lt;T,N&gt; (or <a class="el" href="classConcurrency_1_1array__view_3_01const_01T_00_01N_01_4.html" title="The partial specialization array_view&lt;const T,N&gt; represents a view over elements of type const T with...">array_view&lt;const T, N&gt;</a>) to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array_view&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespaceConcurrency.html#a23f7bbd6e1bd4f6b6356f90adc8ea03f">copy()</a>.</p>

</div>
</div>
<a class="anchor" id="ab37afd6f06aebca4b05f03a6b42c64a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIter , typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a> Concurrency::copy_async </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>srcBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>srcEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest". </p>
<p>If the number of elements in the iterator range is not equal to "dest.extent.size()", an exception is thrown.</p>
<p>In the overloads which don't take an end-iterator it is assumed that the source iterator is able to provide at least dest.extent.size() elements, but no checking is performed (nor possible).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBegin</td><td>An iterator to the first element of a source container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcEnd</td><td>An interator to the end of a source container. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespaceConcurrency.html#a23f7bbd6e1bd4f6b6356f90adc8ea03f">copy()</a>.</p>

</div>
</div>
<a class="anchor" id="ac99b1ed04dfb0f4585a9845135ec795d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIter , typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a> Concurrency::copy_async </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>srcBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest". </p>
<p>If the number of elements in the iterator range is not equal to "dest.extent.size()", an exception is thrown.</p>
<p>In the overloads which don't take an end-iterator it is assumed that the source iterator is able to provide at least dest.extent.size() elements, but no checking is performed (nor possible).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBegin</td><td>An iterator to the first element of a source container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcEnd</td><td>An interator to the end of a source container. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespaceConcurrency.html#a23f7bbd6e1bd4f6b6356f90adc8ea03f">copy()</a>.</p>

</div>
</div>
<a class="anchor" id="a72d25dfe0d16563fe09845badd69ac25"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIter , typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a> Concurrency::copy_async </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>srcBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>srcEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest". </p>
<p>If the number of elements in the iterator range is not equal to "dest.extent.size()", an exception is thrown.</p>
<p>In the overloads which don't take an end-iterator it is assumed that the source iterator is able to provide at least dest.extent.size() elements, but no checking is performed (nor possible).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBegin</td><td>An iterator to the first element of a source container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcEnd</td><td>An interator to the end of a source container. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array_view&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespaceConcurrency.html#a23f7bbd6e1bd4f6b6356f90adc8ea03f">copy()</a>.</p>

</div>
</div>
<a class="anchor" id="ad897f9d3f7206a3de6afef32c21025a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIter , typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a> Concurrency::copy_async </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>srcBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest". </p>
<p>If the number of elements in the iterator range is not equal to "dest.extent.size()", an exception is thrown.</p>
<p>In the overloads which don't take an end-iterator it is assumed that the source iterator is able to provide at least dest.extent.size() elements, but no checking is performed (nor possible).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBegin</td><td>An iterator to the first element of a source container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcEnd</td><td>An interator to the end of a source container. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array_view&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespaceConcurrency.html#a23f7bbd6e1bd4f6b6356f90adc8ea03f">copy()</a>.</p>

</div>
</div>
<a class="anchor" id="abf9dd1c69e5c4383903d2686339fe722"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputIter , typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a> Concurrency::copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIter&#160;</td>
          <td class="paramname"><em>destBegin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of a source array are copied into "dest" starting with iterator destBegin. </p>
<p>If the number of elements in the range starting destBegin in the destination container is smaller than "src.extent.size()", the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array&lt;T,N&gt; to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destBegin</td><td>An output iterator addressing the position of the first element in the destination container. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespaceConcurrency.html#a23f7bbd6e1bd4f6b6356f90adc8ea03f">copy()</a>.</p>

</div>
</div>
<a class="anchor" id="a404eae30679d066e133ae799b3ef3339"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputIter , typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a> Concurrency::copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIter&#160;</td>
          <td class="paramname"><em>destBegin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of a source array are copied into "dest" starting with iterator destBegin. </p>
<p>If the number of elements in the range starting destBegin in the destination container is smaller than "src.extent.size()", the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array_view&lt;T,N&gt; to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destBegin</td><td>An output iterator addressing the position of the first element in the destination container. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespaceConcurrency.html#ac4963a736f7f3f962feee058138ad336">atomic_compare_exchange()</a>, <a class="el" href="namespaceConcurrency.html#aa08d903bd9a76aa4a28ae65b601d9ac5">atomic_exchange()</a>, <a class="el" href="namespaceConcurrency.html#a6aec3e82ae71f4c8758a38fd5bf7375c">atomic_fetch_add()</a>, <a class="el" href="namespaceConcurrency.html#ab291ab92bfc923e13ef20bdae1300c0e">atomic_fetch_and()</a>, <a class="el" href="namespaceConcurrency.html#ab595028ab29c1004089d56dd95f8b00b">atomic_fetch_dec()</a>, <a class="el" href="namespaceConcurrency.html#acfc19c1397a87d1a60c77a137696f63b">atomic_fetch_inc()</a>, <a class="el" href="namespaceConcurrency.html#a08594956cf951eb1edcf5e49c2d4e07b">atomic_fetch_max()</a>, <a class="el" href="namespaceConcurrency.html#aef5654581052107ecd509aefaf6b28ce">atomic_fetch_min()</a>, <a class="el" href="namespaceConcurrency.html#a1b9e4443497cda8803a6f34abccf56a8">atomic_fetch_or()</a>, <a class="el" href="namespaceConcurrency.html#a7200b80cfdb1df576f95b84645bfba77">atomic_fetch_sub()</a>, <a class="el" href="namespaceConcurrency.html#a85f58bfe291785a11015f71f1b150a60">atomic_fetch_xor()</a>, <a class="el" href="namespaceConcurrency.html#a23f7bbd6e1bd4f6b6356f90adc8ea03f">copy()</a>, and <a class="el" href="namespaceConcurrency.html#a79f8f54d8e9be7bedddaeb40b3fe10c0">copy_async()</a>.</p>

</div>
</div>
<a class="anchor" id="a8dfaa3abffa348ab345a95ad0335df59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Concurrency::global_memory_fence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1tile__barrier.html">tile_barrier</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a thread-tile scoped memory fence for global (but not tile-static) memory operations. </p>
<p>This function does not imply a barrier and is therefore permitted in divergent code. </p>

<p>Referenced by <a class="el" href="classConcurrency_1_1tile__barrier.html#a175e2832e0530f493632ae79b89af912">Concurrency::tile_barrier::wait_with_tile_static_memory_fence()</a>.</p>

</div>
</div>
<a class="anchor" id="a39224f2c07629d70a56774237c720677"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt;N&gt; Concurrency::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands. </p>
<p>The result extent&lt;N&gt; is such that for a given operator <img class="formulaInl" alt="$\oplus$" src="form_1.png"/>, result[i] = ext[i] <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> value or result[i] = value <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> ext[i] for every i from 0 to N-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ext</td><td>The extent&lt;N&gt; operand </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The integer operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf191993e54b44a4f624f515d7e3c47e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt;N&gt; Concurrency::operator% </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>ext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands. </p>
<p>The result extent&lt;N&gt; is such that for a given operator <img class="formulaInl" alt="$\oplus$" src="form_1.png"/>, result[i] = ext[i] <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> value or result[i] = value <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> ext[i] for every i from 0 to N-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ext</td><td>The extent&lt;N&gt; operand </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The integer operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7493e7215b072e1e80a640f17922c24d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt;N&gt; Concurrency::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands. </p>
<p>The result extent&lt;N&gt; is such that for a given operator <img class="formulaInl" alt="$\oplus$" src="form_1.png"/>, result[i] = ext[i] <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> value or result[i] = value <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> ext[i] for every i from 0 to N-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ext</td><td>The extent&lt;N&gt; operand </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The integer operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af0bc34f9115f337a0afb5319b563e73d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt;N&gt; Concurrency::operator* </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>ext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands. </p>
<p>The result extent&lt;N&gt; is such that for a given operator <img class="formulaInl" alt="$\oplus$" src="form_1.png"/>, result[i] = ext[i] <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> value or result[i] = value <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> ext[i] for every i from 0 to N-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ext</td><td>The extent&lt;N&gt; operand </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The integer operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a54da7310acb21651d3352675f3f5871f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt;N&gt; Concurrency::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds (or subtracts) two objects of extent&lt;N&gt; to form a new extent. </p>
<p>The result extent&lt;N&gt; is such that for a given operator <img class="formulaInl" alt="$\oplus$" src="form_1.png"/>, result[i] = leftExt[i] <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> rightExt[i] for every i from 0 to N-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The left-hand extent&lt;N&gt; to be compared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The right-hand extent&lt;N&gt; to be compared. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0a775ec79532dbcec7a408c87cee1fa1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt;N&gt; Concurrency::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands. </p>
<p>The result extent&lt;N&gt; is such that for a given operator <img class="formulaInl" alt="$\oplus$" src="form_1.png"/>, result[i] = ext[i] <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> value or result[i] = value <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> ext[i] for every i from 0 to N-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ext</td><td>The extent&lt;N&gt; operand </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The integer operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a090732e407973bbc9b36317314975655"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt;N&gt; Concurrency::operator+ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>ext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands. </p>
<p>The result extent&lt;N&gt; is such that for a given operator <img class="formulaInl" alt="$\oplus$" src="form_1.png"/>, result[i] = ext[i] <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> value or result[i] = value <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> ext[i] for every i from 0 to N-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ext</td><td>The extent&lt;N&gt; operand </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The integer operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a885a06a33e9d9e9c5866609bfaf202fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt;N&gt; Concurrency::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds (or subtracts) two objects of extent&lt;N&gt; to form a new extent. </p>
<p>The result extent&lt;N&gt; is such that for a given operator <img class="formulaInl" alt="$\oplus$" src="form_1.png"/>, result[i] = leftExt[i] <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> rightExt[i] for every i from 0 to N-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The left-hand extent&lt;N&gt; to be compared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The right-hand extent&lt;N&gt; to be compared. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9bf180fdbb091cf2380d63c4ebb70f48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt;N&gt; Concurrency::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands. </p>
<p>The result extent&lt;N&gt; is such that for a given operator <img class="formulaInl" alt="$\oplus$" src="form_1.png"/>, result[i] = ext[i] <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> value or result[i] = value <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> ext[i] for every i from 0 to N-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ext</td><td>The extent&lt;N&gt; operand </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The integer operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a71ba7f3d50a003f24bedcde77d8be630"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt;N&gt; Concurrency::operator- </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>ext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands. </p>
<p>The result extent&lt;N&gt; is such that for a given operator <img class="formulaInl" alt="$\oplus$" src="form_1.png"/>, result[i] = ext[i] <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> value or result[i] = value <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> ext[i] for every i from 0 to N-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ext</td><td>The extent&lt;N&gt; operand </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The integer operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aadfb76947a6c066dcd54b8680ab8444b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt;N&gt; Concurrency::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands. </p>
<p>The result extent&lt;N&gt; is such that for a given operator <img class="formulaInl" alt="$\oplus$" src="form_1.png"/>, result[i] = ext[i] <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> value or result[i] = value <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> ext[i] for every i from 0 to N-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ext</td><td>The extent&lt;N&gt; operand </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The integer operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa15753ae8369c689d57b16969ed3edad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt;N&gt; Concurrency::operator/ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1extent.html">extent</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>ext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands. </p>
<p>The result extent&lt;N&gt; is such that for a given operator <img class="formulaInl" alt="$\oplus$" src="form_1.png"/>, result[i] = ext[i] <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> value or result[i] = value <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> ext[i] for every i from 0 to N-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ext</td><td>The extent&lt;N&gt; operand </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The integer operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac0114fedd0ff8d9946be0cd817208600"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Concurrency::tile_static_memory_fence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1tile__barrier.html">tile_barrier</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a thread-tile scoped memory fence for tile-static (but not global) memory operations. </p>
<p>This function does not imply a barrier and is therefore permitted in divergent code. </p>

<p>Referenced by <a class="el" href="classConcurrency_1_1tile__barrier.html#a175e2832e0530f493632ae79b89af912">Concurrency::tile_barrier::wait_with_tile_static_memory_fence()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a3441d68da380628a2319cdf2e510be2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Concurrency::ext</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {<span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(compute_domain[N - 1]),</div><div class="line">        static_cast&lt;size_t&gt;(compute_domain[N - 2]),</div><div class="line">        <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(compute_domain[N - 3])}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5338a6b22aa53c87f448ad4d14b7708b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConcurrency_1_1tiled__extent.html">tiled_extent</a>&lt; D0, D1, D2 &gt; const Kernel &amp; Concurrency::f</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> compute_domain_size = 1</div></div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 13 2017 13:11:18 for HCC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
