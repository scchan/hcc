<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>HCC: hc::completion_future Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HCC
   </div>
   <div id="projectbrief">HCC is a single-source, C/C++ compiler for heterogeneous computing.  It&#39;s optimized with HSA (http://www.hsafoundation.com/).</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacehc.html">hc</a></li><li class="navelem"><a class="el" href="classhc_1_1completion__future.html">completion_future</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classhc_1_1completion__future-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">hc::completion_future Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_future&lt;void&gt;.  
 <a href="classhc_1_1completion__future.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="hc_8hpp_source.html">hc.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for hc::completion_future:</div>
<div class="dyncontent">
<div class="center"><img src="classhc_1_1completion__future__coll__graph.png" border="0" usemap="#hc_1_1completion__future_coll__map" alt="Collaboration graph"/></div>
<map name="hc_1_1completion__future_coll__map" id="hc_1_1completion__future_coll__map">
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a403ffe10604f72c941145ba25ffe6449"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1completion__future.html#a403ffe10604f72c941145ba25ffe6449">completion_future</a> ()</td></tr>
<tr class="memdesc:a403ffe10604f72c941145ba25ffe6449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a403ffe10604f72c941145ba25ffe6449">More...</a><br /></td></tr>
<tr class="separator:a403ffe10604f72c941145ba25ffe6449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4a91569da4882386d41bb65f91808e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1completion__future.html#a5b4a91569da4882386d41bb65f91808e">completion_future</a> (const <a class="el" href="classhc_1_1completion__future.html">completion_future</a> &amp;other)</td></tr>
<tr class="memdesc:a5b4a91569da4882386d41bb65f91808e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a5b4a91569da4882386d41bb65f91808e">More...</a><br /></td></tr>
<tr class="separator:a5b4a91569da4882386d41bb65f91808e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b9c5841048800ae878c1b1bafad554"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1completion__future.html#a79b9c5841048800ae878c1b1bafad554">completion_future</a> (<a class="el" href="classhc_1_1completion__future.html">completion_future</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a79b9c5841048800ae878c1b1bafad554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#a79b9c5841048800ae878c1b1bafad554">More...</a><br /></td></tr>
<tr class="separator:a79b9c5841048800ae878c1b1bafad554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a060016b06b6993bbe48370e6f0bc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1completion__future.html#ae0a060016b06b6993bbe48370e6f0bc0">operator=</a> (const <a class="el" href="classhc_1_1completion__future.html">completion_future</a> &amp;_Other)</td></tr>
<tr class="memdesc:ae0a060016b06b6993bbe48370e6f0bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment.  <a href="#ae0a060016b06b6993bbe48370e6f0bc0">More...</a><br /></td></tr>
<tr class="separator:ae0a060016b06b6993bbe48370e6f0bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0982718b5b93faa27c09de7ca2714644"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1completion__future.html#a0982718b5b93faa27c09de7ca2714644">operator=</a> (<a class="el" href="classhc_1_1completion__future.html">completion_future</a> &amp;&amp;_Other)</td></tr>
<tr class="memdesc:a0982718b5b93faa27c09de7ca2714644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment.  <a href="#a0982718b5b93faa27c09de7ca2714644">More...</a><br /></td></tr>
<tr class="separator:a0982718b5b93faa27c09de7ca2714644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d621ea8e29edc973ddba82d50f0e6c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1completion__future.html#a0d621ea8e29edc973ddba82d50f0e6c6">get</a> () const </td></tr>
<tr class="memdesc:a0d621ea8e29edc973ddba82d50f0e6c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is functionally identical to std::shared_future&lt;void&gt;::get.  <a href="#a0d621ea8e29edc973ddba82d50f0e6c6">More...</a><br /></td></tr>
<tr class="separator:a0d621ea8e29edc973ddba82d50f0e6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4e2f0ac28c0591cbffca3ba834f173"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1completion__future.html#a1e4e2f0ac28c0591cbffca3ba834f173">valid</a> () const </td></tr>
<tr class="memdesc:a1e4e2f0ac28c0591cbffca3ba834f173"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is functionally identical to std::shared_future&lt;void&gt;::valid.  <a href="#a1e4e2f0ac28c0591cbffca3ba834f173">More...</a><br /></td></tr>
<tr class="separator:a1e4e2f0ac28c0591cbffca3ba834f173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa264ef65bffd89f2ee42927344dcdf40"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1completion__future.html#aa264ef65bffd89f2ee42927344dcdf40">operator std::shared_future&lt; void &gt;</a> () const </td></tr>
<tr class="memdesc:aa264ef65bffd89f2ee42927344dcdf40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator to std::shared_future&lt;void&gt;.  <a href="#aa264ef65bffd89f2ee42927344dcdf40">More...</a><br /></td></tr>
<tr class="separator:aa264ef65bffd89f2ee42927344dcdf40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f05b8026ec7388ae1050dacf9ead33f"><td class="memTemplParams" colspan="2">template&lt;typename functor &gt; </td></tr>
<tr class="memitem:a3f05b8026ec7388ae1050dacf9ead33f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhc_1_1completion__future.html#a3f05b8026ec7388ae1050dacf9ead33f">then</a> (const functor &amp;func)</td></tr>
<tr class="memdesc:a3f05b8026ec7388ae1050dacf9ead33f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method enables specification of a completion callback func which is executed upon completion of the asynchronous operation associated with this <a class="el" href="classhc_1_1completion__future.html" title="This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_...">completion_future</a> object.  <a href="#a3f05b8026ec7388ae1050dacf9ead33f">More...</a><br /></td></tr>
<tr class="separator:a3f05b8026ec7388ae1050dacf9ead33f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa698009690b76b417797c40f9d553310"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1completion__future.html#aa698009690b76b417797c40f9d553310">get_native_handle</a> () const </td></tr>
<tr class="memdesc:aa698009690b76b417797c40f9d553310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the native handle for the asynchronous operation encapsulated in this <a class="el" href="classhc_1_1completion__future.html" title="This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_...">completion_future</a> object.  <a href="#aa698009690b76b417797c40f9d553310">More...</a><br /></td></tr>
<tr class="separator:aa698009690b76b417797c40f9d553310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3e34b6306626c247e9e3a7b90f88bf"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1completion__future.html#adc3e34b6306626c247e9e3a7b90f88bf">get_begin_tick</a> ()</td></tr>
<tr class="memdesc:adc3e34b6306626c247e9e3a7b90f88bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the tick number when the underlying asynchronous operation begins.  <a href="#adc3e34b6306626c247e9e3a7b90f88bf">More...</a><br /></td></tr>
<tr class="separator:adc3e34b6306626c247e9e3a7b90f88bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a85a5ec745076aefcb4e7307ac1085f"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1completion__future.html#a5a85a5ec745076aefcb4e7307ac1085f">get_end_tick</a> ()</td></tr>
<tr class="memdesc:a5a85a5ec745076aefcb4e7307ac1085f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the tick number when the underlying asynchronous operation ends.  <a href="#a5a85a5ec745076aefcb4e7307ac1085f">More...</a><br /></td></tr>
<tr class="separator:a5a85a5ec745076aefcb4e7307ac1085f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9d9f0264ab10ec4fb94bdb2fe2787e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1completion__future.html#a3d9d9f0264ab10ec4fb94bdb2fe2787e">get_tick_frequency</a> ()</td></tr>
<tr class="memdesc:a3d9d9f0264ab10ec4fb94bdb2fe2787e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the frequency of ticks per second for the underlying asynchrnous operation.  <a href="#a3d9d9f0264ab10ec4fb94bdb2fe2787e">More...</a><br /></td></tr>
<tr class="separator:a3d9d9f0264ab10ec4fb94bdb2fe2787e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b9bae487568195a657af7f07961c21"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1completion__future.html#aa6b9bae487568195a657af7f07961c21">is_ready</a> ()</td></tr>
<tr class="memdesc:aa6b9bae487568195a657af7f07961c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get if the async operations has been completed.  <a href="#aa6b9bae487568195a657af7f07961c21">More...</a><br /></td></tr>
<tr class="separator:aa6b9bae487568195a657af7f07961c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55895b4ec2afce57cf65e8e46cc0a837"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1completion__future.html#a55895b4ec2afce57cf65e8e46cc0a837">get_use_count</a> () const </td></tr>
<tr class="separator:a55895b4ec2afce57cf65e8e46cc0a837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a01252e442cf8ffc771484cfbb8014a15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1completion__future.html#a01252e442cf8ffc771484cfbb8014a15">wait</a> (hcWaitMode mode=hcWaitModeBlocked) const </td></tr>
<tr class="memdesc:a01252e442cf8ffc771484cfbb8014a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">These methods are functionally identical to the corresponding std::shared_future&lt;void&gt; methods.  <a href="#a01252e442cf8ffc771484cfbb8014a15">More...</a><br /></td></tr>
<tr class="separator:a01252e442cf8ffc771484cfbb8014a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7403fe6c91f04cfe32c58cd87c9d4ce9"><td class="memTemplParams" colspan="2">template&lt;class _Rep , class _Period &gt; </td></tr>
<tr class="memitem:a7403fe6c91f04cfe32c58cd87c9d4ce9"><td class="memTemplItemLeft" align="right" valign="top">std::future_status&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhc_1_1completion__future.html#a7403fe6c91f04cfe32c58cd87c9d4ce9">wait_for</a> (const std::chrono::duration&lt; _Rep, _Period &gt; &amp;_Rel_time) const </td></tr>
<tr class="memdesc:a7403fe6c91f04cfe32c58cd87c9d4ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">These methods are functionally identical to the corresponding std::shared_future&lt;void&gt; methods.  <a href="#a7403fe6c91f04cfe32c58cd87c9d4ce9">More...</a><br /></td></tr>
<tr class="separator:a7403fe6c91f04cfe32c58cd87c9d4ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30afecbb79b9f01223da9818ddc62b40"><td class="memTemplParams" colspan="2">template&lt;class _Clock , class _Duration &gt; </td></tr>
<tr class="memitem:a30afecbb79b9f01223da9818ddc62b40"><td class="memTemplItemLeft" align="right" valign="top">std::future_status&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhc_1_1completion__future.html#a30afecbb79b9f01223da9818ddc62b40">wait_until</a> (const std::chrono::time_point&lt; _Clock, _Duration &gt; &amp;_Abs_time) const </td></tr>
<tr class="memdesc:a30afecbb79b9f01223da9818ddc62b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">These methods are functionally identical to the corresponding std::shared_future&lt;void&gt; methods.  <a href="#a30afecbb79b9f01223da9818ddc62b40">More...</a><br /></td></tr>
<tr class="separator:a30afecbb79b9f01223da9818ddc62b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:acc1461ab8381ce94e01eccff40d2a448"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc1461ab8381ce94e01eccff40d2a448"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Kalmar::HSAQueue</b></td></tr>
<tr class="separator:acc1461ab8381ce94e01eccff40d2a448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1428cb4ad41918c12d64cc0bb4b2445d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1428cb4ad41918c12d64cc0bb4b2445d"></a>
template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:a1428cb4ad41918c12d64cc0bb4b2445d"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>array_view</b></td></tr>
<tr class="separator:a1428cb4ad41918c12d64cc0bb4b2445d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697ab2c88709b4c2881b9d80e0673b3c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a697ab2c88709b4c2881b9d80e0673b3c"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>accelerator_view</b></td></tr>
<tr class="separator:a697ab2c88709b4c2881b9d80e0673b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9845457ca0fb30c22f7c5f2e50e6148e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9845457ca0fb30c22f7c5f2e50e6148e"></a>
template&lt;int N, typename Kernel &gt; </td></tr>
<tr class="memitem:a9845457ca0fb30c22f7c5f2e50e6148e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_for_each</b> (const <a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a> &amp;, const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;, const Kernel &amp;)</td></tr>
<tr class="separator:a9845457ca0fb30c22f7c5f2e50e6148e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed48d9c9a588ca8c66ae67a120c6fac"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1ed48d9c9a588ca8c66ae67a120c6fac"></a>
template&lt;typename Kernel &gt; </td></tr>
<tr class="memitem:a1ed48d9c9a588ca8c66ae67a120c6fac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_for_each</b> (const <a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a> &amp;, const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; 1 &gt; &amp;, const Kernel &amp;)</td></tr>
<tr class="separator:a1ed48d9c9a588ca8c66ae67a120c6fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3720d3d03613dd372e71b7eaead94380"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3720d3d03613dd372e71b7eaead94380"></a>
template&lt;typename Kernel &gt; </td></tr>
<tr class="memitem:a3720d3d03613dd372e71b7eaead94380"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_for_each</b> (const <a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a> &amp;, const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; 2 &gt; &amp;, const Kernel &amp;)</td></tr>
<tr class="separator:a3720d3d03613dd372e71b7eaead94380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d892f5bb7ce2e6f83d0c0ef4ba3f69"><td class="memTemplParams" colspan="2"><a class="anchor" id="a26d892f5bb7ce2e6f83d0c0ef4ba3f69"></a>
template&lt;typename Kernel &gt; </td></tr>
<tr class="memitem:a26d892f5bb7ce2e6f83d0c0ef4ba3f69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_for_each</b> (const <a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a> &amp;, const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; 3 &gt; &amp;, const Kernel &amp;)</td></tr>
<tr class="separator:a26d892f5bb7ce2e6f83d0c0ef4ba3f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ca0c52379a9c0b25700f94c7bac2fd"><td class="memTemplParams" colspan="2"><a class="anchor" id="a41ca0c52379a9c0b25700f94c7bac2fd"></a>
template&lt;typename Kernel &gt; </td></tr>
<tr class="memitem:a41ca0c52379a9c0b25700f94c7bac2fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_for_each</b> (const <a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a> &amp;, const <a class="el" href="classhc_1_1tiled__extent.html">tiled_extent</a>&lt; 3 &gt; &amp;, const Kernel &amp;)</td></tr>
<tr class="separator:a41ca0c52379a9c0b25700f94c7bac2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0bb63846836f735e4364409fa6732fc"><td class="memTemplParams" colspan="2"><a class="anchor" id="af0bb63846836f735e4364409fa6732fc"></a>
template&lt;typename Kernel &gt; </td></tr>
<tr class="memitem:af0bb63846836f735e4364409fa6732fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_for_each</b> (const <a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a> &amp;, const <a class="el" href="classhc_1_1tiled__extent.html">tiled_extent</a>&lt; 2 &gt; &amp;, const Kernel &amp;)</td></tr>
<tr class="separator:af0bb63846836f735e4364409fa6732fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36615ad0f7692a99786a28aa788e70c"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad36615ad0f7692a99786a28aa788e70c"></a>
template&lt;typename Kernel &gt; </td></tr>
<tr class="memitem:ad36615ad0f7692a99786a28aa788e70c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_for_each</b> (const <a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a> &amp;, const <a class="el" href="classhc_1_1tiled__extent.html">tiled_extent</a>&lt; 1 &gt; &amp;, const Kernel &amp;)</td></tr>
<tr class="separator:ad36615ad0f7692a99786a28aa788e70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa844be401447e725a12311b836d81db8"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:aa844be401447e725a12311b836d81db8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhc_1_1completion__future.html#aa844be401447e725a12311b836d81db8">copy_async</a> (const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; const T, N &gt; &amp;src, const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:aa844be401447e725a12311b836d81db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#aa844be401447e725a12311b836d81db8">More...</a><br /></td></tr>
<tr class="separator:aa844be401447e725a12311b836d81db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535aac2c921b605a8f8f2f6a2e8efcb0"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:a535aac2c921b605a8f8f2f6a2e8efcb0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhc_1_1completion__future.html#a535aac2c921b605a8f8f2f6a2e8efcb0">copy_async</a> (const <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;src, <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:a535aac2c921b605a8f8f2f6a2e8efcb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#a535aac2c921b605a8f8f2f6a2e8efcb0">More...</a><br /></td></tr>
<tr class="separator:a535aac2c921b605a8f8f2f6a2e8efcb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9f288599618932ad0cdaee476da043"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:abb9f288599618932ad0cdaee476da043"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhc_1_1completion__future.html#abb9f288599618932ad0cdaee476da043">copy_async</a> (const <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;src, const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:abb9f288599618932ad0cdaee476da043"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#abb9f288599618932ad0cdaee476da043">More...</a><br /></td></tr>
<tr class="separator:abb9f288599618932ad0cdaee476da043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aecea0e438f7fa647e1659ffced684f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3aecea0e438f7fa647e1659ffced684f"></a>
template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:a3aecea0e438f7fa647e1659ffced684f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_async</b> (const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;src, const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="separator:a3aecea0e438f7fa647e1659ffced684f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad304f24eae5c8ca313a4ae4a36649fe3"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:ad304f24eae5c8ca313a4ae4a36649fe3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhc_1_1completion__future.html#ad304f24eae5c8ca313a4ae4a36649fe3">copy_async</a> (const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; const T, N &gt; &amp;src, <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:ad304f24eae5c8ca313a4ae4a36649fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#ad304f24eae5c8ca313a4ae4a36649fe3">More...</a><br /></td></tr>
<tr class="separator:ad304f24eae5c8ca313a4ae4a36649fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d54aa63b816401aca0cb21efb885af"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:a92d54aa63b816401aca0cb21efb885af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhc_1_1completion__future.html#a92d54aa63b816401aca0cb21efb885af">copy_async</a> (InputIter srcBegin, InputIter srcEnd, <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:a92d54aa63b816401aca0cb21efb885af"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest".  <a href="#a92d54aa63b816401aca0cb21efb885af">More...</a><br /></td></tr>
<tr class="separator:a92d54aa63b816401aca0cb21efb885af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e41e0b2ffd93a0e4e89589a540c12b3"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:a2e41e0b2ffd93a0e4e89589a540c12b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhc_1_1completion__future.html#a2e41e0b2ffd93a0e4e89589a540c12b3">copy_async</a> (InputIter srcBegin, InputIter srcEnd, const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:a2e41e0b2ffd93a0e4e89589a540c12b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest".  <a href="#a2e41e0b2ffd93a0e4e89589a540c12b3">More...</a><br /></td></tr>
<tr class="separator:a2e41e0b2ffd93a0e4e89589a540c12b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dead42e16926f7455bdfb1f786a2c27"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5dead42e16926f7455bdfb1f786a2c27"></a>
template&lt;typename InputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:a5dead42e16926f7455bdfb1f786a2c27"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_async</b> (InputIter srcBegin, <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="separator:a5dead42e16926f7455bdfb1f786a2c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af4158d367879e221a0855238d522e1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6af4158d367879e221a0855238d522e1"></a>
template&lt;typename InputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:a6af4158d367879e221a0855238d522e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_async</b> (InputIter srcBegin, const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="separator:a6af4158d367879e221a0855238d522e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda7ed5a362ffeae5e79043d52c8a5fc"><td class="memTemplParams" colspan="2">template&lt;typename OutputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:acda7ed5a362ffeae5e79043d52c8a5fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhc_1_1completion__future.html#acda7ed5a362ffeae5e79043d52c8a5fc">copy_async</a> (const <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;src, OutputIter destBegin)</td></tr>
<tr class="memdesc:acda7ed5a362ffeae5e79043d52c8a5fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of a source array are copied into "dest" starting with iterator destBegin.  <a href="#acda7ed5a362ffeae5e79043d52c8a5fc">More...</a><br /></td></tr>
<tr class="separator:acda7ed5a362ffeae5e79043d52c8a5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43553d43e88ea14acb1eda95b53dafff"><td class="memTemplParams" colspan="2">template&lt;typename OutputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:a43553d43e88ea14acb1eda95b53dafff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhc_1_1completion__future.html#a43553d43e88ea14acb1eda95b53dafff">copy_async</a> (const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;src, OutputIter destBegin)</td></tr>
<tr class="memdesc:a43553d43e88ea14acb1eda95b53dafff"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of a source array are copied into "dest" starting with iterator destBegin.  <a href="#a43553d43e88ea14acb1eda95b53dafff">More...</a><br /></td></tr>
<tr class="separator:a43553d43e88ea14acb1eda95b53dafff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_future&lt;void&gt;. </p>
<p>Similar to std::shared_future, this type provides member methods such as wait and get to wait for asynchronous operations to finish, and the type additionally provides a member method <a class="el" href="classhc_1_1completion__future.html#a3f05b8026ec7388ae1050dacf9ead33f" title="This method enables specification of a completion callback func which is executed upon completion of ...">then()</a>, to specify a completion callback functor to be executed upon completion of an asynchronous operation. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a403ffe10604f72c941145ba25ffe6449"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hc::completion_future::completion_future </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Constructs an empty uninitialized <a class="el" href="classhc_1_1completion__future.html" title="This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_...">completion_future</a> object which does not refer to any asynchronous operation. Default constructed <a class="el" href="classhc_1_1completion__future.html" title="This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_...">completion_future</a> objects have <a class="el" href="classhc_1_1completion__future.html#a1e4e2f0ac28c0591cbffca3ba834f173" title="This method is functionally identical to std::shared_future&lt;void&gt;::valid. ">valid()</a> == false </p>

</div>
</div>
<a class="anchor" id="a5b4a91569da4882386d41bb65f91808e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hc::completion_future::completion_future </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1completion__future.html">completion_future</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Constructs a new <a class="el" href="classhc_1_1completion__future.html" title="This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_...">completion_future</a> object that referes to the same asynchronous operation as the other <a class="el" href="classhc_1_1completion__future.html" title="This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_...">completion_future</a> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>An object of type <a class="el" href="classhc_1_1completion__future.html" title="This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_...">completion_future</a> from which to initialize this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a79b9c5841048800ae878c1b1bafad554"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hc::completion_future::completion_future </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhc_1_1completion__future.html">completion_future</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>Move constructs a new <a class="el" href="classhc_1_1completion__future.html" title="This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_...">completion_future</a> object that referes to the same asynchronous operation as originally refered by the other <a class="el" href="classhc_1_1completion__future.html" title="This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_...">completion_future</a> object. After this constructor returns, other.valid() == false</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>An object of type <a class="el" href="classhc_1_1completion__future.html" title="This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_...">completion_future</a> which the new <a class="el" href="classhc_1_1completion__future.html" title="This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_...">completion_future</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0d621ea8e29edc973ddba82d50f0e6c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hc::completion_future::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is functionally identical to std::shared_future&lt;void&gt;::get. </p>
<p>This method waits for the associated asynchronous operation to finish and returns only upon the completion of the asynchronous operation. If an exception was encountered during the execution of the asynchronous operation, this method throws that stored exception. </p>

</div>
</div>
<a class="anchor" id="adc3e34b6306626c247e9e3a7b90f88bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t hc::completion_future::get_begin_tick </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the tick number when the underlying asynchronous operation begins. </p>
<dl class="section return"><dt>Returns</dt><dd>An implementation-defined tick number in case the instance is created by a kernel dispatch or a barrier packet. 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a5a85a5ec745076aefcb4e7307ac1085f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t hc::completion_future::get_end_tick </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the tick number when the underlying asynchronous operation ends. </p>
<dl class="section return"><dt>Returns</dt><dd>An implementation-defined tick number in case the instance is created by a kernel dispatch or a barrier packet. 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aa698009690b76b417797c40f9d553310"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* hc::completion_future::get_native_handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the native handle for the asynchronous operation encapsulated in this <a class="el" href="classhc_1_1completion__future.html" title="This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_...">completion_future</a> object. </p>
<p>The method is mostly used for debugging purpose. Applications should retain the parent <a class="el" href="classhc_1_1completion__future.html" title="This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_...">completion_future</a> to ensure the native handle is not deallocated by the HCC runtime. The <a class="el" href="classhc_1_1completion__future.html" title="This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_...">completion_future</a> pointer to the native handle is reference counted, so a copy of the <a class="el" href="classhc_1_1completion__future.html" title="This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_...">completion_future</a> is sufficient to retain the native_handle. </p>

</div>
</div>
<a class="anchor" id="a3d9d9f0264ab10ec4fb94bdb2fe2787e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t hc::completion_future::get_tick_frequency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the frequency of ticks per second for the underlying asynchrnous operation. </p>
<dl class="section return"><dt>Returns</dt><dd>An implementation-defined frequency in Hz in case the instance is created by a kernel dispatch or a barrier packet. 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a55895b4ec2afce57cf65e8e46cc0a837"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int hc::completion_future::get_use_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>reference count for the completion future. Primarily used for debug purposes. </dd></dl>

</div>
</div>
<a class="anchor" id="aa6b9bae487568195a657af7f07961c21"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hc::completion_future::is_ready </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get if the async operations has been completed. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the async operation has been completed, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="aa264ef65bffd89f2ee42927344dcdf40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hc::completion_future::operator std::shared_future&lt; void &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator to std::shared_future&lt;void&gt;. </p>
<p>This method returns a shared_future&lt;void&gt; object corresponding to this <a class="el" href="classhc_1_1completion__future.html" title="This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_...">completion_future</a> object and refers to the same asynchronous operation. </p>

</div>
</div>
<a class="anchor" id="ae0a060016b06b6993bbe48370e6f0bc0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&amp; hc::completion_future::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1completion__future.html">completion_future</a> &amp;&#160;</td>
          <td class="paramname"><em>_Other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment. </p>
<p>Copy assigns the contents of other to this. This method causes this to stop referring its current asynchronous operation and start referring the same asynchronous operation as other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>An object of type <a class="el" href="classhc_1_1completion__future.html" title="This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_...">completion_future</a> which is copy assigned to this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0982718b5b93faa27c09de7ca2714644"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&amp; hc::completion_future::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhc_1_1completion__future.html">completion_future</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>_Other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment. </p>
<p>Move assigns the contents of other to this. This method causes this to stop referring its current asynchronous operation and start referring the same asynchronous operation as other. After this method returns, other.valid() == false</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>An object of type <a class="el" href="classhc_1_1completion__future.html" title="This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_...">completion_future</a> which is move assigned to this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3f05b8026ec7388ae1050dacf9ead33f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hc::completion_future::then </td>
          <td>(</td>
          <td class="paramtype">const functor &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method enables specification of a completion callback func which is executed upon completion of the asynchronous operation associated with this <a class="el" href="classhc_1_1completion__future.html" title="This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_...">completion_future</a> object. </p>
<p>The completion callback func should have an operator() that is valid when invoked with non arguments, i.e., "func()". </p>

</div>
</div>
<a class="anchor" id="a1e4e2f0ac28c0591cbffca3ba834f173"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hc::completion_future::valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is functionally identical to std::shared_future&lt;void&gt;::valid. </p>
<p>This returns true if this <a class="el" href="classhc_1_1completion__future.html" title="This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_...">completion_future</a> is associated with an asynchronous operation. </p>

</div>
</div>
<a class="anchor" id="a01252e442cf8ffc771484cfbb8014a15"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hc::completion_future::wait </td>
          <td>(</td>
          <td class="paramtype">hcWaitMode&#160;</td>
          <td class="paramname"><em>mode</em> = <code>hcWaitModeBlocked</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These methods are functionally identical to the corresponding std::shared_future&lt;void&gt; methods. </p>
<p>The wait method waits for the associated asynchronous operation to finish and returns only upon completion of the associated asynchronous operation or if an exception was encountered when executing the asynchronous operation.</p>
<p>The other variants are functionally identical to the std::shared_future&lt;void&gt; member methods with same names.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waitMode[in]</td><td>An optional parameter to specify the wait mode. By default it would be hcWaitModeBlocked. hcWaitModeActive would be used to reduce latency with the expense of using one CPU core for active waiting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7403fe6c91f04cfe32c58cd87c9d4ce9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Rep , class _Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future_status hc::completion_future::wait_for </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; _Rep, _Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>_Rel_time</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These methods are functionally identical to the corresponding std::shared_future&lt;void&gt; methods. </p>
<p>The wait method waits for the associated asynchronous operation to finish and returns only upon completion of the associated asynchronous operation or if an exception was encountered when executing the asynchronous operation.</p>
<p>The other variants are functionally identical to the std::shared_future&lt;void&gt; member methods with same names.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waitMode[in]</td><td>An optional parameter to specify the wait mode. By default it would be hcWaitModeBlocked. hcWaitModeActive would be used to reduce latency with the expense of using one CPU core for active waiting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a30afecbb79b9f01223da9818ddc62b40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Clock , class _Duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future_status hc::completion_future::wait_until </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::time_point&lt; _Clock, _Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>_Abs_time</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These methods are functionally identical to the corresponding std::shared_future&lt;void&gt; methods. </p>
<p>The wait method waits for the associated asynchronous operation to finish and returns only upon completion of the associated asynchronous operation or if an exception was encountered when executing the asynchronous operation.</p>
<p>The other variants are functionally identical to the std::shared_future&lt;void&gt; member methods with same names.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waitMode[in]</td><td>An optional parameter to specify the wait mode. By default it would be hcWaitModeBlocked. hcWaitModeActive would be used to reduce latency with the expense of using one CPU core for active waiting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="aa844be401447e725a12311b836d81db8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1completion__future.html">completion_future</a> copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; const T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array_view&lt;T,N&gt; (or <a class="el" href="classhc_1_1array__view_3_01const_01T_00_01N_01_4.html" title="The partial specialization array_view&lt;const T,N&gt; represents a view over elements of type const T with...">array_view&lt;const T, N&gt;</a>) to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array_view&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a535aac2c921b605a8f8f2f6a2e8efcb0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1completion__future.html">completion_future</a> copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>The source and destination may reside on different accelerators. If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array&lt;T,N&gt; to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb9f288599618932ad0cdaee476da043"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1completion__future.html">completion_future</a> copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array&lt;T,N&gt; to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array_view&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad304f24eae5c8ca313a4ae4a36649fe3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1completion__future.html">completion_future</a> copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; const T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array_view&lt;T,N&gt; (or <a class="el" href="classhc_1_1array__view_3_01const_01T_00_01N_01_4.html" title="The partial specialization array_view&lt;const T,N&gt; represents a view over elements of type const T with...">array_view&lt;const T, N&gt;</a>) to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a92d54aa63b816401aca0cb21efb885af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIter , typename T , int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1completion__future.html">completion_future</a> copy_async </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>srcBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>srcEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest". </p>
<p>If the number of elements in the iterator range is not equal to "dest.extent.size()", an exception is thrown.</p>
<p>In the overloads which don't take an end-iterator it is assumed that the source iterator is able to provide at least dest.extent.size() elements, but no checking is performed (nor possible).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBegin</td><td>An iterator to the first element of a source container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcEnd</td><td>An interator to the end of a source container. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2e41e0b2ffd93a0e4e89589a540c12b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIter , typename T , int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1completion__future.html">completion_future</a> copy_async </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>srcBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>srcEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest". </p>
<p>If the number of elements in the iterator range is not equal to "dest.extent.size()", an exception is thrown.</p>
<p>In the overloads which don't take an end-iterator it is assumed that the source iterator is able to provide at least dest.extent.size() elements, but no checking is performed (nor possible).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBegin</td><td>An iterator to the first element of a source container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcEnd</td><td>An interator to the end of a source container. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array_view&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acda7ed5a362ffeae5e79043d52c8a5fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputIter , typename T , int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1completion__future.html">completion_future</a> copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIter&#160;</td>
          <td class="paramname"><em>destBegin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The contents of a source array are copied into "dest" starting with iterator destBegin. </p>
<p>If the number of elements in the range starting destBegin in the destination container is smaller than "src.extent.size()", the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array&lt;T,N&gt; to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destBegin</td><td>An output iterator addressing the position of the first element in the destination container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a43553d43e88ea14acb1eda95b53dafff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputIter , typename T , int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1completion__future.html">completion_future</a> copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIter&#160;</td>
          <td class="paramname"><em>destBegin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The contents of a source array are copied into "dest" starting with iterator destBegin. </p>
<p>If the number of elements in the range starting destBegin in the destination container is smaller than "src.extent.size()", the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array_view&lt;T,N&gt; to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destBegin</td><td>An output iterator addressing the position of the first element in the destination container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/scchan/code/hcc/include/<a class="el" href="hc_8hpp_source.html">hc.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 13 2017 13:11:18 for HCC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
