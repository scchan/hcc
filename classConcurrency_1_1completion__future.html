<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>HCC: Concurrency::completion_future Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HCC
   </div>
   <div id="projectbrief">HCC is a single-source, C/C++ compiler for heterogeneous computing.  It&#39;s optimized with HSA (http://www.hsafoundation.com/).</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceConcurrency.html">Concurrency</a></li><li class="navelem"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classConcurrency_1_1completion__future-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Concurrency::completion_future Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class is the return type of all C++ AMP asynchronous APIs and has an interface analogous to std::shared_future&lt;void&gt;.  
 <a href="classConcurrency_1_1completion__future.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="amp_8h_source.html">amp.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for Concurrency::completion_future:</div>
<div class="dyncontent">
<div class="center"><img src="classConcurrency_1_1completion__future__coll__graph.png" border="0" usemap="#Concurrency_1_1completion__future_coll__map" alt="Collaboration graph"/></div>
<map name="Concurrency_1_1completion__future_coll__map" id="Concurrency_1_1completion__future_coll__map">
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4d6f8260c92c01897aadb9f502431b23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConcurrency_1_1completion__future.html#a4d6f8260c92c01897aadb9f502431b23">completion_future</a> ()</td></tr>
<tr class="memdesc:a4d6f8260c92c01897aadb9f502431b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a4d6f8260c92c01897aadb9f502431b23">More...</a><br /></td></tr>
<tr class="separator:a4d6f8260c92c01897aadb9f502431b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b32604265bcb7b34e482c54ad08cc8e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConcurrency_1_1completion__future.html#a8b32604265bcb7b34e482c54ad08cc8e">completion_future</a> (const <a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a> &amp;other)</td></tr>
<tr class="memdesc:a8b32604265bcb7b34e482c54ad08cc8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a8b32604265bcb7b34e482c54ad08cc8e">More...</a><br /></td></tr>
<tr class="separator:a8b32604265bcb7b34e482c54ad08cc8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc2b96f8fff9c0169ed3e603036457e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConcurrency_1_1completion__future.html#a9dc2b96f8fff9c0169ed3e603036457e">completion_future</a> (<a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a9dc2b96f8fff9c0169ed3e603036457e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#a9dc2b96f8fff9c0169ed3e603036457e">More...</a><br /></td></tr>
<tr class="separator:a9dc2b96f8fff9c0169ed3e603036457e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85cbe30114d3eb5689f0aaa88da68b51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConcurrency_1_1completion__future.html#a85cbe30114d3eb5689f0aaa88da68b51">operator=</a> (const <a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a> &amp;other)</td></tr>
<tr class="memdesc:a85cbe30114d3eb5689f0aaa88da68b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment.  <a href="#a85cbe30114d3eb5689f0aaa88da68b51">More...</a><br /></td></tr>
<tr class="separator:a85cbe30114d3eb5689f0aaa88da68b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0cba79cc7375551c082b9495be77e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConcurrency_1_1completion__future.html#a1d0cba79cc7375551c082b9495be77e4">operator=</a> (<a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a1d0cba79cc7375551c082b9495be77e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment.  <a href="#a1d0cba79cc7375551c082b9495be77e4">More...</a><br /></td></tr>
<tr class="separator:a1d0cba79cc7375551c082b9495be77e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd90988317705c8d4408b2a97802427d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConcurrency_1_1completion__future.html#acd90988317705c8d4408b2a97802427d">get</a> () const </td></tr>
<tr class="memdesc:acd90988317705c8d4408b2a97802427d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is functionally identical to std::shared_future&lt;void&gt;::get.  <a href="#acd90988317705c8d4408b2a97802427d">More...</a><br /></td></tr>
<tr class="separator:acd90988317705c8d4408b2a97802427d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1b91e2c8a6ec76da7ff3851699e825"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConcurrency_1_1completion__future.html#a5d1b91e2c8a6ec76da7ff3851699e825">valid</a> () const </td></tr>
<tr class="memdesc:a5d1b91e2c8a6ec76da7ff3851699e825"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is functionally identical to std::shared_future&lt;void&gt;::valid.  <a href="#a5d1b91e2c8a6ec76da7ff3851699e825">More...</a><br /></td></tr>
<tr class="separator:a5d1b91e2c8a6ec76da7ff3851699e825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af1148b8b0ae216348e93abf8db5141"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConcurrency_1_1completion__future.html#a1af1148b8b0ae216348e93abf8db5141">operator std::shared_future&lt; void &gt;</a> () const </td></tr>
<tr class="memdesc:a1af1148b8b0ae216348e93abf8db5141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator to std::shared_future&lt;void&gt;.  <a href="#a1af1148b8b0ae216348e93abf8db5141">More...</a><br /></td></tr>
<tr class="separator:a1af1148b8b0ae216348e93abf8db5141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aad7e5156b54ca337cdfeea69840771"><td class="memTemplParams" colspan="2">template&lt;typename functor &gt; </td></tr>
<tr class="memitem:a6aad7e5156b54ca337cdfeea69840771"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConcurrency_1_1completion__future.html#a6aad7e5156b54ca337cdfeea69840771">then</a> (const functor &amp;func)</td></tr>
<tr class="memdesc:a6aad7e5156b54ca337cdfeea69840771"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method enables specification of a completion callback func which is executed upon completion of the asynchronous operation associated with this <a class="el" href="classConcurrency_1_1completion__future.html" title="This class is the return type of all C++ AMP asynchronous APIs and has an interface analogous to std:...">completion_future</a> object.  <a href="#a6aad7e5156b54ca337cdfeea69840771">More...</a><br /></td></tr>
<tr class="separator:a6aad7e5156b54ca337cdfeea69840771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2ae089713e46945e93a0f623a037e419"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConcurrency_1_1completion__future.html#a2ae089713e46945e93a0f623a037e419">wait</a> () const </td></tr>
<tr class="memdesc:a2ae089713e46945e93a0f623a037e419"><td class="mdescLeft">&#160;</td><td class="mdescRight">These methods are functionally identical to the corresponding std::shared_future&lt;void&gt; methods.  <a href="#a2ae089713e46945e93a0f623a037e419">More...</a><br /></td></tr>
<tr class="separator:a2ae089713e46945e93a0f623a037e419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5101d841b17028e43daef9009e843752"><td class="memTemplParams" colspan="2">template&lt;class _Rep , class _Period &gt; </td></tr>
<tr class="memitem:a5101d841b17028e43daef9009e843752"><td class="memTemplItemLeft" align="right" valign="top">std::future_status&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConcurrency_1_1completion__future.html#a5101d841b17028e43daef9009e843752">wait_for</a> (const std::chrono::duration&lt; _Rep, _Period &gt; &amp;_Rel_time) const </td></tr>
<tr class="memdesc:a5101d841b17028e43daef9009e843752"><td class="mdescLeft">&#160;</td><td class="mdescRight">These methods are functionally identical to the corresponding std::shared_future&lt;void&gt; methods.  <a href="#a5101d841b17028e43daef9009e843752">More...</a><br /></td></tr>
<tr class="separator:a5101d841b17028e43daef9009e843752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3557913213b246482ac54ab205d6d6f4"><td class="memTemplParams" colspan="2">template&lt;class _Clock , class _Duration &gt; </td></tr>
<tr class="memitem:a3557913213b246482ac54ab205d6d6f4"><td class="memTemplItemLeft" align="right" valign="top">std::future_status&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConcurrency_1_1completion__future.html#a3557913213b246482ac54ab205d6d6f4">wait_until</a> (const std::chrono::time_point&lt; _Clock, _Duration &gt; &amp;_Abs_time) const </td></tr>
<tr class="memdesc:a3557913213b246482ac54ab205d6d6f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">These methods are functionally identical to the corresponding std::shared_future&lt;void&gt; methods.  <a href="#a3557913213b246482ac54ab205d6d6f4">More...</a><br /></td></tr>
<tr class="separator:a3557913213b246482ac54ab205d6d6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a1428cb4ad41918c12d64cc0bb4b2445d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1428cb4ad41918c12d64cc0bb4b2445d"></a>
template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:a1428cb4ad41918c12d64cc0bb4b2445d"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>array_view</b></td></tr>
<tr class="separator:a1428cb4ad41918c12d64cc0bb4b2445d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa844be401447e725a12311b836d81db8"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:aa844be401447e725a12311b836d81db8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConcurrency_1_1completion__future.html#aa844be401447e725a12311b836d81db8">copy_async</a> (const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; const T, N &gt; &amp;src, const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:aa844be401447e725a12311b836d81db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#aa844be401447e725a12311b836d81db8">More...</a><br /></td></tr>
<tr class="separator:aa844be401447e725a12311b836d81db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535aac2c921b605a8f8f2f6a2e8efcb0"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:a535aac2c921b605a8f8f2f6a2e8efcb0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConcurrency_1_1completion__future.html#a535aac2c921b605a8f8f2f6a2e8efcb0">copy_async</a> (const <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;src, <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:a535aac2c921b605a8f8f2f6a2e8efcb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#a535aac2c921b605a8f8f2f6a2e8efcb0">More...</a><br /></td></tr>
<tr class="separator:a535aac2c921b605a8f8f2f6a2e8efcb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9f288599618932ad0cdaee476da043"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:abb9f288599618932ad0cdaee476da043"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConcurrency_1_1completion__future.html#abb9f288599618932ad0cdaee476da043">copy_async</a> (const <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;src, const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:abb9f288599618932ad0cdaee476da043"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#abb9f288599618932ad0cdaee476da043">More...</a><br /></td></tr>
<tr class="separator:abb9f288599618932ad0cdaee476da043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aecea0e438f7fa647e1659ffced684f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3aecea0e438f7fa647e1659ffced684f"></a>
template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:a3aecea0e438f7fa647e1659ffced684f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_async</b> (const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;src, const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="separator:a3aecea0e438f7fa647e1659ffced684f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad304f24eae5c8ca313a4ae4a36649fe3"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:ad304f24eae5c8ca313a4ae4a36649fe3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConcurrency_1_1completion__future.html#ad304f24eae5c8ca313a4ae4a36649fe3">copy_async</a> (const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; const T, N &gt; &amp;src, <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:ad304f24eae5c8ca313a4ae4a36649fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#ad304f24eae5c8ca313a4ae4a36649fe3">More...</a><br /></td></tr>
<tr class="separator:ad304f24eae5c8ca313a4ae4a36649fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d54aa63b816401aca0cb21efb885af"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:a92d54aa63b816401aca0cb21efb885af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConcurrency_1_1completion__future.html#a92d54aa63b816401aca0cb21efb885af">copy_async</a> (InputIter srcBegin, InputIter srcEnd, <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:a92d54aa63b816401aca0cb21efb885af"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest".  <a href="#a92d54aa63b816401aca0cb21efb885af">More...</a><br /></td></tr>
<tr class="separator:a92d54aa63b816401aca0cb21efb885af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e41e0b2ffd93a0e4e89589a540c12b3"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:a2e41e0b2ffd93a0e4e89589a540c12b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConcurrency_1_1completion__future.html#a2e41e0b2ffd93a0e4e89589a540c12b3">copy_async</a> (InputIter srcBegin, InputIter srcEnd, const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:a2e41e0b2ffd93a0e4e89589a540c12b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest".  <a href="#a2e41e0b2ffd93a0e4e89589a540c12b3">More...</a><br /></td></tr>
<tr class="separator:a2e41e0b2ffd93a0e4e89589a540c12b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dead42e16926f7455bdfb1f786a2c27"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5dead42e16926f7455bdfb1f786a2c27"></a>
template&lt;typename InputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:a5dead42e16926f7455bdfb1f786a2c27"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_async</b> (InputIter srcBegin, <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="separator:a5dead42e16926f7455bdfb1f786a2c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af4158d367879e221a0855238d522e1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6af4158d367879e221a0855238d522e1"></a>
template&lt;typename InputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:a6af4158d367879e221a0855238d522e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_async</b> (InputIter srcBegin, const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="separator:a6af4158d367879e221a0855238d522e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda7ed5a362ffeae5e79043d52c8a5fc"><td class="memTemplParams" colspan="2">template&lt;typename OutputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:acda7ed5a362ffeae5e79043d52c8a5fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConcurrency_1_1completion__future.html#acda7ed5a362ffeae5e79043d52c8a5fc">copy_async</a> (const <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;src, OutputIter destBegin)</td></tr>
<tr class="memdesc:acda7ed5a362ffeae5e79043d52c8a5fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of a source array are copied into "dest" starting with iterator destBegin.  <a href="#acda7ed5a362ffeae5e79043d52c8a5fc">More...</a><br /></td></tr>
<tr class="separator:acda7ed5a362ffeae5e79043d52c8a5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43553d43e88ea14acb1eda95b53dafff"><td class="memTemplParams" colspan="2">template&lt;typename OutputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:a43553d43e88ea14acb1eda95b53dafff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConcurrency_1_1completion__future.html#a43553d43e88ea14acb1eda95b53dafff">copy_async</a> (const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;src, OutputIter destBegin)</td></tr>
<tr class="memdesc:a43553d43e88ea14acb1eda95b53dafff"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of a source array are copied into "dest" starting with iterator destBegin.  <a href="#a43553d43e88ea14acb1eda95b53dafff">More...</a><br /></td></tr>
<tr class="separator:a43553d43e88ea14acb1eda95b53dafff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class is the return type of all C++ AMP asynchronous APIs and has an interface analogous to std::shared_future&lt;void&gt;. </p>
<p>Similar to std::shared_future, this type provides member methods such as wait and get to wait for C++ AMP asynchronous operations to finish, and the type additionally provides a member method <a class="el" href="classConcurrency_1_1completion__future.html#a6aad7e5156b54ca337cdfeea69840771" title="This method enables specification of a completion callback func which is executed upon completion of ...">then()</a>, to specify a completion callback functor to be executed upon completion of a C++ AMP asynchronous operation. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4d6f8260c92c01897aadb9f502431b23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Concurrency::completion_future::completion_future </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Constructs an empty uninitialized <a class="el" href="classConcurrency_1_1completion__future.html" title="This class is the return type of all C++ AMP asynchronous APIs and has an interface analogous to std:...">completion_future</a> object which does not refer to any asynchronous operation. Default constructed <a class="el" href="classConcurrency_1_1completion__future.html" title="This class is the return type of all C++ AMP asynchronous APIs and has an interface analogous to std:...">completion_future</a> objects have <a class="el" href="classConcurrency_1_1completion__future.html#a5d1b91e2c8a6ec76da7ff3851699e825" title="This method is functionally identical to std::shared_future&lt;void&gt;::valid. ">valid()</a> == false </p>

</div>
</div>
<a class="anchor" id="a8b32604265bcb7b34e482c54ad08cc8e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Concurrency::completion_future::completion_future </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Constructs a new <a class="el" href="classConcurrency_1_1completion__future.html" title="This class is the return type of all C++ AMP asynchronous APIs and has an interface analogous to std:...">completion_future</a> object that referes to the same asynchronous operation as the other <a class="el" href="classConcurrency_1_1completion__future.html" title="This class is the return type of all C++ AMP asynchronous APIs and has an interface analogous to std:...">completion_future</a> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>An object of type <a class="el" href="classConcurrency_1_1completion__future.html" title="This class is the return type of all C++ AMP asynchronous APIs and has an interface analogous to std:...">completion_future</a> from which to initialize this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9dc2b96f8fff9c0169ed3e603036457e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Concurrency::completion_future::completion_future </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>Move constructs a new <a class="el" href="classConcurrency_1_1completion__future.html" title="This class is the return type of all C++ AMP asynchronous APIs and has an interface analogous to std:...">completion_future</a> object that referes to the same asynchronous operation as originally refered by the other <a class="el" href="classConcurrency_1_1completion__future.html" title="This class is the return type of all C++ AMP asynchronous APIs and has an interface analogous to std:...">completion_future</a> object. After this constructor returns, other.valid() == false</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>An object of type <a class="el" href="classConcurrency_1_1completion__future.html" title="This class is the return type of all C++ AMP asynchronous APIs and has an interface analogous to std:...">completion_future</a> which the new <a class="el" href="classConcurrency_1_1completion__future.html" title="This class is the return type of all C++ AMP asynchronous APIs and has an interface analogous to std:...">completion_future</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="acd90988317705c8d4408b2a97802427d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Concurrency::completion_future::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is functionally identical to std::shared_future&lt;void&gt;::get. </p>
<p>This method waits for the associated asynchronous operation to finish and returns only upon the completion of the asynchronous operation. If an exception was encountered during the execution of the asynchronous operation, this method throws that stored exception. </p>

</div>
</div>
<a class="anchor" id="a1af1148b8b0ae216348e93abf8db5141"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Concurrency::completion_future::operator std::shared_future&lt; void &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator to std::shared_future&lt;void&gt;. </p>
<p>This method returns a shared_future&lt;void&gt; object corresponding to this <a class="el" href="classConcurrency_1_1completion__future.html" title="This class is the return type of all C++ AMP asynchronous APIs and has an interface analogous to std:...">completion_future</a> object and refers to the same asynchronous operation. </p>

</div>
</div>
<a class="anchor" id="a85cbe30114d3eb5689f0aaa88da68b51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a>&amp; Concurrency::completion_future::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment. </p>
<p>Copy assigns the contents of other to this. This method causes this to stop referring its current asynchronous operation and start referring the same asynchronous operation as other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>An object of type <a class="el" href="classConcurrency_1_1completion__future.html" title="This class is the return type of all C++ AMP asynchronous APIs and has an interface analogous to std:...">completion_future</a> which is copy assigned to this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1d0cba79cc7375551c082b9495be77e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a>&amp; Concurrency::completion_future::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment. </p>
<p>Move assigns the contents of other to this. This method causes this to stop referring its current asynchronous operation and start referring the same asynchronous operation as other. After this method returns, other.valid() == false</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>An object of type <a class="el" href="classConcurrency_1_1completion__future.html" title="This class is the return type of all C++ AMP asynchronous APIs and has an interface analogous to std:...">completion_future</a> which is move assigned to this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6aad7e5156b54ca337cdfeea69840771"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Concurrency::completion_future::then </td>
          <td>(</td>
          <td class="paramtype">const functor &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method enables specification of a completion callback func which is executed upon completion of the asynchronous operation associated with this <a class="el" href="classConcurrency_1_1completion__future.html" title="This class is the return type of all C++ AMP asynchronous APIs and has an interface analogous to std:...">completion_future</a> object. </p>
<p>The completion callback func should have an operator() that is valid when invoked with non arguments, i.e., "func()". </p>

<p>References <a class="el" href="namespaceConcurrency.html#a79f8f54d8e9be7bedddaeb40b3fe10c0">Concurrency::copy_async()</a>.</p>

</div>
</div>
<a class="anchor" id="a5d1b91e2c8a6ec76da7ff3851699e825"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Concurrency::completion_future::valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is functionally identical to std::shared_future&lt;void&gt;::valid. </p>
<p>This returns true if this <a class="el" href="classConcurrency_1_1completion__future.html" title="This class is the return type of all C++ AMP asynchronous APIs and has an interface analogous to std:...">completion_future</a> is associated with an asynchronous operation. </p>

</div>
</div>
<a class="anchor" id="a2ae089713e46945e93a0f623a037e419"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Concurrency::completion_future::wait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These methods are functionally identical to the corresponding std::shared_future&lt;void&gt; methods. </p>
<p>The wait method waits for the associated asynchronous operation to finish and returns only upon completion of the associated asynchronous operation or if an exception was encountered when executing the asynchronous operation.</p>
<p>The other variants are functionally identical to the std::shared_future&lt;void&gt; member methods with same names. </p>

</div>
</div>
<a class="anchor" id="a5101d841b17028e43daef9009e843752"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Rep , class _Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future_status Concurrency::completion_future::wait_for </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; _Rep, _Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>_Rel_time</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These methods are functionally identical to the corresponding std::shared_future&lt;void&gt; methods. </p>
<p>The wait method waits for the associated asynchronous operation to finish and returns only upon completion of the associated asynchronous operation or if an exception was encountered when executing the asynchronous operation.</p>
<p>The other variants are functionally identical to the std::shared_future&lt;void&gt; member methods with same names. </p>

</div>
</div>
<a class="anchor" id="a3557913213b246482ac54ab205d6d6f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Clock , class _Duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future_status Concurrency::completion_future::wait_until </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::time_point&lt; _Clock, _Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>_Abs_time</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These methods are functionally identical to the corresponding std::shared_future&lt;void&gt; methods. </p>
<p>The wait method waits for the associated asynchronous operation to finish and returns only upon completion of the associated asynchronous operation or if an exception was encountered when executing the asynchronous operation.</p>
<p>The other variants are functionally identical to the std::shared_future&lt;void&gt; member methods with same names. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="aa844be401447e725a12311b836d81db8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a> copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; const T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array_view&lt;T,N&gt; (or <a class="el" href="classConcurrency_1_1array__view_3_01const_01T_00_01N_01_4.html" title="The partial specialization array_view&lt;const T,N&gt; represents a view over elements of type const T with...">array_view&lt;const T, N&gt;</a>) to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array_view&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a535aac2c921b605a8f8f2f6a2e8efcb0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a> copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>The source and destination may reside on different accelerators. If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array&lt;T,N&gt; to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb9f288599618932ad0cdaee476da043"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a> copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array&lt;T,N&gt; to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array_view&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad304f24eae5c8ca313a4ae4a36649fe3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a> copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; const T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array_view&lt;T,N&gt; (or <a class="el" href="classConcurrency_1_1array__view_3_01const_01T_00_01N_01_4.html" title="The partial specialization array_view&lt;const T,N&gt; represents a view over elements of type const T with...">array_view&lt;const T, N&gt;</a>) to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a92d54aa63b816401aca0cb21efb885af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIter , typename T , int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a> copy_async </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>srcBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>srcEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest". </p>
<p>If the number of elements in the iterator range is not equal to "dest.extent.size()", an exception is thrown.</p>
<p>In the overloads which don't take an end-iterator it is assumed that the source iterator is able to provide at least dest.extent.size() elements, but no checking is performed (nor possible).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBegin</td><td>An iterator to the first element of a source container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcEnd</td><td>An interator to the end of a source container. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2e41e0b2ffd93a0e4e89589a540c12b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIter , typename T , int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a> copy_async </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>srcBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>srcEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest". </p>
<p>If the number of elements in the iterator range is not equal to "dest.extent.size()", an exception is thrown.</p>
<p>In the overloads which don't take an end-iterator it is assumed that the source iterator is able to provide at least dest.extent.size() elements, but no checking is performed (nor possible).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBegin</td><td>An iterator to the first element of a source container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcEnd</td><td>An interator to the end of a source container. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array_view&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acda7ed5a362ffeae5e79043d52c8a5fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputIter , typename T , int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a> copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIter&#160;</td>
          <td class="paramname"><em>destBegin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The contents of a source array are copied into "dest" starting with iterator destBegin. </p>
<p>If the number of elements in the range starting destBegin in the destination container is smaller than "src.extent.size()", the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array&lt;T,N&gt; to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destBegin</td><td>An output iterator addressing the position of the first element in the destination container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a43553d43e88ea14acb1eda95b53dafff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputIter , typename T , int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConcurrency_1_1completion__future.html">completion_future</a> copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConcurrency_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIter&#160;</td>
          <td class="paramname"><em>destBegin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The contents of a source array are copied into "dest" starting with iterator destBegin. </p>
<p>If the number of elements in the range starting destBegin in the destination container is smaller than "src.extent.size()", the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array_view&lt;T,N&gt; to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destBegin</td><td>An output iterator addressing the position of the first element in the destination container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/scchan/code/hcc/include/<a class="el" href="amp_8h_source.html">amp.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 13 2017 13:11:18 for HCC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
