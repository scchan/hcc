<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>HCC: hc::accelerator_view Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HCC
   </div>
   <div id="projectbrief">HCC is a single-source, C/C++ compiler for heterogeneous computing.  It&#39;s optimized with HSA (http://www.hsafoundation.com/).</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacehc.html">hc</a></li><li class="navelem"><a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classhc_1_1accelerator__view-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">hc::accelerator_view Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a logical (isolated) accelerator view of a compute accelerator.  
 <a href="classhc_1_1accelerator__view.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="hc_8hpp_source.html">hc.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for hc::accelerator_view:</div>
<div class="dyncontent">
<div class="center"><img src="classhc_1_1accelerator__view__coll__graph.png" border="0" usemap="#hc_1_1accelerator__view_coll__map" alt="Collaboration graph"/></div>
<map name="hc_1_1accelerator__view_coll__map" id="hc_1_1accelerator__view_coll__map">
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a80310590ff29896e1aab865a97115713"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1accelerator__view.html#a80310590ff29896e1aab865a97115713">accelerator_view</a> (const <a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a> &amp;other)</td></tr>
<tr class="memdesc:a80310590ff29896e1aab865a97115713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-constructs an <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> object.  <a href="#a80310590ff29896e1aab865a97115713">More...</a><br /></td></tr>
<tr class="separator:a80310590ff29896e1aab865a97115713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad6750c735a1bfcea230e7831fe7fe3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1accelerator__view.html#a4ad6750c735a1bfcea230e7831fe7fe3">operator=</a> (const <a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a> &amp;other)</td></tr>
<tr class="memdesc:a4ad6750c735a1bfcea230e7831fe7fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns an <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> object to "this" <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> object and returns a reference to "this" object.  <a href="#a4ad6750c735a1bfcea230e7831fe7fe3">More...</a><br /></td></tr>
<tr class="separator:a4ad6750c735a1bfcea230e7831fe7fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a636d9e25e5c78623a94f969e98086c"><td class="memItemLeft" align="right" valign="top">queuing_mode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1accelerator__view.html#a5a636d9e25e5c78623a94f969e98086c">get_queuing_mode</a> () const </td></tr>
<tr class="memdesc:a5a636d9e25e5c78623a94f969e98086c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the queuing mode that this <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> was created with.  <a href="#a5a636d9e25e5c78623a94f969e98086c">More...</a><br /></td></tr>
<tr class="separator:a5a636d9e25e5c78623a94f969e98086c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd29ef09349b58e81023ccec42c5dd8b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd29ef09349b58e81023ccec42c5dd8b"></a>
execute_order&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1accelerator__view.html#afd29ef09349b58e81023ccec42c5dd8b">get_execute_order</a> () const </td></tr>
<tr class="memdesc:afd29ef09349b58e81023ccec42c5dd8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the execution order of this <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a>. <br /></td></tr>
<tr class="separator:afd29ef09349b58e81023ccec42c5dd8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8ce09b7652f6fc01b136afbb308887"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1accelerator__view.html#aca8ce09b7652f6fc01b136afbb308887">get_is_auto_selection</a> ()</td></tr>
<tr class="memdesc:aca8ce09b7652f6fc01b136afbb308887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a boolean value indicating whether the accelerator view when passed to a parallel_for_each would result in automatic selection of an appropriate execution target by the runtime.  <a href="#aca8ce09b7652f6fc01b136afbb308887">More...</a><br /></td></tr>
<tr class="separator:aca8ce09b7652f6fc01b136afbb308887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e94e5e775ccd10d267f8c0fa2d2946"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1accelerator__view.html#a70e94e5e775ccd10d267f8c0fa2d2946">get_version</a> () const </td></tr>
<tr class="memdesc:a70e94e5e775ccd10d267f8c0fa2d2946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a 32-bit unsigned integer representing the version number of this accelerator view.  <a href="#a70e94e5e775ccd10d267f8c0fa2d2946">More...</a><br /></td></tr>
<tr class="separator:a70e94e5e775ccd10d267f8c0fa2d2946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85abb4f2699cf94918aa56d0f485505c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85abb4f2699cf94918aa56d0f485505c"></a>
<a class="el" href="classhc_1_1accelerator.html">accelerator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1accelerator__view.html#a85abb4f2699cf94918aa56d0f485505c">get_accelerator</a> () const </td></tr>
<tr class="memdesc:a85abb4f2699cf94918aa56d0f485505c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the accelerator that this <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> has been created on. <br /></td></tr>
<tr class="separator:a85abb4f2699cf94918aa56d0f485505c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1cf975f5f2e4c8b33fea8793e8505e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1accelerator__view.html#ac1cf975f5f2e4c8b33fea8793e8505e4">get_is_debug</a> () const </td></tr>
<tr class="memdesc:ac1cf975f5f2e4c8b33fea8793e8505e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a boolean value indicating whether the <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> supports debugging through extensive error reporting.  <a href="#ac1cf975f5f2e4c8b33fea8793e8505e4">More...</a><br /></td></tr>
<tr class="separator:ac1cf975f5f2e4c8b33fea8793e8505e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2797b0e5b852c4d540b22dec520020cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1accelerator__view.html#a2797b0e5b852c4d540b22dec520020cc">wait</a> (hcWaitMode waitMode=hcWaitModeBlocked)</td></tr>
<tr class="memdesc:a2797b0e5b852c4d540b22dec520020cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a blocking wait for completion of all commands submitted to the accelerator view prior to calling <a class="el" href="classhc_1_1accelerator__view.html#a2797b0e5b852c4d540b22dec520020cc" title="Performs a blocking wait for completion of all commands submitted to the accelerator view prior to ca...">wait()</a>.  <a href="#a2797b0e5b852c4d540b22dec520020cc">More...</a><br /></td></tr>
<tr class="separator:a2797b0e5b852c4d540b22dec520020cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db436faa775a7ec4f6ea7cbea3f9a15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1accelerator__view.html#a7db436faa775a7ec4f6ea7cbea3f9a15">flush</a> ()</td></tr>
<tr class="memdesc:a7db436faa775a7ec4f6ea7cbea3f9a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the queued up commands in the <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> to the device for execution.  <a href="#a7db436faa775a7ec4f6ea7cbea3f9a15">More...</a><br /></td></tr>
<tr class="separator:a7db436faa775a7ec4f6ea7cbea3f9a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb57f1067104694b8b99bdb0019c9d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1accelerator__view.html#a6fb57f1067104694b8b99bdb0019c9d7">create_marker</a> (memory_scope fence_scope=system_scope) const </td></tr>
<tr class="memdesc:a6fb57f1067104694b8b99bdb0019c9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command inserts a marker event into the <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a>'s command queue.  <a href="#a6fb57f1067104694b8b99bdb0019c9d7">More...</a><br /></td></tr>
<tr class="separator:a6fb57f1067104694b8b99bdb0019c9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b31a0aa5f3726b97060ced34669ea5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1accelerator__view.html#a74b31a0aa5f3726b97060ced34669ea5">create_blocking_marker</a> (<a class="el" href="classhc_1_1completion__future.html">completion_future</a> &amp;dependent_future, memory_scope fence_scope=system_scope) const </td></tr>
<tr class="memdesc:a74b31a0aa5f3726b97060ced34669ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command inserts a marker event into the <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a>'s command queue with a prior dependent asynchronous event.  <a href="#a74b31a0aa5f3726b97060ced34669ea5">More...</a><br /></td></tr>
<tr class="separator:a74b31a0aa5f3726b97060ced34669ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9788f75a07fb8500fa877360e4550feb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1accelerator__view.html#a9788f75a07fb8500fa877360e4550feb">create_blocking_marker</a> (std::initializer_list&lt; <a class="el" href="classhc_1_1completion__future.html">completion_future</a> &gt; dependent_future_list, memory_scope fence_scope=system_scope) const </td></tr>
<tr class="memdesc:a9788f75a07fb8500fa877360e4550feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command inserts a marker event into the <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a>'s command queue with arbitrary number of dependent asynchronous events.  <a href="#a9788f75a07fb8500fa877360e4550feb">More...</a><br /></td></tr>
<tr class="separator:a9788f75a07fb8500fa877360e4550feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5396abb051ace54f83de8ec51de59b"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a8f5396abb051ace54f83de8ec51de59b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhc_1_1accelerator__view.html#a8f5396abb051ace54f83de8ec51de59b">create_blocking_marker</a> (InputIterator first, InputIterator last, memory_scope scope) const </td></tr>
<tr class="memdesc:a8f5396abb051ace54f83de8ec51de59b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command inserts a marker event into the <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a>'s command queue with arbitrary number of dependent asynchronous events.  <a href="#a8f5396abb051ace54f83de8ec51de59b">More...</a><br /></td></tr>
<tr class="separator:a8f5396abb051ace54f83de8ec51de59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7a153d6eae5a6ebb0e91787771ef7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1accelerator__view.html#afb7a153d6eae5a6ebb0e91787771ef7b">copy</a> (const void *src, void *dst, size_t size_bytes)</td></tr>
<tr class="memdesc:afb7a153d6eae5a6ebb0e91787771ef7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies size_bytes bytes from src to dst.  <a href="#afb7a153d6eae5a6ebb0e91787771ef7b">More...</a><br /></td></tr>
<tr class="separator:afb7a153d6eae5a6ebb0e91787771ef7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f22c8cd1da58df3c44551f1631e0f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1accelerator__view.html#a12f22c8cd1da58df3c44551f1631e0f3">copy_ext</a> (const void *src, void *dst, size_t size_bytes, hcCommandKind copyDir, const <a class="el" href="classhc_1_1AmPointerInfo.html">hc::AmPointerInfo</a> &amp;srcInfo, const <a class="el" href="classhc_1_1AmPointerInfo.html">hc::AmPointerInfo</a> &amp;dstInfo, const <a class="el" href="classhc_1_1accelerator.html">hc::accelerator</a> *copyAcc, bool forceUnpinnedCopy)</td></tr>
<tr class="memdesc:a12f22c8cd1da58df3c44551f1631e0f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies size_bytes bytes from src to dst.  <a href="#a12f22c8cd1da58df3c44551f1631e0f3">More...</a><br /></td></tr>
<tr class="separator:a12f22c8cd1da58df3c44551f1631e0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad44d695e181ee21dc09b4537810da6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afad44d695e181ee21dc09b4537810da6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>copy_ext</b> (const void *src, void *dst, size_t size_bytes, hcCommandKind copyDir, const <a class="el" href="classhc_1_1AmPointerInfo.html">hc::AmPointerInfo</a> &amp;srcInfo, const <a class="el" href="classhc_1_1AmPointerInfo.html">hc::AmPointerInfo</a> &amp;dstInfo, bool forceUnpinnedCopy)</td></tr>
<tr class="separator:afad44d695e181ee21dc09b4537810da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59a8f61023bd387eb6c7040d469ad46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1accelerator__view.html#ae59a8f61023bd387eb6c7040d469ad46">copy_async</a> (const void *src, void *dst, size_t size_bytes)</td></tr>
<tr class="memdesc:ae59a8f61023bd387eb6c7040d469ad46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies size_bytes bytes from src to dst.  <a href="#ae59a8f61023bd387eb6c7040d469ad46">More...</a><br /></td></tr>
<tr class="separator:ae59a8f61023bd387eb6c7040d469ad46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76860a7f25faf14d5355cba6c61afe2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1accelerator__view.html#ad76860a7f25faf14d5355cba6c61afe2">copy_async_ext</a> (const void *src, void *dst, size_t size_bytes, hcCommandKind copyDir, const <a class="el" href="classhc_1_1AmPointerInfo.html">hc::AmPointerInfo</a> &amp;srcInfo, const <a class="el" href="classhc_1_1AmPointerInfo.html">hc::AmPointerInfo</a> &amp;dstInfo, const <a class="el" href="classhc_1_1accelerator.html">hc::accelerator</a> *copyAcc)</td></tr>
<tr class="memdesc:ad76860a7f25faf14d5355cba6c61afe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies size_bytes bytes from src to dst.  <a href="#ad76860a7f25faf14d5355cba6c61afe2">More...</a><br /></td></tr>
<tr class="separator:ad76860a7f25faf14d5355cba6c61afe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171eaf8786311db5aa5aa0c8bd9617b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1accelerator__view.html#a171eaf8786311db5aa5aa0c8bd9617b2">operator==</a> (const <a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a> &amp;other) const </td></tr>
<tr class="memdesc:a171eaf8786311db5aa5aa0c8bd9617b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares "this" <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> with the passed <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> object to determine if they represent the same underlying object.  <a href="#a171eaf8786311db5aa5aa0c8bd9617b2">More...</a><br /></td></tr>
<tr class="separator:a171eaf8786311db5aa5aa0c8bd9617b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd9febc0d9594f5d92c3544f9024472"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1accelerator__view.html#a0cd9febc0d9594f5d92c3544f9024472">operator!=</a> (const <a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a> &amp;other) const </td></tr>
<tr class="memdesc:a0cd9febc0d9594f5d92c3544f9024472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares "this" <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> with the passed <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> object to determine if they represent different underlying objects.  <a href="#a0cd9febc0d9594f5d92c3544f9024472">More...</a><br /></td></tr>
<tr class="separator:a0cd9febc0d9594f5d92c3544f9024472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43fdd8166db38c96d2b44b103773ec86"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43fdd8166db38c96d2b44b103773ec86"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1accelerator__view.html#a43fdd8166db38c96d2b44b103773ec86">get_max_tile_static_size</a> ()</td></tr>
<tr class="memdesc:a43fdd8166db38c96d2b44b103773ec86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum size of tile static area available on this accelerator view. <br /></td></tr>
<tr class="separator:a43fdd8166db38c96d2b44b103773ec86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4fcb06427beb70a3e05b7ca42721baf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1accelerator__view.html#ae4fcb06427beb70a3e05b7ca42721baf">get_pending_async_ops</a> ()</td></tr>
<tr class="memdesc:ae4fcb06427beb70a3e05b7ca42721baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of pending asynchronous operations on this accelerator view.  <a href="#ae4fcb06427beb70a3e05b7ca42721baf">More...</a><br /></td></tr>
<tr class="separator:ae4fcb06427beb70a3e05b7ca42721baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25204d16342967d9781999a458d8a90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1accelerator__view.html#ac25204d16342967d9781999a458d8a90">get_is_empty</a> ()</td></tr>
<tr class="memdesc:ac25204d16342967d9781999a458d8a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> is currently empty.  <a href="#ac25204d16342967d9781999a458d8a90">More...</a><br /></td></tr>
<tr class="separator:ac25204d16342967d9781999a458d8a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a84ae80a3027030aef502bf4239b76"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1accelerator__view.html#ab5a84ae80a3027030aef502bf4239b76">get_hsa_queue</a> ()</td></tr>
<tr class="memdesc:ab5a84ae80a3027030aef502bf4239b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an opaque handle which points to the underlying HSA queue.  <a href="#ab5a84ae80a3027030aef502bf4239b76">More...</a><br /></td></tr>
<tr class="separator:ab5a84ae80a3027030aef502bf4239b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4268af2caa20e33f1637215d4422a31"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1accelerator__view.html#ac4268af2caa20e33f1637215d4422a31">get_hsa_agent</a> ()</td></tr>
<tr class="memdesc:ac4268af2caa20e33f1637215d4422a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an opaque handle which points to the underlying HSA agent.  <a href="#ac4268af2caa20e33f1637215d4422a31">More...</a><br /></td></tr>
<tr class="separator:ac4268af2caa20e33f1637215d4422a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7374bdaf0d209dd00d5a636305ab413"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1accelerator__view.html#af7374bdaf0d209dd00d5a636305ab413">get_hsa_am_region</a> ()</td></tr>
<tr class="memdesc:af7374bdaf0d209dd00d5a636305ab413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an opaque handle which points to the AM region on the HSA agent.  <a href="#af7374bdaf0d209dd00d5a636305ab413">More...</a><br /></td></tr>
<tr class="separator:af7374bdaf0d209dd00d5a636305ab413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be94cad7ceb57998b80bcf985239c8f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1accelerator__view.html#a2be94cad7ceb57998b80bcf985239c8f">get_hsa_am_system_region</a> ()</td></tr>
<tr class="memdesc:a2be94cad7ceb57998b80bcf985239c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an opaque handle which points to the AM system region on the HSA agent.  <a href="#a2be94cad7ceb57998b80bcf985239c8f">More...</a><br /></td></tr>
<tr class="separator:a2be94cad7ceb57998b80bcf985239c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57471dcc74c1cbeb329023f94c8b1f7a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1accelerator__view.html#a57471dcc74c1cbeb329023f94c8b1f7a">get_hsa_am_finegrained_system_region</a> ()</td></tr>
<tr class="memdesc:a57471dcc74c1cbeb329023f94c8b1f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an opaque handle which points to the AM system region on the HSA agent.  <a href="#a57471dcc74c1cbeb329023f94c8b1f7a">More...</a><br /></td></tr>
<tr class="separator:a57471dcc74c1cbeb329023f94c8b1f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5717e3c38d7ee88dd51ca1212f9ca15"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1accelerator__view.html#aa5717e3c38d7ee88dd51ca1212f9ca15">get_hsa_kernarg_region</a> ()</td></tr>
<tr class="memdesc:aa5717e3c38d7ee88dd51ca1212f9ca15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an opaque handle which points to the Kernarg region on the HSA agent.  <a href="#aa5717e3c38d7ee88dd51ca1212f9ca15">More...</a><br /></td></tr>
<tr class="separator:aa5717e3c38d7ee88dd51ca1212f9ca15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7bcc1d3115e5c501460d4568c81026"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c7bcc1d3115e5c501460d4568c81026"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1accelerator__view.html#a5c7bcc1d3115e5c501460d4568c81026">is_hsa_accelerator</a> ()</td></tr>
<tr class="memdesc:a5c7bcc1d3115e5c501460d4568c81026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the accelerator view is based on HSA. <br /></td></tr>
<tr class="separator:a5c7bcc1d3115e5c501460d4568c81026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914b04dda4b4c30cdd3d66a767089023"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1accelerator__view.html#a914b04dda4b4c30cdd3d66a767089023">dispatch_hsa_kernel</a> (const hsa_kernel_dispatch_packet_t *aql, const void *args, size_t argsize, <a class="el" href="classhc_1_1completion__future.html">hc::completion_future</a> *cf=nullptr, const char *kernel_name=nullptr)</td></tr>
<tr class="memdesc:a914b04dda4b4c30cdd3d66a767089023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch a kernel into the <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a>.  <a href="#a914b04dda4b4c30cdd3d66a767089023">More...</a><br /></td></tr>
<tr class="separator:a914b04dda4b4c30cdd3d66a767089023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94a4378ae6c08a4a823a0f7a43f2b3a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1accelerator__view.html#aa94a4378ae6c08a4a823a0f7a43f2b3a">set_cu_mask</a> (const std::vector&lt; bool &gt; &amp;cu_mask)</td></tr>
<tr class="memdesc:aa94a4378ae6c08a4a823a0f7a43f2b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a CU affinity to specific command queues.  <a href="#aa94a4378ae6c08a4a823a0f7a43f2b3a">More...</a><br /></td></tr>
<tr class="separator:aa94a4378ae6c08a4a823a0f7a43f2b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:afedbc0cd1677827d4cd454d8d6315344"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afedbc0cd1677827d4cd454d8d6315344"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>accelerator</b></td></tr>
<tr class="separator:afedbc0cd1677827d4cd454d8d6315344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5c2ff8d26f3e271ca30322cba48e55"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7a5c2ff8d26f3e271ca30322cba48e55"></a>
template&lt;typename Q , int K&gt; </td></tr>
<tr class="memitem:a7a5c2ff8d26f3e271ca30322cba48e55"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>array</b></td></tr>
<tr class="separator:a7a5c2ff8d26f3e271ca30322cba48e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1428cb4ad41918c12d64cc0bb4b2445d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1428cb4ad41918c12d64cc0bb4b2445d"></a>
template&lt;typename Q , int K&gt; </td></tr>
<tr class="memitem:a1428cb4ad41918c12d64cc0bb4b2445d"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>array_view</b></td></tr>
<tr class="separator:a1428cb4ad41918c12d64cc0bb4b2445d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac9a1fb4b130a8cea72e80224e51c19"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9ac9a1fb4b130a8cea72e80224e51c19"></a>
template&lt;typename Kernel &gt; </td></tr>
<tr class="memitem:a9ac9a1fb4b130a8cea72e80224e51c19"><td class="memTemplItemLeft" align="right" valign="top">void *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Kalmar::mcw_cxxamp_get_kernel</b> (const std::shared_ptr&lt; Kalmar::KalmarQueue &gt; &amp;, const Kernel &amp;)</td></tr>
<tr class="separator:a9ac9a1fb4b130a8cea72e80224e51c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e45faf6ca4ed0961d7b5f75b63b8932"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8e45faf6ca4ed0961d7b5f75b63b8932"></a>
template&lt;typename Kernel , int dim_ext&gt; </td></tr>
<tr class="memitem:a8e45faf6ca4ed0961d7b5f75b63b8932"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Kalmar::mcw_cxxamp_execute_kernel_with_dynamic_group_memory</b> (const std::shared_ptr&lt; Kalmar::KalmarQueue &gt; &amp;, size_t *, size_t *, const Kernel &amp;, void *, size_t)</td></tr>
<tr class="separator:a8e45faf6ca4ed0961d7b5f75b63b8932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c95760c7f2658ed37a57816ac75824b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6c95760c7f2658ed37a57816ac75824b"></a>
template&lt;typename Kernel , int dim_ext&gt; </td></tr>
<tr class="memitem:a6c95760c7f2658ed37a57816ac75824b"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; Kalmar::KalmarAsyncOp &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Kalmar::mcw_cxxamp_execute_kernel_with_dynamic_group_memory_async</b> (const std::shared_ptr&lt; Kalmar::KalmarQueue &gt; &amp;, size_t *, size_t *, const Kernel &amp;, void *, size_t)</td></tr>
<tr class="separator:a6c95760c7f2658ed37a57816ac75824b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c4a973b240f07537af23efd9edf43c"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad1c4a973b240f07537af23efd9edf43c"></a>
template&lt;typename Kernel , int dim_ext&gt; </td></tr>
<tr class="memitem:ad1c4a973b240f07537af23efd9edf43c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Kalmar::mcw_cxxamp_launch_kernel</b> (const std::shared_ptr&lt; Kalmar::KalmarQueue &gt; &amp;, size_t *, size_t *, const Kernel &amp;)</td></tr>
<tr class="separator:ad1c4a973b240f07537af23efd9edf43c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75fc091acf95072b7711bcc9a4553831"><td class="memTemplParams" colspan="2"><a class="anchor" id="a75fc091acf95072b7711bcc9a4553831"></a>
template&lt;typename Kernel , int dim_ext&gt; </td></tr>
<tr class="memitem:a75fc091acf95072b7711bcc9a4553831"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; Kalmar::KalmarAsyncOp &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Kalmar::mcw_cxxamp_launch_kernel_async</b> (const std::shared_ptr&lt; Kalmar::KalmarQueue &gt; &amp;, size_t *, size_t *, const Kernel &amp;)</td></tr>
<tr class="separator:a75fc091acf95072b7711bcc9a4553831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9845457ca0fb30c22f7c5f2e50e6148e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9845457ca0fb30c22f7c5f2e50e6148e"></a>
template&lt;int N, typename Kernel &gt; </td></tr>
<tr class="memitem:a9845457ca0fb30c22f7c5f2e50e6148e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_for_each</b> (const <a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a> &amp;, const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;, const Kernel &amp;)</td></tr>
<tr class="separator:a9845457ca0fb30c22f7c5f2e50e6148e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed48d9c9a588ca8c66ae67a120c6fac"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1ed48d9c9a588ca8c66ae67a120c6fac"></a>
template&lt;typename Kernel &gt; </td></tr>
<tr class="memitem:a1ed48d9c9a588ca8c66ae67a120c6fac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_for_each</b> (const <a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a> &amp;, const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; 1 &gt; &amp;, const Kernel &amp;)</td></tr>
<tr class="separator:a1ed48d9c9a588ca8c66ae67a120c6fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3720d3d03613dd372e71b7eaead94380"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3720d3d03613dd372e71b7eaead94380"></a>
template&lt;typename Kernel &gt; </td></tr>
<tr class="memitem:a3720d3d03613dd372e71b7eaead94380"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_for_each</b> (const <a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a> &amp;, const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; 2 &gt; &amp;, const Kernel &amp;)</td></tr>
<tr class="separator:a3720d3d03613dd372e71b7eaead94380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d892f5bb7ce2e6f83d0c0ef4ba3f69"><td class="memTemplParams" colspan="2"><a class="anchor" id="a26d892f5bb7ce2e6f83d0c0ef4ba3f69"></a>
template&lt;typename Kernel &gt; </td></tr>
<tr class="memitem:a26d892f5bb7ce2e6f83d0c0ef4ba3f69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_for_each</b> (const <a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a> &amp;, const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; 3 &gt; &amp;, const Kernel &amp;)</td></tr>
<tr class="separator:a26d892f5bb7ce2e6f83d0c0ef4ba3f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ca0c52379a9c0b25700f94c7bac2fd"><td class="memTemplParams" colspan="2"><a class="anchor" id="a41ca0c52379a9c0b25700f94c7bac2fd"></a>
template&lt;typename Kernel &gt; </td></tr>
<tr class="memitem:a41ca0c52379a9c0b25700f94c7bac2fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_for_each</b> (const <a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a> &amp;, const <a class="el" href="classhc_1_1tiled__extent.html">tiled_extent</a>&lt; 3 &gt; &amp;, const Kernel &amp;)</td></tr>
<tr class="separator:a41ca0c52379a9c0b25700f94c7bac2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0bb63846836f735e4364409fa6732fc"><td class="memTemplParams" colspan="2"><a class="anchor" id="af0bb63846836f735e4364409fa6732fc"></a>
template&lt;typename Kernel &gt; </td></tr>
<tr class="memitem:af0bb63846836f735e4364409fa6732fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_for_each</b> (const <a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a> &amp;, const <a class="el" href="classhc_1_1tiled__extent.html">tiled_extent</a>&lt; 2 &gt; &amp;, const Kernel &amp;)</td></tr>
<tr class="separator:af0bb63846836f735e4364409fa6732fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36615ad0f7692a99786a28aa788e70c"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad36615ad0f7692a99786a28aa788e70c"></a>
template&lt;typename Kernel &gt; </td></tr>
<tr class="memitem:ad36615ad0f7692a99786a28aa788e70c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_for_each</b> (const <a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a> &amp;, const <a class="el" href="classhc_1_1tiled__extent.html">tiled_extent</a>&lt; 1 &gt; &amp;, const Kernel &amp;)</td></tr>
<tr class="separator:ad36615ad0f7692a99786a28aa788e70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a logical (isolated) accelerator view of a compute accelerator. </p>
<p>An object of this type can be obtained by calling the default_view property or create_view member functions on an accelerator object. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a80310590ff29896e1aab865a97115713"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hc::accelerator_view::accelerator_view </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-constructs an <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> object. </p>
<p>This function does a shallow copy with the newly created <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> object pointing to the same underlying view as the "other" parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> object to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="afb7a153d6eae5a6ebb0e91787771ef7b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hc::accelerator_view::copy </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies size_bytes bytes from src to dst. </p>
<p>Src and dst must not overlap. Note the src is the first parameter and dst is second, following C++ convention. The copy command will execute after any commands already inserted into the <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> finish. This is a synchronous copy command, and the copy operation complete before this call returns. </p>

</div>
</div>
<a class="anchor" id="ae59a8f61023bd387eb6c7040d469ad46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1completion__future.html">completion_future</a> hc::accelerator_view::copy_async </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies size_bytes bytes from src to dst. </p>
<p>Src and dst must not overlap. Note the src is the first parameter and dst is second, following C++ convention. This is an asynchronous copy command, and this call may return before the copy operation completes. If the source or dest is host memory, the memory must be pinned or a runtime exception will be thrown. Pinned memory can be created with am_alloc with flag=amHostPinned flag.</p>
<p>The copy command will be implicitly ordered with respect to commands previously equeued to this <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a>:</p><ul>
<li>If the <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> execute_order is execute_in_order (the default), then the copy will execute after all previously sent commands finish execution.</li>
<li>If the <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> execute_order is execute_any_order, then the copy will start after all previously send commands start but can execute in any order. </li>
</ul>

</div>
</div>
<a class="anchor" id="ad76860a7f25faf14d5355cba6c61afe2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1completion__future.html">completion_future</a> hc::accelerator_view::copy_async_ext </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hcCommandKind&#160;</td>
          <td class="paramname"><em>copyDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhc_1_1AmPointerInfo.html">hc::AmPointerInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>srcInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhc_1_1AmPointerInfo.html">hc::AmPointerInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>dstInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhc_1_1accelerator.html">hc::accelerator</a> *&#160;</td>
          <td class="paramname"><em>copyAcc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies size_bytes bytes from src to dst. </p>
<p>Src and dst must not overlap. Note the src is the first parameter and dst is second, following C++ convention. This is an asynchronous copy command, and this call may return before the copy operation completes. If the source or dest is host memory, the memory must be pinned or a runtime exception will be thrown. Pinned memory can be created with am_alloc with flag=amHostPinned flag.</p>
<p>The copy command will be implicitly ordered with respect to commands previously enqueued to this <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a>:</p><ul>
<li>If the <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> execute_order is execute_in_order (the default), then the copy will execute after all previously sent commands finish execution.</li>
<li>If the <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> execute_order is execute_any_order, then the copy will start after all previously send commands start but can execute in any order. The copyAcc determines where the copy is executed and does not affect the ordering.</li>
</ul>
<p>The copy_async_ext flavor allows caller to provide additional information about each pointer, which can improve performance by eliminating replicated lookups, and also allow control over which device performs the copy. This interface is intended for language runtimes such as HIP.</p>
<p><code>copyDir</code> : Specify direction of copy. Must be hcMemcpyHostToHost, hcMemcpyHostToDevice, hcMemcpyDeviceToHost, or hcMemcpyDeviceToDevice. <code>copyAcc</code> : Specify which accelerator performs the copy operation. The specified accelerator must have access to the source and dest pointers - either because the memory is allocated on those devices or because the accelerator has peer access to the memory. If copyAcc is nullptr, then the copy will be performed by the host. In this case, the host accelerator must have access to both pointers. The copy operation will be performed by the specified engine but is not synchronized with respect to any operations on that device. </p>

</div>
</div>
<a class="anchor" id="a12f22c8cd1da58df3c44551f1631e0f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hc::accelerator_view::copy_ext </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hcCommandKind&#160;</td>
          <td class="paramname"><em>copyDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhc_1_1AmPointerInfo.html">hc::AmPointerInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>srcInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhc_1_1AmPointerInfo.html">hc::AmPointerInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>dstInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhc_1_1accelerator.html">hc::accelerator</a> *&#160;</td>
          <td class="paramname"><em>copyAcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceUnpinnedCopy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies size_bytes bytes from src to dst. </p>
<p>Src and dst must not overlap. Note the src is the first parameter and dst is second, following C++ convention. The copy command will execute after any commands already inserted into the <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> finish. This is a synchronous copy command, and the copy operation complete before this call returns. The copy_ext flavor allows caller to provide additional information about each pointer, which can improve performance by eliminating replicated lookups. This interface is intended for language runtimes such as HIP.</p>
<p><code>copyDir</code> : Specify direction of copy. Must be hcMemcpyHostToHost, hcMemcpyHostToDevice, hcMemcpyDeviceToHost, or hcMemcpyDeviceToDevice. <code>forceUnpinnedCopy</code> : Force copy to be performed with host involvement rather than with accelerator copy engines. </p>

</div>
</div>
<a class="anchor" id="a74b31a0aa5f3726b97060ced34669ea5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1completion__future.html">completion_future</a> hc::accelerator_view::create_blocking_marker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhc_1_1completion__future.html">completion_future</a> &amp;&#160;</td>
          <td class="paramname"><em>dependent_future</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memory_scope&#160;</td>
          <td class="paramname"><em>fence_scope</em> = <code>system_scope</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This command inserts a marker event into the <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a>'s command queue with a prior dependent asynchronous event. </p>
<p>This marker is returned as a <a class="el" href="classhc_1_1completion__future.html" title="This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_...">completion_future</a> object. When its dependent event and all commands submitted prior to the marker event creation have been completed, the future is ready.</p>
<p>Regardless of the <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a>'s execute_order (execute_any_order, execute_in_order), the marker always ensures older commands complete before the returned <a class="el" href="classhc_1_1completion__future.html" title="This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_...">completion_future</a> is marked ready. Thus, markers provide a mechanism to enforce order between commands in an execute_any_order <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a>.</p>
<p>fence_scope controls the scope of the acquire and release fences applied after the marker executes. Options are:</p><ul>
<li>no_scope : No fence operation is performed.</li>
<li>accelerator_scope: Memory is acquired from and released to the accelerator scope where the marker executes.</li>
<li>system_scope: Memory is acquired from and released to system scope (all accelerators including CPUs)</li>
</ul>
<p>dependent_futures may be recorded in another queue or another accelerator. If in another accelerator, the runtime performs cross-accelerator sychronization.</p>
<dl class="section return"><dt>Returns</dt><dd>A future which can be waited on, and will block until the current batch of commands, plus the dependent event have been completed. </dd></dl>

</div>
</div>
<a class="anchor" id="a9788f75a07fb8500fa877360e4550feb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1completion__future.html">completion_future</a> hc::accelerator_view::create_blocking_marker </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classhc_1_1completion__future.html">completion_future</a> &gt;&#160;</td>
          <td class="paramname"><em>dependent_future_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memory_scope&#160;</td>
          <td class="paramname"><em>fence_scope</em> = <code>system_scope</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This command inserts a marker event into the <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a>'s command queue with arbitrary number of dependent asynchronous events. </p>
<p>This marker is returned as a <a class="el" href="classhc_1_1completion__future.html" title="This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_...">completion_future</a> object. When its dependent events and all commands submitted prior to the marker event creation have been completed, the <a class="el" href="classhc_1_1completion__future.html" title="This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_...">completion_future</a> is ready.</p>
<p>Regardless of the <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a>'s execute_order (execute_any_order, execute_in_order), the marker always ensures older commands complete before the returned <a class="el" href="classhc_1_1completion__future.html" title="This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_...">completion_future</a> is marked ready. Thus, markers provide a mechanism to enforce order between commands in an execute_any_order <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a>.</p>
<p>fence_scope controls the scope of the acquire and release fences applied after the marker executes. Options are:</p><ul>
<li>no_scope : No fence operation is performed.</li>
<li>accelerator_scope: Memory is acquired from and released to the accelerator scope where the marker executes.</li>
<li>system_scope: Memory is acquired from and released to system scope (all accelerators including CPUs)</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>A future which can be waited on, and will block until the current batch of commands, plus the dependent event have been completed. </dd></dl>

</div>
</div>
<a class="anchor" id="a8f5396abb051ace54f83de8ec51de59b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1completion__future.html">completion_future</a> hc::accelerator_view::create_blocking_marker </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memory_scope&#160;</td>
          <td class="paramname"><em>scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This command inserts a marker event into the <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a>'s command queue with arbitrary number of dependent asynchronous events. </p>
<p>This marker is returned as a <a class="el" href="classhc_1_1completion__future.html" title="This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_...">completion_future</a> object. When its dependent events and all commands submitted prior to the marker event creation have been completed, the <a class="el" href="classhc_1_1completion__future.html" title="This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_...">completion_future</a> is ready.</p>
<p>Regardless of the <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a>'s execute_order (execute_any_order, execute_in_order), the marker always ensures older commands complete before the returned <a class="el" href="classhc_1_1completion__future.html" title="This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_...">completion_future</a> is marked ready. Thus, markers provide a mechanism to enforce order between commands in an execute_any_order <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A future which can be waited on, and will block until the current batch of commands, plus the dependent event have been completed. </dd></dl>

</div>
</div>
<a class="anchor" id="a6fb57f1067104694b8b99bdb0019c9d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1completion__future.html">completion_future</a> hc::accelerator_view::create_marker </td>
          <td>(</td>
          <td class="paramtype">memory_scope&#160;</td>
          <td class="paramname"><em>fence_scope</em> = <code>system_scope</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This command inserts a marker event into the <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a>'s command queue. </p>
<p>This marker is returned as a <a class="el" href="classhc_1_1completion__future.html" title="This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_...">completion_future</a> object. When all commands that were submitted prior to the marker event creation have completed, the future is ready.</p>
<p>Regardless of the <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a>'s execute_order (execute_any_order, execute_in_order), the marker always ensures older commands complete before the returned <a class="el" href="classhc_1_1completion__future.html" title="This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_...">completion_future</a> is marked ready. Thus, markers provide a mechanism to enforce order between commands in an execute_any_order <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a>.</p>
<p>fence_scope controls the scope of the acquire and release fences applied after the marker executes. Options are:</p><ul>
<li>no_scope : No fence operation is performed.</li>
<li>accelerator_scope: Memory is acquired from and released to the accelerator scope where the marker executes.</li>
<li>system_scope: Memory is acquired from and released to system scope (all accelerators including CPUs)</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>A future which can be waited on, and will block until the current batch of commands has completed. </dd></dl>

</div>
</div>
<a class="anchor" id="a914b04dda4b4c30cdd3d66a767089023"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hc::accelerator_view::dispatch_hsa_kernel </td>
          <td>(</td>
          <td class="paramtype">const hsa_kernel_dispatch_packet_t *&#160;</td>
          <td class="paramname"><em>aql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>argsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhc_1_1completion__future.html">hc::completion_future</a> *&#160;</td>
          <td class="paramname"><em>cf</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>kernel_name</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatch a kernel into the <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a>. </p>
<p>This function is intended to provide a gateway to dispatch code objects, with some assistance from HCC. Kernels are specified in the standard code object format, and can be created from a varety of compiler tools including the assembler, offline cl compilers, or other tools. The caller also specifies the execution configuration and kernel arguments. HCC will copy the kernel arguments into an appropriate segment and insert the packet into the queue. HCC will also automatically handle signal and kernarg allocation and deallocation for the command.</p>
<p>The kernel is dispatched asynchronously, and thus this API may return before the kernel finishes executing.</p>
<p>Kernels dispatched with this API may be interleaved with other copy and kernel commands generated from copy or parallel_for_each commands. The kernel honors the execute_order associated with the <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a>. Specifically, if execute_order is execute_in_order, then the kernel will wait for older data and kernel commands in the same queue before beginning execution. If execute_order is execute_any_order, then the kernel may begin executing without regards to the state of older kernels. This call honors the packer barrier bit (1 &lt;&lt; HSA_PACKET_HEADER_BARRIER) if set in the aql.header field. If set, this provides the same synchronization behaviora as execute_in_order for the command generated by this API.</p>
<p><code>aql</code> is an HSA-format "AQL" packet. The following fields must be set by the caller: aql.kernel_object aql.group_segment_size : includes static + dynamic group size aql.private_segment_size aql.grid_size_x, aql.grid_size_y, aql.grid_size_z aql.group_size_x, aql.group_size_y, aql.group_size_z aql.setup : The 2 bits at HSA_KERNEL_DISPATCH_PACKET_SETUP_DIMENSIONS. aql.header : Must specify the desired memory fence operations, and barrier bit (if desired.). A typical conservative setting would be: aql.header = (HSA_FENCE_SCOPE_SYSTEM &lt;&lt; HSA_PACKET_HEADER_ACQUIRE_FENCE_SCOPE) | (HSA_FENCE_SCOPE_SYSTEM &lt;&lt; HSA_PACKET_HEADER_RELEASE_FENCE_SCOPE) | (1 &lt;&lt; HSA_PACKET_HEADER_BARRIER);</p>
<p>The following fields are ignored. The API will will set up these fields before dispatching the AQL packet: aql.completion_signal aql.kernarg</p>
<p><code>args</code> : Pointer to kernel arguments with the size and aligment expected by the kernel. The args are copied and then passed directly to the kernel. After this function returns, the args memory may be deallocated. <code>argSz</code> : Size of the arguments. <code>cf</code> : Written with a <a class="el" href="classhc_1_1completion__future.html" title="This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_...">completion_future</a> that can be used to track the status of the dispatch. May be NULL, in which case no <a class="el" href="classhc_1_1completion__future.html" title="This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_...">completion_future</a> is returned and the caller must use other synchronization techniqueues such as calling <a class="el" href="classhc_1_1accelerator__view.html#a2797b0e5b852c4d540b22dec520020cc" title="Performs a blocking wait for completion of all commands submitted to the accelerator view prior to ca...">accelerator_view::wait()</a> or waiting on a younger command in the same queue. <code>kernel_name</code> : Optionally specify the name of the kernel for debug and profiling. May be null. If specified, the caller is responsible for ensuring the memory for the name remains allocated until the kernel completes.</p>
<p>The dispatch_hsa_kernel call will perform the following operations:</p><ul>
<li>Efficiently allocate a kernarg region and copy the arguments.</li>
<li>Efficiently allocate a signal, if required.</li>
<li>Dispatch the command into the queue and flush it to the GPU.</li>
<li>Kernargs and signals are automatically reclaimed by the HCC runtime. </li>
</ul>

</div>
</div>
<a class="anchor" id="a7db436faa775a7ec4f6ea7cbea3f9a15"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hc::accelerator_view::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends the queued up commands in the <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> to the device for execution. </p>
<p>An <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> internally maintains a buffer of commands such as data transfers between the host memory and device buffers, and kernel invocations (parallel_for_each calls). This member function sends the commands to the device for processing. Normally, these commands to the GPU automatically whenever the runtime determines that they need to be, such as when the command buffer is full or when waiting for transfer of data from the device buffers to host memory. The flush member function will send the commands manually to the device.</p>
<p>Calling this member function incurs an overhead and must be used with discretion. A typical use of this member function would be when the CPU waits for an arbitrary amount of time and would like to force the execution of queued device commands in the meantime. It can also be used to ensure that resources on the accelerator are reclaimed after all references to them have been removed.</p>
<p>Because flush operates asynchronously, it can return either before or after the device finishes executing the buffered commandser, the commands will eventually always complete.</p>
<p>If the queuing_mode is queuing_mode_immediate, this function has no effect.</p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ac4268af2caa20e33f1637215d4422a31"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* hc::accelerator_view::get_hsa_agent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an opaque handle which points to the underlying HSA agent. </p>
<dl class="section return"><dt>Returns</dt><dd>An opaque handle of the underlying HSA agent, if the accelerator view is based on HSA. NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a57471dcc74c1cbeb329023f94c8b1f7a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* hc::accelerator_view::get_hsa_am_finegrained_system_region </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an opaque handle which points to the AM system region on the HSA agent. </p>
<p>This region can be used to allocate finegrained system memory which is accessible from the specified accelerator.</p>
<dl class="section return"><dt>Returns</dt><dd>An opaque handle of the region, if the accelerator is based on HSA. NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="af7374bdaf0d209dd00d5a636305ab413"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* hc::accelerator_view::get_hsa_am_region </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an opaque handle which points to the AM region on the HSA agent. </p>
<p>This region can be used to allocate accelerator memory which is accessible from the specified accelerator.</p>
<dl class="section return"><dt>Returns</dt><dd>An opaque handle of the region, if the accelerator is based on HSA. NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a2be94cad7ceb57998b80bcf985239c8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* hc::accelerator_view::get_hsa_am_system_region </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an opaque handle which points to the AM system region on the HSA agent. </p>
<p>This region can be used to allocate system memory which is accessible from the specified accelerator.</p>
<dl class="section return"><dt>Returns</dt><dd>An opaque handle of the region, if the accelerator is based on HSA. NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5717e3c38d7ee88dd51ca1212f9ca15"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* hc::accelerator_view::get_hsa_kernarg_region </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an opaque handle which points to the Kernarg region on the HSA agent. </p>
<dl class="section return"><dt>Returns</dt><dd>An opaque handle of the region, if the accelerator view is based on HSA. NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5a84ae80a3027030aef502bf4239b76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* hc::accelerator_view::get_hsa_queue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an opaque handle which points to the underlying HSA queue. </p>
<dl class="section return"><dt>Returns</dt><dd>An opaque handle of the underlying HSA queue, if the accelerator view is based on HSA. NULL if otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aca8ce09b7652f6fc01b136afbb308887"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hc::accelerator_view::get_is_auto_selection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a boolean value indicating whether the accelerator view when passed to a parallel_for_each would result in automatic selection of an appropriate execution target by the runtime. </p>
<p>In other words, this is the accelerator view that will be automatically selected if parallel_for_each is invoked without explicitly specifying an accelerator view.</p>
<dl class="section return"><dt>Returns</dt><dd>A boolean value indicating if the <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> is the auto selection <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ac1cf975f5f2e4c8b33fea8793e8505e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hc::accelerator_view::get_is_debug </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a boolean value indicating whether the <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> supports debugging through extensive error reporting. </p>
<p>The is_debug property of the accelerator view is usually same as that of the parent accelerator. </p>

</div>
</div>
<a class="anchor" id="ac25204d16342967d9781999a458d8a90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hc::accelerator_view::get_is_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> is currently empty. </p>
<p>Care must be taken to use this API in a thread-safe manner. As the accelerator completes work, the queue may become empty after this function returns false; </p>

</div>
</div>
<a class="anchor" id="ae4fcb06427beb70a3e05b7ca42721baf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int hc::accelerator_view::get_pending_async_ops </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of pending asynchronous operations on this accelerator view. </p>
<p>Care must be taken to use this API in a thread-safe manner, </p>

</div>
</div>
<a class="anchor" id="a5a636d9e25e5c78623a94f969e98086c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">queuing_mode hc::accelerator_view::get_queuing_mode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the queuing mode that this <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> was created with. </p>
<p>See "Queuing Mode".</p>
<dl class="section return"><dt>Returns</dt><dd>The queuing mode. </dd></dl>

</div>
</div>
<a class="anchor" id="a70e94e5e775ccd10d267f8c0fa2d2946"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::accelerator_view::get_version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a 32-bit unsigned integer representing the version number of this accelerator view. </p>
<p>The format of the integer is major.minor, where the major version number is in the high-order 16 bits, and the minor version number is in the low-order bits.</p>
<p>The version of the accelerator view is usually the same as that of the parent accelerator. </p>

</div>
</div>
<a class="anchor" id="a0cd9febc0d9594f5d92c3544f9024472"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hc::accelerator_view::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares "this" <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> with the passed <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> object to determine if they represent different underlying objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> object to be compared against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean value indicating whether the passed <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> object is different from "this" <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a4ad6750c735a1bfcea230e7831fe7fe3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a>&amp; hc::accelerator_view::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns an <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> object to "this" <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> object and returns a reference to "this" object. </p>
<p>This function does a shallow assignment with the newly created <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> object pointing to the same underlying view as the passed <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> object to be assigned from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to "this" <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> object. </dd></dl>

</div>
</div>
<a class="anchor" id="a171eaf8786311db5aa5aa0c8bd9617b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hc::accelerator_view::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares "this" <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> with the passed <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> object to determine if they represent the same underlying object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> object to be compared against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean value indicating whether the passed <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a> object is same as "this" <a class="el" href="classhc_1_1accelerator__view.html" title="Represents a logical (isolated) accelerator view of a compute accelerator. ">accelerator_view</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aa94a4378ae6c08a4a823a0f7a43f2b3a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hc::accelerator_view::set_cu_mask </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>cu_mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a CU affinity to specific command queues. </p>
<p>The setting is permanent until the queue is destroyed or CU affinity is set again. This setting is "atomic", it won't affect the dispatch in flight.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cu_mask</td><td>a bool vector to indicate what CUs you want to use. True represents using the cu. The first 32 elements represents the first 32 CUs, and so on. If its size is greater than physical CU number, the extra elements are ignored. It is user's responsibility to make sure the input is meaningful.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if operations succeeds or false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a2797b0e5b852c4d540b22dec520020cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hc::accelerator_view::wait </td>
          <td>(</td>
          <td class="paramtype">hcWaitMode&#160;</td>
          <td class="paramname"><em>waitMode</em> = <code>hcWaitModeBlocked</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a blocking wait for completion of all commands submitted to the accelerator view prior to calling <a class="el" href="classhc_1_1accelerator__view.html#a2797b0e5b852c4d540b22dec520020cc" title="Performs a blocking wait for completion of all commands submitted to the accelerator view prior to ca...">wait()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waitMode[in]</td><td>An optional parameter to specify the wait mode. By default it would be hcWaitModeBlocked. hcWaitModeActive would be used to reduce latency with the expense of using one CPU core for active waiting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/scchan/code/hcc/include/<a class="el" href="hc_8hpp_source.html">hc.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 13 2017 13:11:18 for HCC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
