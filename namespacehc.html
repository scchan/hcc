<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>HCC: hc Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HCC
   </div>
   <div id="projectbrief">HCC is a single-source, C/C++ compiler for heterogeneous computing.  It&#39;s optimized with HSA (http://www.hsafoundation.com/).</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">hc Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Heterogeneous C++ (HC) namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhc_1_1____has__data.html">__has_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhc_1_1____has__size.html">__has_size</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhc_1_1____is__container.html">__is_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionhc_1_1____u.html">__u</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1accelerator.html">accelerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a physical accelerated computing device.  <a href="classhc_1_1accelerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a logical (isolated) accelerator view of a compute accelerator.  <a href="classhc_1_1accelerator__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhc_1_1am__allocator.html">am_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1AmPointerInfo.html">AmPointerInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array.html">array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an N-dimensional region of memory (with type T) located on an accelerator.  <a href="classhc_1_1array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhc_1_1array__projection__helper.html">array_projection_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhc_1_1array__projection__helper_3_01T_00_011_01_4.html">array_projection_helper&lt; T, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view.html">array_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T,N&gt;, or a section thereof.  <a href="classhc_1_1array__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1array__view_3_01const_01T_00_01N_01_4.html">array_view&lt; const T, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The partial specialization <a class="el" href="classhc_1_1array__view_3_01const_01T_00_01N_01_4.html" title="The partial specialization array_view&lt;const T,N&gt; represents a view over elements of type const T with...">array_view&lt;const T,N&gt;</a> represents a view over elements of type const T with rank N.  <a href="classhc_1_1array__view_3_01const_01T_00_01N_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1completion__future.html">completion_future</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is the return type of all asynchronous APIs and has an interface analogous to std::shared_future&lt;void&gt;.  <a href="classhc_1_1completion__future.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhc_1_1copy__bidir.html">copy_bidir</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhc_1_1copy__bidir_3_01T_00_01N_00_01N_01_4.html">copy_bidir&lt; T, N, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhc_1_1copy__input.html">copy_input</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhc_1_1copy__input_3_01InputIter_00_01T_00_01N_00_01N_01_4.html">copy_input&lt; InputIter, T, N, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhc_1_1copy__output.html">copy_output</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhc_1_1copy__output_3_01OutputIter_00_01T_00_01N_00_01N_01_4.html">copy_output&lt; OutputIter, T, N, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhc_1_1do__copy.html">do_copy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhc_1_1do__copy_3_01Iter_00_01T_00_011_01_4.html">do_copy&lt; Iter, T, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhc_1_1do__copy_3_01T_01_5_00_01T_00_011_01_4.html">do_copy&lt; T *, T, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhc_1_1do__copy_3_01T_01_5_00_01T_00_01N_01_4.html">do_copy&lt; T *, T, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1extent.html">extent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a unique position in N-dimensional space.  <a href="classhc_1_1extent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhc_1_1pfe__helper.html">pfe_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhc_1_1pfe__helper_3_010_00_01Kernel_00_01__Tp_01_4.html">pfe_helper&lt; 0, Kernel, _Tp &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1pfe__wrapper.html">pfe_wrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1PrintfPacket.html">PrintfPacket</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionhc_1_1PrintfPacketData.html">PrintfPacketData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhc_1_1projection__helper.html">projection_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhc_1_1projection__helper_3_01const_01T_00_011_01_4.html">projection_helper&lt; const T, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhc_1_1projection__helper_3_01const_01T_00_01N_01_4.html">projection_helper&lt; const T, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhc_1_1projection__helper_3_01T_00_011_01_4.html">projection_helper&lt; T, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1tile__barrier.html">tile_barrier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classhc_1_1tile__barrier.html" title="The tile_barrier class is a capability class that is only creatable by the system, and passed to a tiled parallel_for_each function object as part of the tiled_index parameter. ">tile_barrier</a> class is a capability class that is only creatable by the system, and passed to a tiled parallel_for_each function object as part of the <a class="el" href="classhc_1_1tiled__index.html" title="Represents a set of related indices subdivided into 1-, 2-, or 3-dimensional tiles. ">tiled_index</a> parameter.  <a href="classhc_1_1tile__barrier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1tiled__extent.html">tiled_extent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an extent subdivided into tiles.  <a href="classhc_1_1tiled__extent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1tiled__extent_3_011_01_4.html">tiled_extent&lt; 1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an extent subdivided into tiles.  <a href="classhc_1_1tiled__extent_3_011_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1tiled__extent_3_012_01_4.html">tiled_extent&lt; 2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an extent subdivided into tiles.  <a href="classhc_1_1tiled__extent_3_012_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1tiled__extent_3_013_01_4.html">tiled_extent&lt; 3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an extent subdivided into tiles.  <a href="classhc_1_1tiled__extent_3_013_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1tiled__index.html">tiled_index</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a set of related indices subdivided into 1-, 2-, or 3-dimensional tiles.  <a href="classhc_1_1tiled__index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1tiled__index_3_011_01_4.html">tiled_index&lt; 1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a set of related indices subdivided into 1-, 2-, or 3-dimensional tiles.  <a href="classhc_1_1tiled__index_3_011_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhc_1_1tiled__index_3_012_01_4.html">tiled_index&lt; 2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a set of related indices subdivided into 1-, 2-, or 3-dimensional tiles.  <a href="classhc_1_1tiled__index_3_012_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a76d71e557b828b0789b178426021e066"><td class="memTemplParams" colspan="2"><a class="anchor" id="a76d71e557b828b0789b178426021e066"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:a76d71e557b828b0789b178426021e066"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#a76d71e557b828b0789b178426021e066">index</a> = <a class="el" href="classKalmar_1_1index.html">Kalmar::index</a>&lt; N &gt;</td></tr>
<tr class="memdesc:a76d71e557b828b0789b178426021e066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a unique position in N-dimensional space. <br /></td></tr>
<tr class="separator:a76d71e557b828b0789b178426021e066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f9a6477a3460594a0df9d0c990ccf3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94f9a6477a3460594a0df9d0c990ccf3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>runtime_exception</b> = <a class="el" href="classKalmar_1_1runtime__exception.html">Kalmar::runtime_exception</a></td></tr>
<tr class="separator:a94f9a6477a3460594a0df9d0c990ccf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f539c31bc0c0b6211ffb978fa1ea35"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49f539c31bc0c0b6211ffb978fa1ea35"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>invalid_compute_domain</b> = <a class="el" href="classKalmar_1_1invalid__compute__domain.html">Kalmar::invalid_compute_domain</a></td></tr>
<tr class="separator:a49f539c31bc0c0b6211ffb978fa1ea35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41766090ea27f72b15b57247cef33169"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41766090ea27f72b15b57247cef33169"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>accelerator_view_removed</b> = <a class="el" href="classKalmar_1_1accelerator__view__removed.html">Kalmar::accelerator_view_removed</a></td></tr>
<tr class="separator:a41766090ea27f72b15b57247cef33169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ac7e15bc776ef653419f6d09c803f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30ac7e15bc776ef653419f6d09c803f1"></a>
typedef __fp16&#160;</td><td class="memItemRight" valign="bottom"><b>half</b></td></tr>
<tr class="separator:a30ac7e15bc776ef653419f6d09c803f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a3d7c100d0a6ea2dbcba28b5c4e5d1"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa9a3d7c100d0a6ea2dbcba28b5c4e5d1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa9a3d7c100d0a6ea2dbcba28b5c4e5d1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>pinned_vector</b> = std::vector&lt; T, <a class="el" href="structhc_1_1am__allocator.html">am_allocator</a>&lt; T &gt;&gt;</td></tr>
<tr class="separator:aa9a3d7c100d0a6ea2dbcba28b5c4e5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a06891784bb28777c7243d220cec2f643"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06891784bb28777c7243d220cec2f643"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>PrintfPacketDataType</b> { <br />
&#160;&#160;<b>PRINTF_BUFFER_SIZE</b> = 0, 
<b>PRINTF_STRING_BUFFER</b> = 1, 
<b>PRINTF_STRING_BUFFER_SIZE</b> = 2, 
<b>PRINTF_OFFSETS</b> = 3, 
<br />
&#160;&#160;<b>PRINTF_HEADER_SIZE</b> = 4, 
<b>PRINTF_MIN_SIZE</b> = 5, 
<b>PRINTF_UNUSED</b>, 
<b>PRINTF_UNSIGNED_INT</b>, 
<br />
&#160;&#160;<b>PRINTF_SIGNED_INT</b>, 
<b>PRINTF_FLOAT</b>, 
<b>PRINTF_DOUBLE</b>, 
<b>PRINTF_VOID_PTR</b>, 
<br />
&#160;&#160;<b>PRINTF_CONST_VOID_PTR</b>, 
<b>PRINTF_CHAR_PTR</b>, 
<b>PRINTF_CONST_CHAR_PTR</b>
<br />
 }</td></tr>
<tr class="separator:a06891784bb28777c7243d220cec2f643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50aef616026bb963d8b5522ad3c6330f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50aef616026bb963d8b5522ad3c6330f"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>PrintfError</b> { <b>PRINTF_SUCCESS</b> = 0, 
<b>PRINTF_BUFFER_OVERFLOW</b> = 1, 
<b>PRINTF_STRING_BUFFER_OVERFLOW</b> = 2, 
<b>PRINTF_UNKNOWN_ERROR</b> = 3
 }</td></tr>
<tr class="separator:a50aef616026bb963d8b5522ad3c6330f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af20faf82c2dbdd0030c10a6f0984a2a5"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#af20faf82c2dbdd0030c10a6f0984a2a5">get_system_ticks</a> ()</td></tr>
<tr class="memdesc:af20faf82c2dbdd0030c10a6f0984a2a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current tick count for the GPU platform.  <a href="#af20faf82c2dbdd0030c10a6f0984a2a5">More...</a><br /></td></tr>
<tr class="separator:af20faf82c2dbdd0030c10a6f0984a2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab206a54bb54ac1169e26f46034110938"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#ab206a54bb54ac1169e26f46034110938">get_tick_frequency</a> ()</td></tr>
<tr class="memdesc:ab206a54bb54ac1169e26f46034110938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the frequency of ticks per second for the underlying asynchrnous operation.  <a href="#ab206a54bb54ac1169e26f46034110938">More...</a><br /></td></tr>
<tr class="separator:ab206a54bb54ac1169e26f46034110938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efbfff1949cccdabe5e4c3c6733ab42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8efbfff1949cccdabe5e4c3c6733ab42"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>__wavesize</b> () __HC__</td></tr>
<tr class="separator:a8efbfff1949cccdabe5e4c3c6733ab42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ad4d92e0a809d37a40c2c327b4cccc"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#aa5ad4d92e0a809d37a40c2c327b4cccc">__popcount_u32_b32</a> (unsigned int input) __HC__</td></tr>
<tr class="memdesc:aa5ad4d92e0a809d37a40c2c327b4cccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count number of 1 bits in the input.  <a href="#aa5ad4d92e0a809d37a40c2c327b4cccc">More...</a><br /></td></tr>
<tr class="separator:aa5ad4d92e0a809d37a40c2c327b4cccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4ad6e19394f2c962632e4a1f2ba264"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a9a4ad6e19394f2c962632e4a1f2ba264">__popcount_u32_b64</a> (unsigned long long int input) __HC__</td></tr>
<tr class="memdesc:a9a4ad6e19394f2c962632e4a1f2ba264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count number of 1 bits in the input.  <a href="#a9a4ad6e19394f2c962632e4a1f2ba264">More...</a><br /></td></tr>
<tr class="separator:a9a4ad6e19394f2c962632e4a1f2ba264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39c28e56a9368c546ffb07489f39623"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#af39c28e56a9368c546ffb07489f39623">__firstbit_u32_u32</a> (unsigned int input) __HC__</td></tr>
<tr class="memdesc:af39c28e56a9368c546ffb07489f39623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count leading zero bits in the input.  <a href="#af39c28e56a9368c546ffb07489f39623">More...</a><br /></td></tr>
<tr class="separator:af39c28e56a9368c546ffb07489f39623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c9f4d9d7bc665fb83ac5c8797f2720"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#ae0c9f4d9d7bc665fb83ac5c8797f2720">__firstbit_u32_u64</a> (unsigned long long int input) __HC__</td></tr>
<tr class="memdesc:ae0c9f4d9d7bc665fb83ac5c8797f2720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count leading zero bits in the input.  <a href="#ae0c9f4d9d7bc665fb83ac5c8797f2720">More...</a><br /></td></tr>
<tr class="separator:ae0c9f4d9d7bc665fb83ac5c8797f2720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c8d47e6b5159b2bfff1acbac7a3112"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a21c8d47e6b5159b2bfff1acbac7a3112">__firstbit_u32_s32</a> (int input) __HC__</td></tr>
<tr class="memdesc:a21c8d47e6b5159b2bfff1acbac7a3112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count leading zero bits in the input.  <a href="#a21c8d47e6b5159b2bfff1acbac7a3112">More...</a><br /></td></tr>
<tr class="separator:a21c8d47e6b5159b2bfff1acbac7a3112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36408fe848adef2b9030bc6bd2761bf4"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a36408fe848adef2b9030bc6bd2761bf4">__firstbit_u32_s64</a> (long long int input) __HC__</td></tr>
<tr class="memdesc:a36408fe848adef2b9030bc6bd2761bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count leading zero bits in the input.  <a href="#a36408fe848adef2b9030bc6bd2761bf4">More...</a><br /></td></tr>
<tr class="separator:a36408fe848adef2b9030bc6bd2761bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790eb8855c4d34602b382ac9a2777600"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a790eb8855c4d34602b382ac9a2777600">__bitalign_b32</a> (unsigned int src0, unsigned int src1, unsigned int src2) __HC__</td></tr>
<tr class="memdesc:a790eb8855c4d34602b382ac9a2777600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Align 32 bits within 64 bits of data on an arbitrary bit boundary.  <a href="#a790eb8855c4d34602b382ac9a2777600">More...</a><br /></td></tr>
<tr class="separator:a790eb8855c4d34602b382ac9a2777600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dbaeaed929e26f2a768c72f1e39104b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a4dbaeaed929e26f2a768c72f1e39104b">__bytealign_b32</a> (unsigned int src0, unsigned int src1, unsigned int src2) __HC__</td></tr>
<tr class="memdesc:a4dbaeaed929e26f2a768c72f1e39104b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Align 32 bits within 64 bis of data on an arbitrary byte boundary.  <a href="#a4dbaeaed929e26f2a768c72f1e39104b">More...</a><br /></td></tr>
<tr class="separator:a4dbaeaed929e26f2a768c72f1e39104b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575ed483f89436a35d0827c90e23934f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a575ed483f89436a35d0827c90e23934f">__lerp_u8x4</a> (unsigned int src0, unsigned int src1, unsigned int src2) __HC__</td></tr>
<tr class="memdesc:a575ed483f89436a35d0827c90e23934f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do linear interpolation and computes the unsigned 8-bit average of packed data.  <a href="#a575ed483f89436a35d0827c90e23934f">More...</a><br /></td></tr>
<tr class="separator:a575ed483f89436a35d0827c90e23934f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b9b99aa1ada58dfe25b00c6b06950a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#af9b9b99aa1ada58dfe25b00c6b06950a">__packcvt_u8x4_f32</a> (float src0, float src1, float src2, float src3) __HC__</td></tr>
<tr class="memdesc:af9b9b99aa1ada58dfe25b00c6b06950a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes four floating-point number, convers them to unsigned integer values, and packs them into a packed u8x4 value.  <a href="#af9b9b99aa1ada58dfe25b00c6b06950a">More...</a><br /></td></tr>
<tr class="separator:af9b9b99aa1ada58dfe25b00c6b06950a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398e80d3ecd8163acc99b97ed2a4e699"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a398e80d3ecd8163acc99b97ed2a4e699">__unpackcvt_f32_u8x4</a> (unsigned int src0, unsigned int src1) __HC__</td></tr>
<tr class="memdesc:a398e80d3ecd8163acc99b97ed2a4e699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks a single element from a packed u8x4 value and converts it to an f32.  <a href="#a398e80d3ecd8163acc99b97ed2a4e699">More...</a><br /></td></tr>
<tr class="separator:a398e80d3ecd8163acc99b97ed2a4e699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b684a9f630186124fab2494a080963b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a3b684a9f630186124fab2494a080963b">__sadhi_u16x2_u8x4</a> (unsigned int src0, unsigned int src1, unsigned int src2) __HC__</td></tr>
<tr class="memdesc:a3b684a9f630186124fab2494a080963b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is mostly the same as sad except the sum of absolute differences is added to the most significant 16 bits of the result.  <a href="#a3b684a9f630186124fab2494a080963b">More...</a><br /></td></tr>
<tr class="separator:a3b684a9f630186124fab2494a080963b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0a139af8b91b2f5394564449e9034b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee0a139af8b91b2f5394564449e9034b"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#aee0a139af8b91b2f5394564449e9034b">__clock_u64</a> () __HC__</td></tr>
<tr class="memdesc:aee0a139af8b91b2f5394564449e9034b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get system timestamp. <br /></td></tr>
<tr class="separator:aee0a139af8b91b2f5394564449e9034b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addedc07838df1e5ecf1a78ccc1df3716"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#addedc07838df1e5ecf1a78ccc1df3716">__cycle_u64</a> () __HC__</td></tr>
<tr class="memdesc:addedc07838df1e5ecf1a78ccc1df3716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get hardware cycle count.  <a href="#addedc07838df1e5ecf1a78ccc1df3716">More...</a><br /></td></tr>
<tr class="separator:addedc07838df1e5ecf1a78ccc1df3716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518b02705c95b77399f523b078960863"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a518b02705c95b77399f523b078960863">__activelaneid_u32</a> () __HC__</td></tr>
<tr class="memdesc:a518b02705c95b77399f523b078960863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the count of the number of earlier (in flattened work-item order) active work-items within the same wavefront.  <a href="#a518b02705c95b77399f523b078960863">More...</a><br /></td></tr>
<tr class="separator:a518b02705c95b77399f523b078960863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d507a896f9181568db3d14694c98ab"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a48d507a896f9181568db3d14694c98ab">__activelanemask_v4_b64_b1</a> (unsigned int input) __HC__</td></tr>
<tr class="memdesc:a48d507a896f9181568db3d14694c98ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a bit mask shows which active work-items in the wavefront have a non-zero input.  <a href="#a48d507a896f9181568db3d14694c98ab">More...</a><br /></td></tr>
<tr class="separator:a48d507a896f9181568db3d14694c98ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab139e9ba8ec1252213934fc4ba671f5"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#aab139e9ba8ec1252213934fc4ba671f5">__activelanecount_u32_b1</a> (unsigned int input) __HC__</td></tr>
<tr class="memdesc:aab139e9ba8ec1252213934fc4ba671f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of active work-items in the current wavefront that have a non-zero input.  <a href="#aab139e9ba8ec1252213934fc4ba671f5">More...</a><br /></td></tr>
<tr class="separator:aab139e9ba8ec1252213934fc4ba671f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1feb90691ba66a88e32d41d7a426d60e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1feb90691ba66a88e32d41d7a426d60e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a1feb90691ba66a88e32d41d7a426d60e">__any</a> (int predicate) __HC__</td></tr>
<tr class="memdesc:a1feb90691ba66a88e32d41d7a426d60e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate predicate for all active work-items in the wavefront and return non-zero if and only if predicate evaluates to non-zero for all of them. <br /></td></tr>
<tr class="separator:a1feb90691ba66a88e32d41d7a426d60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7dbc5986d520b78d440045a029bdd36"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7dbc5986d520b78d440045a029bdd36"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#af7dbc5986d520b78d440045a029bdd36">__all</a> (int predicate) __HC__</td></tr>
<tr class="memdesc:af7dbc5986d520b78d440045a029bdd36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate predicate for all active work-items in the wavefront and return non-zero if and only if predicate evaluates to non-zero for any of them. <br /></td></tr>
<tr class="separator:af7dbc5986d520b78d440045a029bdd36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63928871bb9f5c1669df7fdb92e29a1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63928871bb9f5c1669df7fdb92e29a1a"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a63928871bb9f5c1669df7fdb92e29a1a">__ballot</a> (int predicate) __HC__</td></tr>
<tr class="memdesc:a63928871bb9f5c1669df7fdb92e29a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate predicate for all active work-items in the wavefront and return an integer whose Nth bit is set if and only if predicate evaluates to non-zero for the Nth work-item of the wavefront and the Nth work-item is active. <br /></td></tr>
<tr class="separator:a63928871bb9f5c1669df7fdb92e29a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b8e9546861cfdc6cc939aa8558f2b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4b8e9546861cfdc6cc939aa8558f2b4"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>__shfl_xor</b> (unsigned int var, int laneMask, int width=<a class="el" href="hc_8hpp.html#ab71c5e1746e89bffb56cfa5cd507ca24">__HSA_WAVEFRONT_SIZE__</a>) __HC__</td></tr>
<tr class="separator:af4b8e9546861cfdc6cc939aa8558f2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e28f0ab139f835c645ab905128dfb1"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a71e28f0ab139f835c645ab905128dfb1">__mul24</a> (unsigned int x, unsigned int y)[[hc]]</td></tr>
<tr class="memdesc:a71e28f0ab139f835c645ab905128dfb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two unsigned integers (x,y) but only the lower 24 bits will be used in the multiplication.  <a href="#a71e28f0ab139f835c645ab905128dfb1">More...</a><br /></td></tr>
<tr class="separator:a71e28f0ab139f835c645ab905128dfb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90dd9e111f0404723d3dcd48c3c427f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#ab90dd9e111f0404723d3dcd48c3c427f">__mul24</a> (int x, int y)[[hc]]</td></tr>
<tr class="memdesc:ab90dd9e111f0404723d3dcd48c3c427f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two integers (x,y) but only the lower 24 bits will be used in the multiplication.  <a href="#ab90dd9e111f0404723d3dcd48c3c427f">More...</a><br /></td></tr>
<tr class="separator:ab90dd9e111f0404723d3dcd48c3c427f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dbf9fbafaeb0fb18e68fbdeb8291b7c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a4dbf9fbafaeb0fb18e68fbdeb8291b7c">__mad24</a> (unsigned int x, unsigned int y, unsigned int z)[[hc]]</td></tr>
<tr class="memdesc:a4dbf9fbafaeb0fb18e68fbdeb8291b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two unsigned integers (x,y) but only the lower 24 bits will be used in the multiplication and then add the product to a 32-bit unsigned integer.  <a href="#a4dbf9fbafaeb0fb18e68fbdeb8291b7c">More...</a><br /></td></tr>
<tr class="separator:a4dbf9fbafaeb0fb18e68fbdeb8291b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3ff833b8dfd488fe9f29cfb29c1334"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#aec3ff833b8dfd488fe9f29cfb29c1334">__mad24</a> (int x, int y, int z)[[hc]]</td></tr>
<tr class="memdesc:aec3ff833b8dfd488fe9f29cfb29c1334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two integers (x,y) but only the lower 24 bits will be used in the multiplication and then add the product to a 32-bit integer.  <a href="#aec3ff833b8dfd488fe9f29cfb29c1334">More...</a><br /></td></tr>
<tr class="separator:aec3ff833b8dfd488fe9f29cfb29c1334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae968cb4b17a1a7f50a198d3e7917b64e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae968cb4b17a1a7f50a198d3e7917b64e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>abort</b> () __HC__</td></tr>
<tr class="separator:ae968cb4b17a1a7f50a198d3e7917b64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d125c77255cf875e818f574fd6255d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a10d125c77255cf875e818f574fd6255d">get_group_segment_size</a> () __HC__</td></tr>
<tr class="memdesc:a10d125c77255cf875e818f574fd6255d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the size of group segment.  <a href="#a10d125c77255cf875e818f574fd6255d">More...</a><br /></td></tr>
<tr class="separator:a10d125c77255cf875e818f574fd6255d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad0b4e17bb8c7c73107b5d9b383a2d3"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a8ad0b4e17bb8c7c73107b5d9b383a2d3">get_static_group_segment_size</a> () __HC__</td></tr>
<tr class="memdesc:a8ad0b4e17bb8c7c73107b5d9b383a2d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the size of static group segment.  <a href="#a8ad0b4e17bb8c7c73107b5d9b383a2d3">More...</a><br /></td></tr>
<tr class="separator:a8ad0b4e17bb8c7c73107b5d9b383a2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e86c303e95a21cdbcf9c7019694c3d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e86c303e95a21cdbcf9c7019694c3d9"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a5e86c303e95a21cdbcf9c7019694c3d9">get_group_segment_base_pointer</a> () __HC__</td></tr>
<tr class="memdesc:a5e86c303e95a21cdbcf9c7019694c3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the address of the beginning of group segment. <br /></td></tr>
<tr class="separator:a5e86c303e95a21cdbcf9c7019694c3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630288ca281db35cfb1b4d6c79c74bb5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a630288ca281db35cfb1b4d6c79c74bb5"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a630288ca281db35cfb1b4d6c79c74bb5">get_dynamic_group_segment_base_pointer</a> () __HC__</td></tr>
<tr class="memdesc:a630288ca281db35cfb1b4d6c79c74bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the address of the beginning of dynamic group segment. <br /></td></tr>
<tr class="separator:a630288ca281db35cfb1b4d6c79c74bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d96b992f50f35a84598b4a0e98d26b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a76d96b992f50f35a84598b4a0e98d26b">all_memory_fence</a> (const <a class="el" href="classhc_1_1tile__barrier.html">tile_barrier</a> &amp;) __HC__</td></tr>
<tr class="memdesc:a76d96b992f50f35a84598b4a0e98d26b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a thread-tile scoped memory fence for both global and tile-static memory operations.  <a href="#a76d96b992f50f35a84598b4a0e98d26b">More...</a><br /></td></tr>
<tr class="separator:a76d96b992f50f35a84598b4a0e98d26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60fb6bc2cb74e9120b6d444ea0dbf125"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a60fb6bc2cb74e9120b6d444ea0dbf125">global_memory_fence</a> (const <a class="el" href="classhc_1_1tile__barrier.html">tile_barrier</a> &amp;) __HC__</td></tr>
<tr class="memdesc:a60fb6bc2cb74e9120b6d444ea0dbf125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a thread-tile scoped memory fence for global (but not tile-static) memory operations.  <a href="#a60fb6bc2cb74e9120b6d444ea0dbf125">More...</a><br /></td></tr>
<tr class="separator:a60fb6bc2cb74e9120b6d444ea0dbf125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d1958ac18966c6c4ce871956bdfa0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a34d1958ac18966c6c4ce871956bdfa0f">tile_static_memory_fence</a> (const <a class="el" href="classhc_1_1tile__barrier.html">tile_barrier</a> &amp;) __HC__</td></tr>
<tr class="memdesc:a34d1958ac18966c6c4ce871956bdfa0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a thread-tile scoped memory fence for tile-static (but not global) memory operations.  <a href="#a34d1958ac18966c6c4ce871956bdfa0f">More...</a><br /></td></tr>
<tr class="separator:a34d1958ac18966c6c4ce871956bdfa0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354b3e390e2dceeee6db58a7f2405eb9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a354b3e390e2dceeee6db58a7f2405eb9"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:a354b3e390e2dceeee6db58a7f2405eb9"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>check</b> (const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;ext)</td></tr>
<tr class="separator:a354b3e390e2dceeee6db58a7f2405eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e59f3d3f5f72ca01b81e9e1bccf92f"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:a54e59f3d3f5f72ca01b81e9e1bccf92f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#a54e59f3d3f5f72ca01b81e9e1bccf92f">copy</a> (const <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;src, <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:a54e59f3d3f5f72ca01b81e9e1bccf92f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#a54e59f3d3f5f72ca01b81e9e1bccf92f">More...</a><br /></td></tr>
<tr class="separator:a54e59f3d3f5f72ca01b81e9e1bccf92f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc1fb2ba55b46d9b3456fc7c5456e7f"><td class="memTemplParams" colspan="2">template&lt;typename OutputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:a5fc1fb2ba55b46d9b3456fc7c5456e7f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#a5fc1fb2ba55b46d9b3456fc7c5456e7f">copy</a> (const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;src, OutputIter destBegin)</td></tr>
<tr class="memdesc:a5fc1fb2ba55b46d9b3456fc7c5456e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of a source array are copied into "dest" starting with iterator destBegin.  <a href="#a5fc1fb2ba55b46d9b3456fc7c5456e7f">More...</a><br /></td></tr>
<tr class="separator:a5fc1fb2ba55b46d9b3456fc7c5456e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1434fa4cb5b5c60ed2a302ec0837f0"><td class="memTemplParams" colspan="2">template&lt;typename OutputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:a2e1434fa4cb5b5c60ed2a302ec0837f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#a2e1434fa4cb5b5c60ed2a302ec0837f0">copy</a> (const <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;src, OutputIter destBegin)</td></tr>
<tr class="memdesc:a2e1434fa4cb5b5c60ed2a302ec0837f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of a source array are copied into "dest" starting with iterator destBegin.  <a href="#a2e1434fa4cb5b5c60ed2a302ec0837f0">More...</a><br /></td></tr>
<tr class="separator:a2e1434fa4cb5b5c60ed2a302ec0837f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c4d08885e472810f7dab21e5c44a1c"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:a19c4d08885e472810f7dab21e5c44a1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#a19c4d08885e472810f7dab21e5c44a1c">copy_async</a> (const <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;src, <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:a19c4d08885e472810f7dab21e5c44a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#a19c4d08885e472810f7dab21e5c44a1c">More...</a><br /></td></tr>
<tr class="separator:a19c4d08885e472810f7dab21e5c44a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7285314bc81e56f1fc641f1e33efc8"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:a9e7285314bc81e56f1fc641f1e33efc8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#a9e7285314bc81e56f1fc641f1e33efc8">copy_async</a> (const <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;src, const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:a9e7285314bc81e56f1fc641f1e33efc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#a9e7285314bc81e56f1fc641f1e33efc8">More...</a><br /></td></tr>
<tr class="separator:a9e7285314bc81e56f1fc641f1e33efc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac2ad6f6af293f315ccf83843d5338f"><td class="memTemplParams" colspan="2">template&lt;typename OutputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:a2ac2ad6f6af293f315ccf83843d5338f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#a2ac2ad6f6af293f315ccf83843d5338f">copy_async</a> (const <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;src, OutputIter destBegin)</td></tr>
<tr class="memdesc:a2ac2ad6f6af293f315ccf83843d5338f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of a source array are copied into "dest" starting with iterator destBegin.  <a href="#a2ac2ad6f6af293f315ccf83843d5338f">More...</a><br /></td></tr>
<tr class="separator:a2ac2ad6f6af293f315ccf83843d5338f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfca81adfdf1af6f9724114f095b3d5b"><td class="memTemplParams" colspan="2">template&lt;typename OutputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:abfca81adfdf1af6f9724114f095b3d5b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#abfca81adfdf1af6f9724114f095b3d5b">copy_async</a> (const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;src, OutputIter destBegin)</td></tr>
<tr class="memdesc:abfca81adfdf1af6f9724114f095b3d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of a source array are copied into "dest" starting with iterator destBegin.  <a href="#abfca81adfdf1af6f9724114f095b3d5b">More...</a><br /></td></tr>
<tr class="separator:abfca81adfdf1af6f9724114f095b3d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9889b01bcc016682dd56007aa424a5"><td class="memTemplParams" colspan="2"><a class="anchor" id="ada9889b01bcc016682dd56007aa424a5"></a>
template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:ada9889b01bcc016682dd56007aa424a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_async</b> (const <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;src, const <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="separator:ada9889b01bcc016682dd56007aa424a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4355c0ccd1e4865fa154c304aa5ec615"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4355c0ccd1e4865fa154c304aa5ec615"></a>
template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:a4355c0ccd1e4865fa154c304aa5ec615"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_async</b> (const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; const T, N &gt; &amp;src, const <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="separator:a4355c0ccd1e4865fa154c304aa5ec615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4171302f63662bcc8e527b65cfa48211"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4171302f63662bcc8e527b65cfa48211"></a>
template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:a4171302f63662bcc8e527b65cfa48211"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_async</b> (const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;src, const <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="separator:a4171302f63662bcc8e527b65cfa48211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc6976a1ea23546bbf65ecb4cd2caa8"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#adbc6976a1ea23546bbf65ecb4cd2caa8">__atomic_wrapinc</a> (unsigned int *address, unsigned int val) __HC__</td></tr>
<tr class="memdesc:adbc6976a1ea23546bbf65ecb4cd2caa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically do the following operations:  <a href="#adbc6976a1ea23546bbf65ecb4cd2caa8">More...</a><br /></td></tr>
<tr class="separator:adbc6976a1ea23546bbf65ecb4cd2caa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01f045e1ab6336e7776d3bbdadb65bc"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#aa01f045e1ab6336e7776d3bbdadb65bc">__atomic_wrapdec</a> (unsigned int *address, unsigned int val) __HC__</td></tr>
<tr class="memdesc:aa01f045e1ab6336e7776d3bbdadb65bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically do the following operations:  <a href="#aa01f045e1ab6336e7776d3bbdadb65bc">More...</a><br /></td></tr>
<tr class="separator:aa01f045e1ab6336e7776d3bbdadb65bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee6bcfef94d6634e610bfa508552b1e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8ee6bcfef94d6634e610bfa508552b1e"></a>
template&lt;int N, typename Kernel &gt; </td></tr>
<tr class="memitem:a8ee6bcfef94d6634e610bfa508552b1e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_for_each</b> (const <a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a> &amp;, const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;, const Kernel &amp;)</td></tr>
<tr class="separator:a8ee6bcfef94d6634e610bfa508552b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94f02d7c6805c5c8da78b5565f31b9a"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac94f02d7c6805c5c8da78b5565f31b9a"></a>
template&lt;typename Kernel &gt; </td></tr>
<tr class="memitem:ac94f02d7c6805c5c8da78b5565f31b9a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_for_each</b> (const <a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a> &amp;, const <a class="el" href="classhc_1_1tiled__extent.html">tiled_extent</a>&lt; 3 &gt; &amp;, const Kernel &amp;)</td></tr>
<tr class="separator:ac94f02d7c6805c5c8da78b5565f31b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc65a12a63a96b7764af87a97b3111f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9cc65a12a63a96b7764af87a97b3111f"></a>
template&lt;typename Kernel &gt; </td></tr>
<tr class="memitem:a9cc65a12a63a96b7764af87a97b3111f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_for_each</b> (const <a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a> &amp;, const <a class="el" href="classhc_1_1tiled__extent.html">tiled_extent</a>&lt; 2 &gt; &amp;, const Kernel &amp;)</td></tr>
<tr class="separator:a9cc65a12a63a96b7764af87a97b3111f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed24d80453011130d464f8a6010f28a6"><td class="memTemplParams" colspan="2"><a class="anchor" id="aed24d80453011130d464f8a6010f28a6"></a>
template&lt;typename Kernel &gt; </td></tr>
<tr class="memitem:aed24d80453011130d464f8a6010f28a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_for_each</b> (const <a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a> &amp;, const <a class="el" href="classhc_1_1tiled__extent.html">tiled_extent</a>&lt; 1 &gt; &amp;, const Kernel &amp;)</td></tr>
<tr class="separator:aed24d80453011130d464f8a6010f28a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed13872c54a6fcc55c8267d0ec857219"><td class="memTemplParams" colspan="2"><a class="anchor" id="aed13872c54a6fcc55c8267d0ec857219"></a>
template&lt;int N, typename Kernel &gt; </td></tr>
<tr class="memitem:aed13872c54a6fcc55c8267d0ec857219"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_for_each</b> (const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;compute_domain, const Kernel &amp;f)</td></tr>
<tr class="separator:aed13872c54a6fcc55c8267d0ec857219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0961c757e27dbd084946247a28dc740"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae0961c757e27dbd084946247a28dc740"></a>
template&lt;typename Kernel &gt; </td></tr>
<tr class="memitem:ae0961c757e27dbd084946247a28dc740"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_for_each</b> (const <a class="el" href="classhc_1_1tiled__extent.html">tiled_extent</a>&lt; 3 &gt; &amp;compute_domain, const Kernel &amp;f)</td></tr>
<tr class="separator:ae0961c757e27dbd084946247a28dc740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0d54991bec93f56c654e9e9288a389"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9b0d54991bec93f56c654e9e9288a389"></a>
template&lt;typename Kernel &gt; </td></tr>
<tr class="memitem:a9b0d54991bec93f56c654e9e9288a389"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_for_each</b> (const <a class="el" href="classhc_1_1tiled__extent.html">tiled_extent</a>&lt; 2 &gt; &amp;compute_domain, const Kernel &amp;f)</td></tr>
<tr class="separator:a9b0d54991bec93f56c654e9e9288a389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d3d9e2c3860e9848ed890de0b8823e"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa7d3d9e2c3860e9848ed890de0b8823e"></a>
template&lt;typename Kernel &gt; </td></tr>
<tr class="memitem:aa7d3d9e2c3860e9848ed890de0b8823e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_for_each</b> (const <a class="el" href="classhc_1_1tiled__extent.html">tiled_extent</a>&lt; 1 &gt; &amp;compute_domain, const Kernel &amp;f)</td></tr>
<tr class="separator:aa7d3d9e2c3860e9848ed890de0b8823e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b642fcc61f3b333ade5e82e5b2865e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a18b642fcc61f3b333ade5e82e5b2865e"></a>
template&lt;int N, typename Kernel &gt; </td></tr>
<tr class="memitem:a18b642fcc61f3b333ade5e82e5b2865e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>__attribute__</b> ((noinline, used)) <a class="el" href="classhc_1_1completion__future.html">completion_future</a> parallel_for_each(const <a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a> &amp;av</td></tr>
<tr class="separator:a18b642fcc61f3b333ade5e82e5b2865e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad363f223ecc7d9b8ecb03e989ddb8fd3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad363f223ecc7d9b8ecb03e989ddb8fd3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (av.get_accelerator().get_device_path()==L&quot;cpu&quot;)</td></tr>
<tr class="separator:ad363f223ecc7d9b8ecb03e989ddb8fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b15991db9b83ed49b0887bef2dc0026"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b15991db9b83ed49b0887bef2dc0026"></a>
return&#160;</td><td class="memItemRight" valign="bottom"><b>completion_future</b> (Kalmar::mcw_cxxamp_launch_kernel_async&lt; <a class="el" href="classhc_1_1pfe__wrapper.html">pfe_wrapper</a>&lt; N, Kernel &gt;, 3 &gt;(av.pQueue, ext, NULL, _pf))</td></tr>
<tr class="separator:a9b15991db9b83ed49b0887bef2dc0026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141ae4a6d25c99252d56ef5d2361f781"><td class="memTemplParams" colspan="2"><a class="anchor" id="a141ae4a6d25c99252d56ef5d2361f781"></a>
template&lt;typename Kernel &gt; </td></tr>
<tr class="memitem:a141ae4a6d25c99252d56ef5d2361f781"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>__attribute__</b> ((noinline, used)) <a class="el" href="classhc_1_1completion__future.html">completion_future</a> parallel_for_each(const <a class="el" href="classhc_1_1accelerator__view.html">accelerator_view</a> &amp;av</td></tr>
<tr class="separator:a141ae4a6d25c99252d56ef5d2361f781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1cfc551aeae0703d465e6706c0494a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b1cfc551aeae0703d465e6706c0494a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (compute_domain[0]&lt; 0)</td></tr>
<tr class="separator:a7b1cfc551aeae0703d465e6706c0494a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d00aa172452b98c132438aeaf2b0778"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d00aa172452b98c132438aeaf2b0778"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (static_cast&lt; size_t &gt;(compute_domain[0]) &gt; 4294967295L) throw invalid_compute_domain(&quot;Extent size too large.&quot;)</td></tr>
<tr class="separator:a0d00aa172452b98c132438aeaf2b0778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624c8d284da1ae35b4dc69ca5ce33bce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a624c8d284da1ae35b4dc69ca5ce33bce"></a>
return&#160;</td><td class="memItemRight" valign="bottom"><b>completion_future</b> (Kalmar::mcw_cxxamp_launch_kernel_async&lt; Kernel, 1 &gt;(av.pQueue,&amp;ext, NULL, f))</td></tr>
<tr class="separator:a624c8d284da1ae35b4dc69ca5ce33bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeab4e243535aa46ae78a173b25025a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abeab4e243535aa46ae78a173b25025a4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (static_cast&lt; size_t &gt;(compute_domain[1]) &gt; 4294967295L) throw invalid_compute_domain(&quot;Extent size too large.&quot;)</td></tr>
<tr class="separator:abeab4e243535aa46ae78a173b25025a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05059607430ee45ed1aa63158c05d16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af05059607430ee45ed1aa63158c05d16"></a>
return&#160;</td><td class="memItemRight" valign="bottom"><b>completion_future</b> (Kalmar::mcw_cxxamp_launch_kernel_async&lt; Kernel, 2 &gt;(av.pQueue, ext, NULL, f))</td></tr>
<tr class="separator:af05059607430ee45ed1aa63158c05d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003ed83133bea10594fc03b5310c2fdb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a003ed83133bea10594fc03b5310c2fdb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (static_cast&lt; size_t &gt;(compute_domain[2]) &gt; 4294967295L) throw invalid_compute_domain(&quot;Extent size too large.&quot;)</td></tr>
<tr class="separator:a003ed83133bea10594fc03b5310c2fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71071ebeb782e0a7b0d3473b155b5e37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71071ebeb782e0a7b0d3473b155b5e37"></a>
return&#160;</td><td class="memItemRight" valign="bottom"><b>completion_future</b> (Kalmar::mcw_cxxamp_launch_kernel_async&lt; Kernel, 3 &gt;(av.pQueue, ext, NULL, f))</td></tr>
<tr class="separator:a71071ebeb782e0a7b0d3473b155b5e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb1749539fb0030bd80b2aa5bfddd28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3eb1749539fb0030bd80b2aa5bfddd28"></a>
return&#160;</td><td class="memItemRight" valign="bottom"><b>completion_future</b> (Kalmar::mcw_cxxamp_execute_kernel_with_dynamic_group_memory_async&lt; Kernel, 1 &gt;(av.pQueue,&amp;ext,&amp;tile, f, kernel, compute_domain.get_dynamic_group_segment_size()))</td></tr>
<tr class="separator:a3eb1749539fb0030bd80b2aa5bfddd28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c44772b9f1e38f44e137ef418938ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7c44772b9f1e38f44e137ef418938ed"></a>
return&#160;</td><td class="memItemRight" valign="bottom"><b>completion_future</b> (Kalmar::mcw_cxxamp_execute_kernel_with_dynamic_group_memory_async&lt; Kernel, 2 &gt;(av.pQueue, ext, tile, f, kernel, compute_domain.get_dynamic_group_segment_size()))</td></tr>
<tr class="separator:ac7c44772b9f1e38f44e137ef418938ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0359254e32d402321bcb8d9284908740"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0359254e32d402321bcb8d9284908740"></a>
return&#160;</td><td class="memItemRight" valign="bottom"><b>completion_future</b> (Kalmar::mcw_cxxamp_execute_kernel_with_dynamic_group_memory_async&lt; Kernel, 3 &gt;(av.pQueue, ext, tile, f, kernel, compute_domain.get_dynamic_group_segment_size()))</td></tr>
<tr class="separator:a0359254e32d402321bcb8d9284908740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac045d9e161761a2f6f4c23e85783841"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classauto__voidp.html">auto_voidp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#aac045d9e161761a2f6f4c23e85783841">am_aligned_alloc</a> (std::size_t size, <a class="el" href="classhc_1_1accelerator.html">hc::accelerator</a> &amp;acc, unsigned flags, std::size_t alignment=0)</td></tr>
<tr class="memdesc:aac045d9e161761a2f6f4c23e85783841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a block of <code>size</code> bytes of memory on the specified <code>acc</code>.  <a href="#aac045d9e161761a2f6f4c23e85783841">More...</a><br /></td></tr>
<tr class="separator:aac045d9e161761a2f6f4c23e85783841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27438ff723607db97264d499bb159ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classauto__voidp.html">auto_voidp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#af27438ff723607db97264d499bb159ff">am_alloc</a> (std::size_t size, <a class="el" href="classhc_1_1accelerator.html">hc::accelerator</a> &amp;acc, unsigned flags)</td></tr>
<tr class="memdesc:af27438ff723607db97264d499bb159ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a block of <code>size</code> bytes of memory on the specified <code>acc</code>.  <a href="#af27438ff723607db97264d499bb159ff">More...</a><br /></td></tr>
<tr class="separator:af27438ff723607db97264d499bb159ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860681199cb960b9786dd39350fddbad"><td class="memItemLeft" align="right" valign="top">am_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a860681199cb960b9786dd39350fddbad">am_free</a> (void *ptr)</td></tr>
<tr class="memdesc:a860681199cb960b9786dd39350fddbad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a block of memory previously allocated with am_alloc.  <a href="#a860681199cb960b9786dd39350fddbad">More...</a><br /></td></tr>
<tr class="separator:a860681199cb960b9786dd39350fddbad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f220659dd7a945d89876cf68595e159"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f220659dd7a945d89876cf68595e159"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>while</b> (str[size]!='\0') size++</td></tr>
<tr class="separator:a4f220659dd7a945d89876cf68595e159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d78c4c6c3e49713bbe38e433ea2518"><td class="memTemplParams" colspan="2"><a class="anchor" id="a71d78c4c6c3e49713bbe38e433ea2518"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a71d78c4c6c3e49713bbe38e433ea2518"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structhc_1_1am__allocator.html">am_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="structhc_1_1am__allocator.html">am_allocator</a>&lt; U &gt; &amp;)</td></tr>
<tr class="separator:a71d78c4c6c3e49713bbe38e433ea2518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50f834cf1d421b1556cde363e8ce86d"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa50f834cf1d421b1556cde363e8ce86d"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:aa50f834cf1d421b1556cde363e8ce86d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="structhc_1_1am__allocator.html">am_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="structhc_1_1am__allocator.html">am_allocator</a>&lt; U &gt; &amp;)</td></tr>
<tr class="separator:aa50f834cf1d421b1556cde363e8ce86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4d3e42654ea30b4f586595e6d7c1b0ca"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a4d3e42654ea30b4f586595e6d7c1b0ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#a4d3e42654ea30b4f586595e6d7c1b0ca">operator+</a> (const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;lhs, const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;rhs) __CPU__ __HC__</td></tr>
<tr class="memdesc:a4d3e42654ea30b4f586595e6d7c1b0ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds (or subtracts) two objects of extent&lt;N&gt; to form a new extent.  <a href="#a4d3e42654ea30b4f586595e6d7c1b0ca">More...</a><br /></td></tr>
<tr class="separator:a4d3e42654ea30b4f586595e6d7c1b0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c9f9a9e42b162e941f6bb8cceec26e"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a49c9f9a9e42b162e941f6bb8cceec26e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#a49c9f9a9e42b162e941f6bb8cceec26e">operator-</a> (const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;lhs, const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;rhs) __CPU__ __HC__</td></tr>
<tr class="memdesc:a49c9f9a9e42b162e941f6bb8cceec26e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds (or subtracts) two objects of extent&lt;N&gt; to form a new extent.  <a href="#a49c9f9a9e42b162e941f6bb8cceec26e">More...</a><br /></td></tr>
<tr class="separator:a49c9f9a9e42b162e941f6bb8cceec26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa1d1f514a90e532aa0736b1b33e134b6"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:aa1d1f514a90e532aa0736b1b33e134b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#aa1d1f514a90e532aa0736b1b33e134b6">operator+</a> (const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;ext, int value) __CPU__ __HC__</td></tr>
<tr class="memdesc:aa1d1f514a90e532aa0736b1b33e134b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands.  <a href="#aa1d1f514a90e532aa0736b1b33e134b6">More...</a><br /></td></tr>
<tr class="separator:aa1d1f514a90e532aa0736b1b33e134b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4535cf3e8ab396987a0b02af1caa14c8"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a4535cf3e8ab396987a0b02af1caa14c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#a4535cf3e8ab396987a0b02af1caa14c8">operator+</a> (int value, const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;ext) __CPU__ __HC__</td></tr>
<tr class="memdesc:a4535cf3e8ab396987a0b02af1caa14c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands.  <a href="#a4535cf3e8ab396987a0b02af1caa14c8">More...</a><br /></td></tr>
<tr class="separator:a4535cf3e8ab396987a0b02af1caa14c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2463747f107a246000b7cd15bc1bc9"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a8e2463747f107a246000b7cd15bc1bc9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#a8e2463747f107a246000b7cd15bc1bc9">operator-</a> (const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;ext, int value) __CPU__ __HC__</td></tr>
<tr class="memdesc:a8e2463747f107a246000b7cd15bc1bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands.  <a href="#a8e2463747f107a246000b7cd15bc1bc9">More...</a><br /></td></tr>
<tr class="separator:a8e2463747f107a246000b7cd15bc1bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72e890fd253412f24b4b2920855053e"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:aa72e890fd253412f24b4b2920855053e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#aa72e890fd253412f24b4b2920855053e">operator-</a> (int value, const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;ext) __CPU__ __HC__</td></tr>
<tr class="memdesc:aa72e890fd253412f24b4b2920855053e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands.  <a href="#aa72e890fd253412f24b4b2920855053e">More...</a><br /></td></tr>
<tr class="separator:aa72e890fd253412f24b4b2920855053e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d71e064695bdbaa607737fb7136af86"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a9d71e064695bdbaa607737fb7136af86"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#a9d71e064695bdbaa607737fb7136af86">operator*</a> (const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;ext, int value) __CPU__ __HC__</td></tr>
<tr class="memdesc:a9d71e064695bdbaa607737fb7136af86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands.  <a href="#a9d71e064695bdbaa607737fb7136af86">More...</a><br /></td></tr>
<tr class="separator:a9d71e064695bdbaa607737fb7136af86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f515e67671ea7683322f90a73ce07f"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:ab3f515e67671ea7683322f90a73ce07f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#ab3f515e67671ea7683322f90a73ce07f">operator*</a> (int value, const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;ext) __CPU__ __HC__</td></tr>
<tr class="memdesc:ab3f515e67671ea7683322f90a73ce07f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands.  <a href="#ab3f515e67671ea7683322f90a73ce07f">More...</a><br /></td></tr>
<tr class="separator:ab3f515e67671ea7683322f90a73ce07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8038167eedd9bce712ce8523bd9a05ba"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a8038167eedd9bce712ce8523bd9a05ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#a8038167eedd9bce712ce8523bd9a05ba">operator/</a> (const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;ext, int value) __CPU__ __HC__</td></tr>
<tr class="memdesc:a8038167eedd9bce712ce8523bd9a05ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands.  <a href="#a8038167eedd9bce712ce8523bd9a05ba">More...</a><br /></td></tr>
<tr class="separator:a8038167eedd9bce712ce8523bd9a05ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974a4b7fb5625be322063b97b0dbe244"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a974a4b7fb5625be322063b97b0dbe244"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#a974a4b7fb5625be322063b97b0dbe244">operator/</a> (int value, const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;ext) __CPU__ __HC__</td></tr>
<tr class="memdesc:a974a4b7fb5625be322063b97b0dbe244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands.  <a href="#a974a4b7fb5625be322063b97b0dbe244">More...</a><br /></td></tr>
<tr class="separator:a974a4b7fb5625be322063b97b0dbe244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97a24725253fb9cd8c6dc906ac1deac"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:ac97a24725253fb9cd8c6dc906ac1deac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#ac97a24725253fb9cd8c6dc906ac1deac">operator%</a> (const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;ext, int value) __CPU__ __HC__</td></tr>
<tr class="memdesc:ac97a24725253fb9cd8c6dc906ac1deac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands.  <a href="#ac97a24725253fb9cd8c6dc906ac1deac">More...</a><br /></td></tr>
<tr class="separator:ac97a24725253fb9cd8c6dc906ac1deac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4756e26a413eed7b072c76a16d5cb283"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a4756e26a413eed7b072c76a16d5cb283"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#a4756e26a413eed7b072c76a16d5cb283">operator%</a> (int value, const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;ext) __CPU__ __HC__</td></tr>
<tr class="memdesc:a4756e26a413eed7b072c76a16d5cb283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands.  <a href="#a4756e26a413eed7b072c76a16d5cb283">More...</a><br /></td></tr>
<tr class="separator:a4756e26a413eed7b072c76a16d5cb283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab7d68af33b943427dfd864f21be8c1a7"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#ab7d68af33b943427dfd864f21be8c1a7">__bitextract_u32</a> (unsigned int src0, unsigned int src1, unsigned int src2) __HC__</td></tr>
<tr class="memdesc:ab7d68af33b943427dfd864f21be8c1a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a range of bits.  <a href="#ab7d68af33b943427dfd864f21be8c1a7">More...</a><br /></td></tr>
<tr class="separator:ab7d68af33b943427dfd864f21be8c1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c067ff1962e65bf38ab1b6ad8ba45c6"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a5c067ff1962e65bf38ab1b6ad8ba45c6">__bitextract_u64</a> (uint64_t src0, unsigned int src1, unsigned int src2) __HC__</td></tr>
<tr class="memdesc:a5c067ff1962e65bf38ab1b6ad8ba45c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a range of bits.  <a href="#a5c067ff1962e65bf38ab1b6ad8ba45c6">More...</a><br /></td></tr>
<tr class="separator:a5c067ff1962e65bf38ab1b6ad8ba45c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2336cdaba01761e44fbefddbcd078170"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a2336cdaba01761e44fbefddbcd078170">__bitextract_s32</a> (int src0, unsigned int src1, unsigned int src2) __HC__</td></tr>
<tr class="memdesc:a2336cdaba01761e44fbefddbcd078170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a range of bits.  <a href="#a2336cdaba01761e44fbefddbcd078170">More...</a><br /></td></tr>
<tr class="separator:a2336cdaba01761e44fbefddbcd078170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2c18450fe385de1be4f3db29b55671"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a9a2c18450fe385de1be4f3db29b55671">__bitextract_s64</a> (int64_t src0, unsigned int src1, unsigned int src2) __HC__</td></tr>
<tr class="memdesc:a9a2c18450fe385de1be4f3db29b55671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a range of bits.  <a href="#a9a2c18450fe385de1be4f3db29b55671">More...</a><br /></td></tr>
<tr class="separator:a9a2c18450fe385de1be4f3db29b55671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a961ff948dde14859acb29aa1ce1c7988"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a961ff948dde14859acb29aa1ce1c7988">__bitinsert_u32</a> (unsigned int src0, unsigned int src1, unsigned int src2, unsigned int src3) __HC__</td></tr>
<tr class="memdesc:a961ff948dde14859acb29aa1ce1c7988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a range of bits.  <a href="#a961ff948dde14859acb29aa1ce1c7988">More...</a><br /></td></tr>
<tr class="separator:a961ff948dde14859acb29aa1ce1c7988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4837929d10e0e5e3b2c6d46e72d2413f"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a4837929d10e0e5e3b2c6d46e72d2413f">__bitinsert_u64</a> (uint64_t src0, uint64_t src1, unsigned int src2, unsigned int src3) __HC__</td></tr>
<tr class="memdesc:a4837929d10e0e5e3b2c6d46e72d2413f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a range of bits.  <a href="#a4837929d10e0e5e3b2c6d46e72d2413f">More...</a><br /></td></tr>
<tr class="separator:a4837929d10e0e5e3b2c6d46e72d2413f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e425f01102241414c6daf8a4353617"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a97e425f01102241414c6daf8a4353617">__bitinsert_s32</a> (int src0, int src1, unsigned int src2, unsigned int src3) __HC__</td></tr>
<tr class="memdesc:a97e425f01102241414c6daf8a4353617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a range of bits.  <a href="#a97e425f01102241414c6daf8a4353617">More...</a><br /></td></tr>
<tr class="separator:a97e425f01102241414c6daf8a4353617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a1e61a0026a81e5883b3fa0d69faf3"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#af8a1e61a0026a81e5883b3fa0d69faf3">__bitinsert_s64</a> (int64_t src0, int64_t src1, unsigned int src2, unsigned int src3) __HC__</td></tr>
<tr class="memdesc:af8a1e61a0026a81e5883b3fa0d69faf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a range of bits.  <a href="#af8a1e61a0026a81e5883b3fa0d69faf3">More...</a><br /></td></tr>
<tr class="separator:af8a1e61a0026a81e5883b3fa0d69faf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3eb60d1735ef8a9e657048776ec18de6"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a3eb60d1735ef8a9e657048776ec18de6">__bitmask_b32</a> (unsigned int src0, unsigned int src1) __HC__</td></tr>
<tr class="memdesc:a3eb60d1735ef8a9e657048776ec18de6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a bit mask that can be used with bitselect.  <a href="#a3eb60d1735ef8a9e657048776ec18de6">More...</a><br /></td></tr>
<tr class="separator:a3eb60d1735ef8a9e657048776ec18de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a73bfdc3c8a9d202125a697e542cee9"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a3a73bfdc3c8a9d202125a697e542cee9">__bitmask_b64</a> (unsigned int src0, unsigned int src1) __HC__</td></tr>
<tr class="memdesc:a3a73bfdc3c8a9d202125a697e542cee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a bit mask that can be used with bitselect.  <a href="#a3a73bfdc3c8a9d202125a697e542cee9">More...</a><br /></td></tr>
<tr class="separator:a3a73bfdc3c8a9d202125a697e542cee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a368bdf36391edbcf3648416366aebca0"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a368bdf36391edbcf3648416366aebca0">__bitrev_b32</a> (unsigned int src0)[[hc]] __asm(&quot;llvm.bitreverse.i32&quot;)</td></tr>
<tr class="memdesc:a368bdf36391edbcf3648416366aebca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse the bits.  <a href="#a368bdf36391edbcf3648416366aebca0">More...</a><br /></td></tr>
<tr class="separator:a368bdf36391edbcf3648416366aebca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c7b8a0fdf82f087223f1a606b5992c"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#aa6c7b8a0fdf82f087223f1a606b5992c">__bitrev_b64</a> (uint64_t src0)[[hc]] __asm(&quot;llvm.bitreverse.i64&quot;)</td></tr>
<tr class="memdesc:aa6c7b8a0fdf82f087223f1a606b5992c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse the bits.  <a href="#aa6c7b8a0fdf82f087223f1a606b5992c">More...</a><br /></td></tr>
<tr class="separator:aa6c7b8a0fdf82f087223f1a606b5992c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a53b190f8e293c4991d3443910bb3c35d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a53b190f8e293c4991d3443910bb3c35d">__bitselect_b32</a> (unsigned int src0, unsigned int src1, unsigned int src2) __HC__</td></tr>
<tr class="memdesc:a53b190f8e293c4991d3443910bb3c35d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do bit field selection.  <a href="#a53b190f8e293c4991d3443910bb3c35d">More...</a><br /></td></tr>
<tr class="separator:a53b190f8e293c4991d3443910bb3c35d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156fe3e818d24651a33a659b5e61790d"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a156fe3e818d24651a33a659b5e61790d">__bitselect_b64</a> (uint64_t src0, uint64_t src1, uint64_t src2) __HC__</td></tr>
<tr class="memdesc:a156fe3e818d24651a33a659b5e61790d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do bit field selection.  <a href="#a156fe3e818d24651a33a659b5e61790d">More...</a><br /></td></tr>
<tr class="separator:a156fe3e818d24651a33a659b5e61790d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a53c79d41462733762d069c2504b268e0"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a53c79d41462733762d069c2504b268e0">__lastbit_u32_u32</a> (unsigned int input) __HC__</td></tr>
<tr class="memdesc:a53c79d41462733762d069c2504b268e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first bit set to 1 in a number starting from the least significant bit.  <a href="#a53c79d41462733762d069c2504b268e0">More...</a><br /></td></tr>
<tr class="separator:a53c79d41462733762d069c2504b268e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc37037b1bc07f391d8255ac2e44cb7e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#adc37037b1bc07f391d8255ac2e44cb7e">__lastbit_u32_u64</a> (unsigned long long int input) __HC__</td></tr>
<tr class="memdesc:adc37037b1bc07f391d8255ac2e44cb7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first bit set to 1 in a number starting from the least significant bit.  <a href="#adc37037b1bc07f391d8255ac2e44cb7e">More...</a><br /></td></tr>
<tr class="separator:adc37037b1bc07f391d8255ac2e44cb7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452a1c0f3cf4ae8e39daae6a53631c94"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a452a1c0f3cf4ae8e39daae6a53631c94">__lastbit_u32_s32</a> (int input) __HC__</td></tr>
<tr class="memdesc:a452a1c0f3cf4ae8e39daae6a53631c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first bit set to 1 in a number starting from the least significant bit.  <a href="#a452a1c0f3cf4ae8e39daae6a53631c94">More...</a><br /></td></tr>
<tr class="separator:a452a1c0f3cf4ae8e39daae6a53631c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72edf96f4a16e7a02c5463e9b2d11b7"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64</a> (unsigned long long input) __HC__</td></tr>
<tr class="memdesc:aa72edf96f4a16e7a02c5463e9b2d11b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first bit set to 1 in a number starting from the least significant bit.  <a href="#aa72edf96f4a16e7a02c5463e9b2d11b7">More...</a><br /></td></tr>
<tr class="separator:aa72edf96f4a16e7a02c5463e9b2d11b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1c352973da30d1e147c499519d1e6f82"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a1c352973da30d1e147c499519d1e6f82">__unpacklo_u8x4</a> (unsigned int src0, unsigned int src1) __HC__</td></tr>
<tr class="memdesc:a1c352973da30d1e147c499519d1e6f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy and interleave the lower half of the elements from each source into the desitionation.  <a href="#a1c352973da30d1e147c499519d1e6f82">More...</a><br /></td></tr>
<tr class="separator:a1c352973da30d1e147c499519d1e6f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3047ffa8f9223ec5a798462eb1b9a1"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a2b3047ffa8f9223ec5a798462eb1b9a1">__unpacklo_u8x8</a> (uint64_t src0, uint64_t src1) __HC__</td></tr>
<tr class="memdesc:a2b3047ffa8f9223ec5a798462eb1b9a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy and interleave the lower half of the elements from each source into the desitionation.  <a href="#a2b3047ffa8f9223ec5a798462eb1b9a1">More...</a><br /></td></tr>
<tr class="separator:a2b3047ffa8f9223ec5a798462eb1b9a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198ca447a0f8c664706332c5d6855ea9"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a198ca447a0f8c664706332c5d6855ea9">__unpacklo_u16x2</a> (unsigned int src0, unsigned int src1) __HC__</td></tr>
<tr class="memdesc:a198ca447a0f8c664706332c5d6855ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy and interleave the lower half of the elements from each source into the desitionation.  <a href="#a198ca447a0f8c664706332c5d6855ea9">More...</a><br /></td></tr>
<tr class="separator:a198ca447a0f8c664706332c5d6855ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1ffe2751b1462b5dc4d7814f718f8b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#aba1ffe2751b1462b5dc4d7814f718f8b">__unpacklo_u16x4</a> (uint64_t src0, uint64_t src1) __HC__</td></tr>
<tr class="memdesc:aba1ffe2751b1462b5dc4d7814f718f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy and interleave the lower half of the elements from each source into the desitionation.  <a href="#aba1ffe2751b1462b5dc4d7814f718f8b">More...</a><br /></td></tr>
<tr class="separator:aba1ffe2751b1462b5dc4d7814f718f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac115a01fcebfbc8cef346363a89f7807"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#ac115a01fcebfbc8cef346363a89f7807">__unpacklo_u32x2</a> (uint64_t src0, uint64_t src1) __HC__</td></tr>
<tr class="memdesc:ac115a01fcebfbc8cef346363a89f7807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy and interleave the lower half of the elements from each source into the desitionation.  <a href="#ac115a01fcebfbc8cef346363a89f7807">More...</a><br /></td></tr>
<tr class="separator:ac115a01fcebfbc8cef346363a89f7807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7c8cda5a28d0c9bf32308b07d25431"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a1b7c8cda5a28d0c9bf32308b07d25431">__unpacklo_s8x4</a> (int src0, int src1) __HC__</td></tr>
<tr class="memdesc:a1b7c8cda5a28d0c9bf32308b07d25431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy and interleave the lower half of the elements from each source into the desitionation.  <a href="#a1b7c8cda5a28d0c9bf32308b07d25431">More...</a><br /></td></tr>
<tr class="separator:a1b7c8cda5a28d0c9bf32308b07d25431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6eeec8da4ad7af7775dca688aa3a5b"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#afc6eeec8da4ad7af7775dca688aa3a5b">__unpacklo_s8x8</a> (int64_t src0, int64_t src1) __HC__</td></tr>
<tr class="memdesc:afc6eeec8da4ad7af7775dca688aa3a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy and interleave the lower half of the elements from each source into the desitionation.  <a href="#afc6eeec8da4ad7af7775dca688aa3a5b">More...</a><br /></td></tr>
<tr class="separator:afc6eeec8da4ad7af7775dca688aa3a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2fc5d4b019ca1b2058971d21998972"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a1b2fc5d4b019ca1b2058971d21998972">__unpacklo_s16x2</a> (int src0, int src1) __HC__</td></tr>
<tr class="memdesc:a1b2fc5d4b019ca1b2058971d21998972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy and interleave the lower half of the elements from each source into the desitionation.  <a href="#a1b2fc5d4b019ca1b2058971d21998972">More...</a><br /></td></tr>
<tr class="separator:a1b2fc5d4b019ca1b2058971d21998972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e7134973ebb73059739023a9c040a3"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a81e7134973ebb73059739023a9c040a3">__unpacklo_s16x4</a> (int64_t src0, int64_t src1) __HC__</td></tr>
<tr class="memdesc:a81e7134973ebb73059739023a9c040a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy and interleave the lower half of the elements from each source into the desitionation.  <a href="#a81e7134973ebb73059739023a9c040a3">More...</a><br /></td></tr>
<tr class="separator:a81e7134973ebb73059739023a9c040a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524d7a4aa0c87bf1d32d61780394a73b"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a524d7a4aa0c87bf1d32d61780394a73b">__unpacklo_s32x2</a> (int64_t src0, int64_t src1) __HC__</td></tr>
<tr class="memdesc:a524d7a4aa0c87bf1d32d61780394a73b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy and interleave the lower half of the elements from each source into the desitionation.  <a href="#a524d7a4aa0c87bf1d32d61780394a73b">More...</a><br /></td></tr>
<tr class="separator:a524d7a4aa0c87bf1d32d61780394a73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3d76bf79cfeec4b886e5e7827bc979dc"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a3d76bf79cfeec4b886e5e7827bc979dc">__unpackhi_u8x4</a> (unsigned int src0, unsigned int src1) __HC__</td></tr>
<tr class="memdesc:a3d76bf79cfeec4b886e5e7827bc979dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy and interleave the upper half of the elements from each source into the desitionation.  <a href="#a3d76bf79cfeec4b886e5e7827bc979dc">More...</a><br /></td></tr>
<tr class="separator:a3d76bf79cfeec4b886e5e7827bc979dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1846a4d2c7867799368ad136fcae43c3"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a1846a4d2c7867799368ad136fcae43c3">__unpackhi_u8x8</a> (uint64_t src0, uint64_t src1) __HC__</td></tr>
<tr class="memdesc:a1846a4d2c7867799368ad136fcae43c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy and interleave the upper half of the elements from each source into the desitionation.  <a href="#a1846a4d2c7867799368ad136fcae43c3">More...</a><br /></td></tr>
<tr class="separator:a1846a4d2c7867799368ad136fcae43c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922cf3fff83656b785769e349c178960"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a922cf3fff83656b785769e349c178960">__unpackhi_u16x2</a> (unsigned int src0, unsigned int src1) __HC__</td></tr>
<tr class="memdesc:a922cf3fff83656b785769e349c178960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy and interleave the upper half of the elements from each source into the desitionation.  <a href="#a922cf3fff83656b785769e349c178960">More...</a><br /></td></tr>
<tr class="separator:a922cf3fff83656b785769e349c178960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38241ba7a0072f08e4e6a35edeec8242"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a38241ba7a0072f08e4e6a35edeec8242">__unpackhi_u16x4</a> (uint64_t src0, uint64_t src1) __HC__</td></tr>
<tr class="memdesc:a38241ba7a0072f08e4e6a35edeec8242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy and interleave the upper half of the elements from each source into the desitionation.  <a href="#a38241ba7a0072f08e4e6a35edeec8242">More...</a><br /></td></tr>
<tr class="separator:a38241ba7a0072f08e4e6a35edeec8242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9405bd932d73b6cec17f2dafb03fe0"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a0b9405bd932d73b6cec17f2dafb03fe0">__unpackhi_u32x2</a> (uint64_t src0, uint64_t src1) __HC__</td></tr>
<tr class="memdesc:a0b9405bd932d73b6cec17f2dafb03fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy and interleave the upper half of the elements from each source into the desitionation.  <a href="#a0b9405bd932d73b6cec17f2dafb03fe0">More...</a><br /></td></tr>
<tr class="separator:a0b9405bd932d73b6cec17f2dafb03fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c213e05d1139301491527f5eb4d5de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#ac6c213e05d1139301491527f5eb4d5de">__unpackhi_s8x4</a> (int src0, int src1) __HC__</td></tr>
<tr class="memdesc:ac6c213e05d1139301491527f5eb4d5de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy and interleave the upper half of the elements from each source into the desitionation.  <a href="#ac6c213e05d1139301491527f5eb4d5de">More...</a><br /></td></tr>
<tr class="separator:ac6c213e05d1139301491527f5eb4d5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1d7b458e0641d8ec408aa7cc56eb8e"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a7d1d7b458e0641d8ec408aa7cc56eb8e">__unpackhi_s8x8</a> (int64_t src0, int64_t src1) __HC__</td></tr>
<tr class="memdesc:a7d1d7b458e0641d8ec408aa7cc56eb8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy and interleave the upper half of the elements from each source into the desitionation.  <a href="#a7d1d7b458e0641d8ec408aa7cc56eb8e">More...</a><br /></td></tr>
<tr class="separator:a7d1d7b458e0641d8ec408aa7cc56eb8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9aa819cac89ce8e050498b6b7d871a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#ac9aa819cac89ce8e050498b6b7d871a1">__unpackhi_s16x2</a> (int src0, int src1) __HC__</td></tr>
<tr class="memdesc:ac9aa819cac89ce8e050498b6b7d871a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy and interleave the upper half of the elements from each source into the desitionation.  <a href="#ac9aa819cac89ce8e050498b6b7d871a1">More...</a><br /></td></tr>
<tr class="separator:ac9aa819cac89ce8e050498b6b7d871a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe971dbc1279815910e3f8a7296e04b"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a3fe971dbc1279815910e3f8a7296e04b">__unpackhi_s16x4</a> (int64_t src0, int64_t src1) __HC__</td></tr>
<tr class="memdesc:a3fe971dbc1279815910e3f8a7296e04b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy and interleave the upper half of the elements from each source into the desitionation.  <a href="#a3fe971dbc1279815910e3f8a7296e04b">More...</a><br /></td></tr>
<tr class="separator:a3fe971dbc1279815910e3f8a7296e04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28c8309f3cc71369839b06d43dfe9d6"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#ad28c8309f3cc71369839b06d43dfe9d6">__unpackhi_s32x2</a> (int64_t src0, int64_t src1) __HC__</td></tr>
<tr class="memdesc:ad28c8309f3cc71369839b06d43dfe9d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy and interleave the upper half of the elements from each source into the desitionation.  <a href="#ad28c8309f3cc71369839b06d43dfe9d6">More...</a><br /></td></tr>
<tr class="separator:ad28c8309f3cc71369839b06d43dfe9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6e1faff89347656244ec48d999fbc69e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a6e1faff89347656244ec48d999fbc69e">__pack_u8x4_u32</a> (unsigned int src0, unsigned int src1, unsigned int src2) __HC__</td></tr>
<tr class="memdesc:a6e1faff89347656244ec48d999fbc69e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the elements of the packed value in src0, replacing the element specified by src2 with the value from src1.  <a href="#a6e1faff89347656244ec48d999fbc69e">More...</a><br /></td></tr>
<tr class="separator:a6e1faff89347656244ec48d999fbc69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62656c02cc32a8a7ae6ac5345f233bbe"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a62656c02cc32a8a7ae6ac5345f233bbe">__pack_u8x8_u32</a> (uint64_t src0, unsigned int src1, unsigned int src2) __HC__</td></tr>
<tr class="memdesc:a62656c02cc32a8a7ae6ac5345f233bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the elements of the packed value in src0, replacing the element specified by src2 with the value from src1.  <a href="#a62656c02cc32a8a7ae6ac5345f233bbe">More...</a><br /></td></tr>
<tr class="separator:a62656c02cc32a8a7ae6ac5345f233bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3557c5dd4b9cfd7b5f03296ff73e5606"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a3557c5dd4b9cfd7b5f03296ff73e5606">__pack_u16x2_u32</a> (unsigned int src0, unsigned int src1, unsigned int src2) __HC__</td></tr>
<tr class="memdesc:a3557c5dd4b9cfd7b5f03296ff73e5606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the elements of the packed value in src0, replacing the element specified by src2 with the value from src1.  <a href="#a3557c5dd4b9cfd7b5f03296ff73e5606">More...</a><br /></td></tr>
<tr class="separator:a3557c5dd4b9cfd7b5f03296ff73e5606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa102308ba50dc87f1923a47b8d5b89"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#acaa102308ba50dc87f1923a47b8d5b89">__pack_u16x4_u32</a> (uint64_t src0, unsigned int src1, unsigned int src2) __HC__</td></tr>
<tr class="memdesc:acaa102308ba50dc87f1923a47b8d5b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the elements of the packed value in src0, replacing the element specified by src2 with the value from src1.  <a href="#acaa102308ba50dc87f1923a47b8d5b89">More...</a><br /></td></tr>
<tr class="separator:acaa102308ba50dc87f1923a47b8d5b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ee0dd4d3b076079efe964561f6df2f"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#aa8ee0dd4d3b076079efe964561f6df2f">__pack_u32x2_u32</a> (uint64_t src0, unsigned int src1, unsigned int src2) __HC__</td></tr>
<tr class="memdesc:aa8ee0dd4d3b076079efe964561f6df2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the elements of the packed value in src0, replacing the element specified by src2 with the value from src1.  <a href="#aa8ee0dd4d3b076079efe964561f6df2f">More...</a><br /></td></tr>
<tr class="separator:aa8ee0dd4d3b076079efe964561f6df2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fc627085fdf04e35363ec4c1cd870f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#ae2fc627085fdf04e35363ec4c1cd870f">__pack_s8x4_s32</a> (int src0, int src1, unsigned int src2) __HC__</td></tr>
<tr class="memdesc:ae2fc627085fdf04e35363ec4c1cd870f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the elements of the packed value in src0, replacing the element specified by src2 with the value from src1.  <a href="#ae2fc627085fdf04e35363ec4c1cd870f">More...</a><br /></td></tr>
<tr class="separator:ae2fc627085fdf04e35363ec4c1cd870f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a3f6de4a4582ddeb2d084b13414b9b"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a08a3f6de4a4582ddeb2d084b13414b9b">__pack_s8x8_s32</a> (int64_t src0, int src1, unsigned int src2) __HC__</td></tr>
<tr class="memdesc:a08a3f6de4a4582ddeb2d084b13414b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the elements of the packed value in src0, replacing the element specified by src2 with the value from src1.  <a href="#a08a3f6de4a4582ddeb2d084b13414b9b">More...</a><br /></td></tr>
<tr class="separator:a08a3f6de4a4582ddeb2d084b13414b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d11f5bd959c92354da6bbedb835e621"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a0d11f5bd959c92354da6bbedb835e621">__pack_s16x2_s32</a> (int src0, int src1, unsigned int src2) __HC__</td></tr>
<tr class="memdesc:a0d11f5bd959c92354da6bbedb835e621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the elements of the packed value in src0, replacing the element specified by src2 with the value from src1.  <a href="#a0d11f5bd959c92354da6bbedb835e621">More...</a><br /></td></tr>
<tr class="separator:a0d11f5bd959c92354da6bbedb835e621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c9a7ae8cea0d921b7dee18a94370cc"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a75c9a7ae8cea0d921b7dee18a94370cc">__pack_s16x4_s32</a> (int64_t src0, int src1, unsigned int src2) __HC__</td></tr>
<tr class="memdesc:a75c9a7ae8cea0d921b7dee18a94370cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the elements of the packed value in src0, replacing the element specified by src2 with the value from src1.  <a href="#a75c9a7ae8cea0d921b7dee18a94370cc">More...</a><br /></td></tr>
<tr class="separator:a75c9a7ae8cea0d921b7dee18a94370cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0671c523932e4c1bca5d54e94e5d84d"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#aa0671c523932e4c1bca5d54e94e5d84d">__pack_s32x2_s32</a> (int64_t src0, int src1, unsigned int src2) __HC__</td></tr>
<tr class="memdesc:aa0671c523932e4c1bca5d54e94e5d84d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the elements of the packed value in src0, replacing the element specified by src2 with the value from src1.  <a href="#aa0671c523932e4c1bca5d54e94e5d84d">More...</a><br /></td></tr>
<tr class="separator:aa0671c523932e4c1bca5d54e94e5d84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72a1a20e16f9b4431e6204f817b5523"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#af72a1a20e16f9b4431e6204f817b5523">__pack_f32x2_f32</a> (double src0, float src1, unsigned int src2) __HC__</td></tr>
<tr class="memdesc:af72a1a20e16f9b4431e6204f817b5523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the elements of the packed value in src0, replacing the element specified by src2 with the value from src1.  <a href="#af72a1a20e16f9b4431e6204f817b5523">More...</a><br /></td></tr>
<tr class="separator:af72a1a20e16f9b4431e6204f817b5523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa89504c0311e6ccc0af7bd5998b99b1a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#aa89504c0311e6ccc0af7bd5998b99b1a">__unpack_u32_u8x4</a> (unsigned int src0, unsigned int src1) __HC__</td></tr>
<tr class="memdesc:aa89504c0311e6ccc0af7bd5998b99b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the elements specified by src1 from the packed value in src0.  <a href="#aa89504c0311e6ccc0af7bd5998b99b1a">More...</a><br /></td></tr>
<tr class="separator:aa89504c0311e6ccc0af7bd5998b99b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae064e8de38365d170b75ca2b5c91630"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#aae064e8de38365d170b75ca2b5c91630">__unpack_u32_u8x8</a> (uint64_t src0, unsigned int src1) __HC__</td></tr>
<tr class="memdesc:aae064e8de38365d170b75ca2b5c91630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the elements specified by src1 from the packed value in src0.  <a href="#aae064e8de38365d170b75ca2b5c91630">More...</a><br /></td></tr>
<tr class="separator:aae064e8de38365d170b75ca2b5c91630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38f5dc8bcae5ad6aa8822a898d684cd"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#ad38f5dc8bcae5ad6aa8822a898d684cd">__unpack_u32_u16x2</a> (unsigned int src0, unsigned int src1) __HC__</td></tr>
<tr class="memdesc:ad38f5dc8bcae5ad6aa8822a898d684cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the elements specified by src1 from the packed value in src0.  <a href="#ad38f5dc8bcae5ad6aa8822a898d684cd">More...</a><br /></td></tr>
<tr class="separator:ad38f5dc8bcae5ad6aa8822a898d684cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab936a88a2ee5095d2726124b5abf9e0c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#ab936a88a2ee5095d2726124b5abf9e0c">__unpack_u32_u16x4</a> (uint64_t src0, unsigned int src1) __HC__</td></tr>
<tr class="memdesc:ab936a88a2ee5095d2726124b5abf9e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the elements specified by src1 from the packed value in src0.  <a href="#ab936a88a2ee5095d2726124b5abf9e0c">More...</a><br /></td></tr>
<tr class="separator:ab936a88a2ee5095d2726124b5abf9e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3291dae53730b38e155469772499893a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a3291dae53730b38e155469772499893a">__unpack_u32_u32x2</a> (uint64_t src0, unsigned int src1) __HC__</td></tr>
<tr class="memdesc:a3291dae53730b38e155469772499893a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the elements specified by src1 from the packed value in src0.  <a href="#a3291dae53730b38e155469772499893a">More...</a><br /></td></tr>
<tr class="separator:a3291dae53730b38e155469772499893a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4e769cca3f7b9ccbf14af2415d0e7e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a9f4e769cca3f7b9ccbf14af2415d0e7e">__unpack_s32_s8x4</a> (int src0, unsigned int src1) __HC__</td></tr>
<tr class="memdesc:a9f4e769cca3f7b9ccbf14af2415d0e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the elements specified by src1 from the packed value in src0.  <a href="#a9f4e769cca3f7b9ccbf14af2415d0e7e">More...</a><br /></td></tr>
<tr class="separator:a9f4e769cca3f7b9ccbf14af2415d0e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37818d9eaf45ecfd6068ce58518179ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a37818d9eaf45ecfd6068ce58518179ad">__unpack_s32_s8x8</a> (int64_t src0, unsigned int src1) __HC__</td></tr>
<tr class="memdesc:a37818d9eaf45ecfd6068ce58518179ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the elements specified by src1 from the packed value in src0.  <a href="#a37818d9eaf45ecfd6068ce58518179ad">More...</a><br /></td></tr>
<tr class="separator:a37818d9eaf45ecfd6068ce58518179ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08889e4ea03eca5f8f1a0f83973da032"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a08889e4ea03eca5f8f1a0f83973da032">__unpack_s32_s16x2</a> (int src0, unsigned int src1) __HC__</td></tr>
<tr class="memdesc:a08889e4ea03eca5f8f1a0f83973da032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the elements specified by src1 from the packed value in src0.  <a href="#a08889e4ea03eca5f8f1a0f83973da032">More...</a><br /></td></tr>
<tr class="separator:a08889e4ea03eca5f8f1a0f83973da032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bcd498c879dc731c3d1696c10c1f5d2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a8bcd498c879dc731c3d1696c10c1f5d2">__unpack_s32_s16x4</a> (int64_t src0, unsigned int src1) __HC__</td></tr>
<tr class="memdesc:a8bcd498c879dc731c3d1696c10c1f5d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the elements specified by src1 from the packed value in src0.  <a href="#a8bcd498c879dc731c3d1696c10c1f5d2">More...</a><br /></td></tr>
<tr class="separator:a8bcd498c879dc731c3d1696c10c1f5d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd5f399232544c74be95df91c8bbc84"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a4dd5f399232544c74be95df91c8bbc84">__unpack_s32_s3x2</a> (int64_t src0, unsigned int src1) __HC__</td></tr>
<tr class="memdesc:a4dd5f399232544c74be95df91c8bbc84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the elements specified by src1 from the packed value in src0.  <a href="#a4dd5f399232544c74be95df91c8bbc84">More...</a><br /></td></tr>
<tr class="separator:a4dd5f399232544c74be95df91c8bbc84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98052b106b6eea9667cd19b7e9bb71f4"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a98052b106b6eea9667cd19b7e9bb71f4">__unpack_f32_f32x2</a> (double src0, unsigned int src1) __HC__</td></tr>
<tr class="memdesc:a98052b106b6eea9667cd19b7e9bb71f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the elements specified by src1 from the packed value in src0.  <a href="#a98052b106b6eea9667cd19b7e9bb71f4">More...</a><br /></td></tr>
<tr class="separator:a98052b106b6eea9667cd19b7e9bb71f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0fe54df1c124d07a3fcef8eac770d61f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a0fe54df1c124d07a3fcef8eac770d61f">__sad_u32_u32</a> (unsigned int src0, unsigned int src1, unsigned int src2) __HC__</td></tr>
<tr class="memdesc:a0fe54df1c124d07a3fcef8eac770d61f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of the absolute differences of src0 and src1 and then adds src2 to the result.  <a href="#a0fe54df1c124d07a3fcef8eac770d61f">More...</a><br /></td></tr>
<tr class="separator:a0fe54df1c124d07a3fcef8eac770d61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a097611f2a6b2a9101010d20477a93266"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a097611f2a6b2a9101010d20477a93266">__sad_u32_u16x2</a> (unsigned int src0, unsigned int src1, unsigned int src2) __HC__</td></tr>
<tr class="memdesc:a097611f2a6b2a9101010d20477a93266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of the absolute differences of src0 and src1 and then adds src2 to the result.  <a href="#a097611f2a6b2a9101010d20477a93266">More...</a><br /></td></tr>
<tr class="separator:a097611f2a6b2a9101010d20477a93266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b7a2c676f36a9a11fe95adc26b6839"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a91b7a2c676f36a9a11fe95adc26b6839">__sad_u32_u8x4</a> (unsigned int src0, unsigned int src1, unsigned int src2) __HC__</td></tr>
<tr class="memdesc:a91b7a2c676f36a9a11fe95adc26b6839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of the absolute differences of src0 and src1 and then adds src2 to the result.  <a href="#a91b7a2c676f36a9a11fe95adc26b6839">More...</a><br /></td></tr>
<tr class="separator:a91b7a2c676f36a9a11fe95adc26b6839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0e971454707e60ea8a4c614a8732c0b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a0e971454707e60ea8a4c614a8732c0b5">__amdgcn_mbcnt_lo</a> (int mask, int src)[[hc]] __asm(&quot;llvm.amdgcn.mbcnt.lo&quot;)</td></tr>
<tr class="memdesc:a0e971454707e60ea8a4c614a8732c0b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct copy from indexed active work-item within a wavefront.  <a href="#a0e971454707e60ea8a4c614a8732c0b5">More...</a><br /></td></tr>
<tr class="separator:a0e971454707e60ea8a4c614a8732c0b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6fdbd8ba6f37680e1a8144d06da3f2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#adb6fdbd8ba6f37680e1a8144d06da3f2">__amdgcn_mbcnt_hi</a> (int mask, int src)[[hc]] __asm(&quot;llvm.amdgcn.mbcnt.hi&quot;)</td></tr>
<tr class="memdesc:adb6fdbd8ba6f37680e1a8144d06da3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct copy from indexed active work-item within a wavefront.  <a href="#adb6fdbd8ba6f37680e1a8144d06da3f2">More...</a><br /></td></tr>
<tr class="separator:adb6fdbd8ba6f37680e1a8144d06da3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee86debe02dc57b1b597920e0a73a1c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a1ee86debe02dc57b1b597920e0a73a1c">__lane_id</a> (void)[[hc]]</td></tr>
<tr class="memdesc:a1ee86debe02dc57b1b597920e0a73a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct copy from indexed active work-item within a wavefront.  <a href="#a1ee86debe02dc57b1b597920e0a73a1c">More...</a><br /></td></tr>
<tr class="separator:a1ee86debe02dc57b1b597920e0a73a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ddc655165651347da37fd79de4c23c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7ddc655165651347da37fd79de4c23c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#ac7ddc655165651347da37fd79de4c23c">__amdgcn_ds_bpermute</a> (int <a class="el" href="namespacehc.html#a76d71e557b828b0789b178426021e066">index</a>, int src)[[hc]] __asm(&quot;llvm.amdgcn.ds.bpermute&quot;)</td></tr>
<tr class="memdesc:ac7ddc655165651347da37fd79de4c23c"><td class="mdescLeft">&#160;</td><td class="mdescRight">ds_bpermute intrinsic FIXME: We need to add __builtin_amdgcn_ds_bpermute to clang and call it here instead. <br /></td></tr>
<tr class="separator:ac7ddc655165651347da37fd79de4c23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14ac2a59a38ec303a3d78c004469aff"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#ad14ac2a59a38ec303a3d78c004469aff">__amdgcn_ds_bpermute</a> (int <a class="el" href="namespacehc.html#a76d71e557b828b0789b178426021e066">index</a>, unsigned int src)[[hc]]</td></tr>
<tr class="memdesc:ad14ac2a59a38ec303a3d78c004469aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct copy from indexed active work-item within a wavefront.  <a href="#ad14ac2a59a38ec303a3d78c004469aff">More...</a><br /></td></tr>
<tr class="separator:ad14ac2a59a38ec303a3d78c004469aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7bd617cc88bef0ebd0a115e98f6a47e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#ae7bd617cc88bef0ebd0a115e98f6a47e">__amdgcn_ds_bpermute</a> (int <a class="el" href="namespacehc.html#a76d71e557b828b0789b178426021e066">index</a>, float src)[[hc]]</td></tr>
<tr class="memdesc:ae7bd617cc88bef0ebd0a115e98f6a47e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct copy from indexed active work-item within a wavefront.  <a href="#ae7bd617cc88bef0ebd0a115e98f6a47e">More...</a><br /></td></tr>
<tr class="separator:ae7bd617cc88bef0ebd0a115e98f6a47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa49963079383b75dd6c28d7f97cd22d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa49963079383b75dd6c28d7f97cd22d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#aaa49963079383b75dd6c28d7f97cd22d">__amdgcn_ds_permute</a> (int <a class="el" href="namespacehc.html#a76d71e557b828b0789b178426021e066">index</a>, int src)[[hc]]</td></tr>
<tr class="memdesc:aaa49963079383b75dd6c28d7f97cd22d"><td class="mdescLeft">&#160;</td><td class="mdescRight">ds_permute intrinsic <br /></td></tr>
<tr class="separator:aaa49963079383b75dd6c28d7f97cd22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e4a5c411cc90ab684ff62811e4748b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a54e4a5c411cc90ab684ff62811e4748b">__amdgcn_ds_permute</a> (int <a class="el" href="namespacehc.html#a76d71e557b828b0789b178426021e066">index</a>, unsigned int src)[[hc]]</td></tr>
<tr class="memdesc:a54e4a5c411cc90ab684ff62811e4748b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct copy from indexed active work-item within a wavefront.  <a href="#a54e4a5c411cc90ab684ff62811e4748b">More...</a><br /></td></tr>
<tr class="separator:a54e4a5c411cc90ab684ff62811e4748b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c99fa3bfc68ba5588181bd296b8329"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a58c99fa3bfc68ba5588181bd296b8329">__amdgcn_ds_permute</a> (int <a class="el" href="namespacehc.html#a76d71e557b828b0789b178426021e066">index</a>, float src)[[hc]]</td></tr>
<tr class="memdesc:a58c99fa3bfc68ba5588181bd296b8329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct copy from indexed active work-item within a wavefront.  <a href="#a58c99fa3bfc68ba5588181bd296b8329">More...</a><br /></td></tr>
<tr class="separator:a58c99fa3bfc68ba5588181bd296b8329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87bde0d7afd28fbdb88fb4b34a495fe2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87bde0d7afd28fbdb88fb4b34a495fe2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a87bde0d7afd28fbdb88fb4b34a495fe2">__amdgcn_ds_swizzle</a> (int src, int pattern)[[hc]]</td></tr>
<tr class="memdesc:a87bde0d7afd28fbdb88fb4b34a495fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">ds_swizzle intrinsic <br /></td></tr>
<tr class="separator:a87bde0d7afd28fbdb88fb4b34a495fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64ad7ba3b07ad2e47fa529b01264f9b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#ab64ad7ba3b07ad2e47fa529b01264f9b">__amdgcn_ds_swizzle</a> (unsigned int src, int pattern)[[hc]]</td></tr>
<tr class="memdesc:ab64ad7ba3b07ad2e47fa529b01264f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct copy from indexed active work-item within a wavefront.  <a href="#ab64ad7ba3b07ad2e47fa529b01264f9b">More...</a><br /></td></tr>
<tr class="separator:ab64ad7ba3b07ad2e47fa529b01264f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6de36b62e83bca03516bbe25c8c51c"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a7a6de36b62e83bca03516bbe25c8c51c">__amdgcn_ds_swizzle</a> (float src, int pattern)[[hc]]</td></tr>
<tr class="memdesc:a7a6de36b62e83bca03516bbe25c8c51c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct copy from indexed active work-item within a wavefront.  <a href="#a7a6de36b62e83bca03516bbe25c8c51c">More...</a><br /></td></tr>
<tr class="separator:a7a6de36b62e83bca03516bbe25c8c51c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84395cfc190228fd1f121c8b4e6a9386"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84395cfc190228fd1f121c8b4e6a9386"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a84395cfc190228fd1f121c8b4e6a9386">__amdgcn_move_dpp</a> (int src, int dpp_ctrl, int row_mask, int bank_mask, bool bound_ctrl)[[hc]]</td></tr>
<tr class="memdesc:a84395cfc190228fd1f121c8b4e6a9386"><td class="mdescLeft">&#160;</td><td class="mdescRight">move DPP intrinsic <br /></td></tr>
<tr class="separator:a84395cfc190228fd1f121c8b4e6a9386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6ddb7251cf1330068e49cf997b4354"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#ace6ddb7251cf1330068e49cf997b4354">__amdgcn_wave_sr1</a> (int src, bool bound_ctrl)[[hc]]</td></tr>
<tr class="memdesc:ace6ddb7251cf1330068e49cf997b4354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the value of src to the right by one thread within a wavefront.  <a href="#ace6ddb7251cf1330068e49cf997b4354">More...</a><br /></td></tr>
<tr class="separator:ace6ddb7251cf1330068e49cf997b4354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1faea6490dda1d240de723cae16cc645"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a1faea6490dda1d240de723cae16cc645">__amdgcn_wave_sr1</a> (unsigned int src, bool bound_ctrl)[[hc]]</td></tr>
<tr class="memdesc:a1faea6490dda1d240de723cae16cc645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct copy from indexed active work-item within a wavefront.  <a href="#a1faea6490dda1d240de723cae16cc645">More...</a><br /></td></tr>
<tr class="separator:a1faea6490dda1d240de723cae16cc645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4258da8730aa98d0996aaf67ba8b8094"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a4258da8730aa98d0996aaf67ba8b8094">__amdgcn_wave_sr1</a> (float src, bool bound_ctrl)[[hc]]</td></tr>
<tr class="memdesc:a4258da8730aa98d0996aaf67ba8b8094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct copy from indexed active work-item within a wavefront.  <a href="#a4258da8730aa98d0996aaf67ba8b8094">More...</a><br /></td></tr>
<tr class="separator:a4258da8730aa98d0996aaf67ba8b8094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31569f4de5723d39ace77f8f44beb7ca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a31569f4de5723d39ace77f8f44beb7ca">__amdgcn_wave_sl1</a> (int src, bool bound_ctrl)[[hc]]</td></tr>
<tr class="memdesc:a31569f4de5723d39ace77f8f44beb7ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the value of src to the left by one thread within a wavefront.  <a href="#a31569f4de5723d39ace77f8f44beb7ca">More...</a><br /></td></tr>
<tr class="separator:a31569f4de5723d39ace77f8f44beb7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe78d23ddade3786de560477a66badba"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#abe78d23ddade3786de560477a66badba">__amdgcn_wave_sl1</a> (unsigned int src, bool bound_ctrl)[[hc]]</td></tr>
<tr class="memdesc:abe78d23ddade3786de560477a66badba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct copy from indexed active work-item within a wavefront.  <a href="#abe78d23ddade3786de560477a66badba">More...</a><br /></td></tr>
<tr class="separator:abe78d23ddade3786de560477a66badba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5131be1cf78ab97dec3935e60385105"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#af5131be1cf78ab97dec3935e60385105">__amdgcn_wave_sl1</a> (float src, bool bound_ctrl)[[hc]]</td></tr>
<tr class="memdesc:af5131be1cf78ab97dec3935e60385105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct copy from indexed active work-item within a wavefront.  <a href="#af5131be1cf78ab97dec3935e60385105">More...</a><br /></td></tr>
<tr class="separator:af5131be1cf78ab97dec3935e60385105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4845fb0465b29b6be73ccec4314fe2fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a4845fb0465b29b6be73ccec4314fe2fe">__amdgcn_wave_rr1</a> (int src)[[hc]]</td></tr>
<tr class="memdesc:a4845fb0465b29b6be73ccec4314fe2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate the value of src to the right by one thread within a wavefront.  <a href="#a4845fb0465b29b6be73ccec4314fe2fe">More...</a><br /></td></tr>
<tr class="separator:a4845fb0465b29b6be73ccec4314fe2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea180d659e0b8a786fda300035da39e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a8ea180d659e0b8a786fda300035da39e">__amdgcn_wave_rr1</a> (unsigned int src)[[hc]]</td></tr>
<tr class="memdesc:a8ea180d659e0b8a786fda300035da39e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct copy from indexed active work-item within a wavefront.  <a href="#a8ea180d659e0b8a786fda300035da39e">More...</a><br /></td></tr>
<tr class="separator:a8ea180d659e0b8a786fda300035da39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e4d9243e55e60f23a758149486ecc9"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a82e4d9243e55e60f23a758149486ecc9">__amdgcn_wave_rr1</a> (float src)[[hc]]</td></tr>
<tr class="memdesc:a82e4d9243e55e60f23a758149486ecc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct copy from indexed active work-item within a wavefront.  <a href="#a82e4d9243e55e60f23a758149486ecc9">More...</a><br /></td></tr>
<tr class="separator:a82e4d9243e55e60f23a758149486ecc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393e4103ec7c4aa3ae845d62531fdd1e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a393e4103ec7c4aa3ae845d62531fdd1e">__amdgcn_wave_rl1</a> (int src)[[hc]]</td></tr>
<tr class="memdesc:a393e4103ec7c4aa3ae845d62531fdd1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate the value of src to the left by one thread within a wavefront.  <a href="#a393e4103ec7c4aa3ae845d62531fdd1e">More...</a><br /></td></tr>
<tr class="separator:a393e4103ec7c4aa3ae845d62531fdd1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a814af3a3ea80508a38bb2351fea5020b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a814af3a3ea80508a38bb2351fea5020b">__amdgcn_wave_rl1</a> (unsigned int src)[[hc]]</td></tr>
<tr class="memdesc:a814af3a3ea80508a38bb2351fea5020b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct copy from indexed active work-item within a wavefront.  <a href="#a814af3a3ea80508a38bb2351fea5020b">More...</a><br /></td></tr>
<tr class="separator:a814af3a3ea80508a38bb2351fea5020b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64970c36551c0a321a050b5855149348"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a64970c36551c0a321a050b5855149348">__amdgcn_wave_rl1</a> (float src)[[hc]]</td></tr>
<tr class="memdesc:a64970c36551c0a321a050b5855149348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct copy from indexed active work-item within a wavefront.  <a href="#a64970c36551c0a321a050b5855149348">More...</a><br /></td></tr>
<tr class="separator:a64970c36551c0a321a050b5855149348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4257770fdd620bc621f9776edd2b084"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#af4257770fdd620bc621f9776edd2b084">__shfl</a> (int var, int srcLane, int width=<a class="el" href="hc_8hpp.html#ab71c5e1746e89bffb56cfa5cd507ca24">__HSA_WAVEFRONT_SIZE__</a>) __HC__</td></tr>
<tr class="memdesc:af4257770fdd620bc621f9776edd2b084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct copy from indexed active work-item within a wavefront.  <a href="#af4257770fdd620bc621f9776edd2b084">More...</a><br /></td></tr>
<tr class="separator:af4257770fdd620bc621f9776edd2b084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5d4f77623cdc85dfadf5f428749ef7"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#abe5d4f77623cdc85dfadf5f428749ef7">__shfl</a> (unsigned int var, int srcLane, int width=<a class="el" href="hc_8hpp.html#ab71c5e1746e89bffb56cfa5cd507ca24">__HSA_WAVEFRONT_SIZE__</a>) __HC__</td></tr>
<tr class="memdesc:abe5d4f77623cdc85dfadf5f428749ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct copy from indexed active work-item within a wavefront.  <a href="#abe5d4f77623cdc85dfadf5f428749ef7">More...</a><br /></td></tr>
<tr class="separator:abe5d4f77623cdc85dfadf5f428749ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c07da4556093fc8d39ca28e233bd8b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a00c07da4556093fc8d39ca28e233bd8b">__shfl</a> (float var, int srcLane, int width=<a class="el" href="hc_8hpp.html#ab71c5e1746e89bffb56cfa5cd507ca24">__HSA_WAVEFRONT_SIZE__</a>) __HC__</td></tr>
<tr class="memdesc:a00c07da4556093fc8d39ca28e233bd8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct copy from indexed active work-item within a wavefront.  <a href="#a00c07da4556093fc8d39ca28e233bd8b">More...</a><br /></td></tr>
<tr class="separator:a00c07da4556093fc8d39ca28e233bd8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afb062a5f5d3ede692602a0317470ee51"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#afb062a5f5d3ede692602a0317470ee51">__shfl_up</a> (int var, const unsigned int delta, const int width=<a class="el" href="hc_8hpp.html#ab71c5e1746e89bffb56cfa5cd507ca24">__HSA_WAVEFRONT_SIZE__</a>) __HC__</td></tr>
<tr class="memdesc:afb062a5f5d3ede692602a0317470ee51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from an active work-item with lower ID relative to caller within a wavefront.  <a href="#afb062a5f5d3ede692602a0317470ee51">More...</a><br /></td></tr>
<tr class="separator:afb062a5f5d3ede692602a0317470ee51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0b282a4db453d0d3312b851f004889"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#aca0b282a4db453d0d3312b851f004889">__shfl_up</a> (unsigned int var, const unsigned int delta, const int width=<a class="el" href="hc_8hpp.html#ab71c5e1746e89bffb56cfa5cd507ca24">__HSA_WAVEFRONT_SIZE__</a>) __HC__</td></tr>
<tr class="memdesc:aca0b282a4db453d0d3312b851f004889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from an active work-item with lower ID relative to caller within a wavefront.  <a href="#aca0b282a4db453d0d3312b851f004889">More...</a><br /></td></tr>
<tr class="separator:aca0b282a4db453d0d3312b851f004889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36288c8c55dcc69769ec2f50713b61ea"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a36288c8c55dcc69769ec2f50713b61ea">__shfl_up</a> (float var, const unsigned int delta, const int width=<a class="el" href="hc_8hpp.html#ab71c5e1746e89bffb56cfa5cd507ca24">__HSA_WAVEFRONT_SIZE__</a>) __HC__</td></tr>
<tr class="memdesc:a36288c8c55dcc69769ec2f50713b61ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from an active work-item with lower ID relative to caller within a wavefront.  <a href="#a36288c8c55dcc69769ec2f50713b61ea">More...</a><br /></td></tr>
<tr class="separator:a36288c8c55dcc69769ec2f50713b61ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab2ba23c1a4fa1a5b223b26a87cc3b47e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#ab2ba23c1a4fa1a5b223b26a87cc3b47e">__shfl_down</a> (int var, const unsigned int delta, const int width=<a class="el" href="hc_8hpp.html#ab71c5e1746e89bffb56cfa5cd507ca24">__HSA_WAVEFRONT_SIZE__</a>) __HC__</td></tr>
<tr class="memdesc:ab2ba23c1a4fa1a5b223b26a87cc3b47e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from an active work-item with higher ID relative to caller within a wavefront.  <a href="#ab2ba23c1a4fa1a5b223b26a87cc3b47e">More...</a><br /></td></tr>
<tr class="separator:ab2ba23c1a4fa1a5b223b26a87cc3b47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12b5e4f903cb07d4cd8db915fe4e8d6"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#aa12b5e4f903cb07d4cd8db915fe4e8d6">__shfl_down</a> (unsigned int var, const unsigned int delta, const int width=<a class="el" href="hc_8hpp.html#ab71c5e1746e89bffb56cfa5cd507ca24">__HSA_WAVEFRONT_SIZE__</a>) __HC__</td></tr>
<tr class="memdesc:aa12b5e4f903cb07d4cd8db915fe4e8d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from an active work-item with higher ID relative to caller within a wavefront.  <a href="#aa12b5e4f903cb07d4cd8db915fe4e8d6">More...</a><br /></td></tr>
<tr class="separator:aa12b5e4f903cb07d4cd8db915fe4e8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b8c020c86085928c96cc3a56b24691"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#ac2b8c020c86085928c96cc3a56b24691">__shfl_down</a> (float var, const unsigned int delta, const int width=<a class="el" href="hc_8hpp.html#ab71c5e1746e89bffb56cfa5cd507ca24">__HSA_WAVEFRONT_SIZE__</a>) __HC__</td></tr>
<tr class="memdesc:ac2b8c020c86085928c96cc3a56b24691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from an active work-item with higher ID relative to caller within a wavefront.  <a href="#ac2b8c020c86085928c96cc3a56b24691">More...</a><br /></td></tr>
<tr class="separator:ac2b8c020c86085928c96cc3a56b24691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4d5476fe3a4689e1d8f4efb446f5b4ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a4d5476fe3a4689e1d8f4efb446f5b4ed">__shfl_xor</a> (int var, int laneMask, int width=<a class="el" href="hc_8hpp.html#ab71c5e1746e89bffb56cfa5cd507ca24">__HSA_WAVEFRONT_SIZE__</a>) __HC__</td></tr>
<tr class="memdesc:a4d5476fe3a4689e1d8f4efb446f5b4ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from an active work-item based on bitwise XOR of caller work-item ID within a wavefront.  <a href="#a4d5476fe3a4689e1d8f4efb446f5b4ed">More...</a><br /></td></tr>
<tr class="separator:a4d5476fe3a4689e1d8f4efb446f5b4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa554d33a2e4aa842ecbd254f42fb65f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#afa554d33a2e4aa842ecbd254f42fb65f">__shfl_xor</a> (float var, int laneMask, int width=<a class="el" href="hc_8hpp.html#ab71c5e1746e89bffb56cfa5cd507ca24">__HSA_WAVEFRONT_SIZE__</a>) __HC__</td></tr>
<tr class="memdesc:afa554d33a2e4aa842ecbd254f42fb65f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from an active work-item based on bitwise XOR of caller work-item ID within a wavefront.  <a href="#afa554d33a2e4aa842ecbd254f42fb65f">More...</a><br /></td></tr>
<tr class="separator:afa554d33a2e4aa842ecbd254f42fb65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa475300aad804b607f74f86de266a2b2"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:aa475300aad804b607f74f86de266a2b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#aa475300aad804b607f74f86de266a2b2">copy</a> (const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; const T, N &gt; &amp;src, const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:aa475300aad804b607f74f86de266a2b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#aa475300aad804b607f74f86de266a2b2">More...</a><br /></td></tr>
<tr class="separator:aa475300aad804b607f74f86de266a2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754f84098173418069020cd34da33be6"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:a754f84098173418069020cd34da33be6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#a754f84098173418069020cd34da33be6">copy</a> (const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;src, const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:a754f84098173418069020cd34da33be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#a754f84098173418069020cd34da33be6">More...</a><br /></td></tr>
<tr class="separator:a754f84098173418069020cd34da33be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b400529b72d0e9c26c4b9083e2d681"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a33b400529b72d0e9c26c4b9083e2d681"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#a33b400529b72d0e9c26c4b9083e2d681">copy</a> (const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; const T, 1 &gt; &amp;src, const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, 1 &gt; &amp;dest)</td></tr>
<tr class="memdesc:a33b400529b72d0e9c26c4b9083e2d681"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#a33b400529b72d0e9c26c4b9083e2d681">More...</a><br /></td></tr>
<tr class="separator:a33b400529b72d0e9c26c4b9083e2d681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3b37a30d5090d17acba67652635182ba"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:a3b37a30d5090d17acba67652635182ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#a3b37a30d5090d17acba67652635182ba">copy</a> (const <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;src, const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:a3b37a30d5090d17acba67652635182ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#a3b37a30d5090d17acba67652635182ba">More...</a><br /></td></tr>
<tr class="separator:a3b37a30d5090d17acba67652635182ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc44d4113d75572503077bb07ba08362"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abc44d4113d75572503077bb07ba08362"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#abc44d4113d75572503077bb07ba08362">copy</a> (const <a class="el" href="classhc_1_1array.html">array</a>&lt; T, 1 &gt; &amp;src, const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, 1 &gt; &amp;dest)</td></tr>
<tr class="memdesc:abc44d4113d75572503077bb07ba08362"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#abc44d4113d75572503077bb07ba08362">More...</a><br /></td></tr>
<tr class="separator:abc44d4113d75572503077bb07ba08362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a05652136ace69ed76a177983a1cdef45"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:a05652136ace69ed76a177983a1cdef45"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#a05652136ace69ed76a177983a1cdef45">copy</a> (const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; const T, N &gt; &amp;src, <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:a05652136ace69ed76a177983a1cdef45"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#a05652136ace69ed76a177983a1cdef45">More...</a><br /></td></tr>
<tr class="separator:a05652136ace69ed76a177983a1cdef45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89cd26765005205fa62a0f7f692f00fc"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:a89cd26765005205fa62a0f7f692f00fc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#a89cd26765005205fa62a0f7f692f00fc">copy</a> (const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;src, <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:a89cd26765005205fa62a0f7f692f00fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#a89cd26765005205fa62a0f7f692f00fc">More...</a><br /></td></tr>
<tr class="separator:a89cd26765005205fa62a0f7f692f00fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed609690ebe1915a9773d67e2d4862e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7ed609690ebe1915a9773d67e2d4862e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#a7ed609690ebe1915a9773d67e2d4862e">copy</a> (const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; const T, 1 &gt; &amp;src, <a class="el" href="classhc_1_1array.html">array</a>&lt; T, 1 &gt; &amp;dest)</td></tr>
<tr class="memdesc:a7ed609690ebe1915a9773d67e2d4862e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#a7ed609690ebe1915a9773d67e2d4862e">More...</a><br /></td></tr>
<tr class="separator:a7ed609690ebe1915a9773d67e2d4862e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aae5de40faeaa7e8737f0fc7c1a054c78"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:aae5de40faeaa7e8737f0fc7c1a054c78"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#aae5de40faeaa7e8737f0fc7c1a054c78">copy</a> (InputIter srcBegin, InputIter srcEnd, const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:aae5de40faeaa7e8737f0fc7c1a054c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest".  <a href="#aae5de40faeaa7e8737f0fc7c1a054c78">More...</a><br /></td></tr>
<tr class="separator:aae5de40faeaa7e8737f0fc7c1a054c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5da881f88351946b9c26e3485d278b"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:a9c5da881f88351946b9c26e3485d278b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#a9c5da881f88351946b9c26e3485d278b">copy</a> (InputIter srcBegin, const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:a9c5da881f88351946b9c26e3485d278b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest".  <a href="#a9c5da881f88351946b9c26e3485d278b">More...</a><br /></td></tr>
<tr class="separator:a9c5da881f88351946b9c26e3485d278b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6f8b9ccbe0fead355a79d4eb81d076ab"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:a6f8b9ccbe0fead355a79d4eb81d076ab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#a6f8b9ccbe0fead355a79d4eb81d076ab">copy</a> (InputIter srcBegin, InputIter srcEnd, <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:a6f8b9ccbe0fead355a79d4eb81d076ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest".  <a href="#a6f8b9ccbe0fead355a79d4eb81d076ab">More...</a><br /></td></tr>
<tr class="separator:a6f8b9ccbe0fead355a79d4eb81d076ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38b2c139229fdb0935fdb9b71a323a0"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:ae38b2c139229fdb0935fdb9b71a323a0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#ae38b2c139229fdb0935fdb9b71a323a0">copy</a> (InputIter srcBegin, <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:ae38b2c139229fdb0935fdb9b71a323a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest".  <a href="#ae38b2c139229fdb0935fdb9b71a323a0">More...</a><br /></td></tr>
<tr class="separator:ae38b2c139229fdb0935fdb9b71a323a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2cc6fbd8ba2c9341e800c124348566d1"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:a2cc6fbd8ba2c9341e800c124348566d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#a2cc6fbd8ba2c9341e800c124348566d1">copy_async</a> (const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; const T, N &gt; &amp;src, <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:a2cc6fbd8ba2c9341e800c124348566d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#a2cc6fbd8ba2c9341e800c124348566d1">More...</a><br /></td></tr>
<tr class="separator:a2cc6fbd8ba2c9341e800c124348566d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2ec164e3dfd5513688772498fc4e4e"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:a8c2ec164e3dfd5513688772498fc4e4e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#a8c2ec164e3dfd5513688772498fc4e4e">copy_async</a> (const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;src, <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:a8c2ec164e3dfd5513688772498fc4e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#a8c2ec164e3dfd5513688772498fc4e4e">More...</a><br /></td></tr>
<tr class="separator:a8c2ec164e3dfd5513688772498fc4e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0a9eee4d952b2e2ad6098686dea61619"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:a0a9eee4d952b2e2ad6098686dea61619"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#a0a9eee4d952b2e2ad6098686dea61619">copy_async</a> (const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; const T, N &gt; &amp;src, const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:a0a9eee4d952b2e2ad6098686dea61619"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#a0a9eee4d952b2e2ad6098686dea61619">More...</a><br /></td></tr>
<tr class="separator:a0a9eee4d952b2e2ad6098686dea61619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6846df06fc19ef5989afdd9cc683f514"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:a6846df06fc19ef5989afdd9cc683f514"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#a6846df06fc19ef5989afdd9cc683f514">copy_async</a> (const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;src, const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:a6846df06fc19ef5989afdd9cc683f514"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of "src" are copied into "dest".  <a href="#a6846df06fc19ef5989afdd9cc683f514">More...</a><br /></td></tr>
<tr class="separator:a6846df06fc19ef5989afdd9cc683f514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4c7f44927641a2cb0f3af03cbbb7bfc1"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:a4c7f44927641a2cb0f3af03cbbb7bfc1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#a4c7f44927641a2cb0f3af03cbbb7bfc1">copy_async</a> (InputIter srcBegin, InputIter srcEnd, <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:a4c7f44927641a2cb0f3af03cbbb7bfc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest".  <a href="#a4c7f44927641a2cb0f3af03cbbb7bfc1">More...</a><br /></td></tr>
<tr class="separator:a4c7f44927641a2cb0f3af03cbbb7bfc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f81bd4317a53fd880de223079561667"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:a1f81bd4317a53fd880de223079561667"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#a1f81bd4317a53fd880de223079561667">copy_async</a> (InputIter srcBegin, <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:a1f81bd4317a53fd880de223079561667"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest".  <a href="#a1f81bd4317a53fd880de223079561667">More...</a><br /></td></tr>
<tr class="separator:a1f81bd4317a53fd880de223079561667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abf01554001426ff112473a5e6843b454"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:abf01554001426ff112473a5e6843b454"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#abf01554001426ff112473a5e6843b454">copy_async</a> (InputIter srcBegin, InputIter srcEnd, const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:abf01554001426ff112473a5e6843b454"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest".  <a href="#abf01554001426ff112473a5e6843b454">More...</a><br /></td></tr>
<tr class="separator:abf01554001426ff112473a5e6843b454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa245b722b9ce411c62e781fb4a171de2"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename T , int N&gt; </td></tr>
<tr class="memitem:aa245b722b9ce411c62e781fb4a171de2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhc_1_1completion__future.html">completion_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehc.html#aa245b722b9ce411c62e781fb4a171de2">copy_async</a> (InputIter srcBegin, const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;dest)</td></tr>
<tr class="memdesc:aa245b722b9ce411c62e781fb4a171de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest".  <a href="#aa245b722b9ce411c62e781fb4a171de2">More...</a><br /></td></tr>
<tr class="separator:aa245b722b9ce411c62e781fb4a171de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab3b10c0076f2ec59ae99dbd532a2bc31"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#ab3b10c0076f2ec59ae99dbd532a2bc31">atomic_exchange</a> (unsigned int *dest, unsigned int val) __CPU__ __HC__</td></tr>
<tr class="memdesc:ab3b10c0076f2ec59ae99dbd532a2bc31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest , replace it with the value given in val and return the old value to the caller.  <a href="#ab3b10c0076f2ec59ae99dbd532a2bc31">More...</a><br /></td></tr>
<tr class="separator:ab3b10c0076f2ec59ae99dbd532a2bc31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbdad78734bea33c98f111e543932d00"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#adbdad78734bea33c98f111e543932d00">atomic_exchange</a> (int *dest, int val) __CPU__ __HC__</td></tr>
<tr class="memdesc:adbdad78734bea33c98f111e543932d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest , replace it with the value given in val and return the old value to the caller.  <a href="#adbdad78734bea33c98f111e543932d00">More...</a><br /></td></tr>
<tr class="separator:adbdad78734bea33c98f111e543932d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c28a7a010d35956ed009b7c1b39428c"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a4c28a7a010d35956ed009b7c1b39428c">atomic_exchange</a> (float *dest, float val) __CPU__ __HC__</td></tr>
<tr class="memdesc:a4c28a7a010d35956ed009b7c1b39428c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest , replace it with the value given in val and return the old value to the caller.  <a href="#a4c28a7a010d35956ed009b7c1b39428c">More...</a><br /></td></tr>
<tr class="separator:a4c28a7a010d35956ed009b7c1b39428c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815fe01bcd422a1308da8141a71b62fc"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a815fe01bcd422a1308da8141a71b62fc">atomic_exchange</a> (uint64_t *dest, uint64_t val) __CPU__ __HC__</td></tr>
<tr class="memdesc:a815fe01bcd422a1308da8141a71b62fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest , replace it with the value given in val and return the old value to the caller.  <a href="#a815fe01bcd422a1308da8141a71b62fc">More...</a><br /></td></tr>
<tr class="separator:a815fe01bcd422a1308da8141a71b62fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a144a13f65f39ce2970a2dbfdfaabbe28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a144a13f65f39ce2970a2dbfdfaabbe28">atomic_compare_exchange</a> (unsigned int *dest, unsigned int *expected_val, unsigned int val) __CPU__ __HC__</td></tr>
<tr class="memdesc:a144a13f65f39ce2970a2dbfdfaabbe28"><td class="mdescLeft">&#160;</td><td class="mdescRight">These functions attempt to perform these three steps atomically:  <a href="#a144a13f65f39ce2970a2dbfdfaabbe28">More...</a><br /></td></tr>
<tr class="separator:a144a13f65f39ce2970a2dbfdfaabbe28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94caf1e8bdd84fc1561b114d3b16edc3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a94caf1e8bdd84fc1561b114d3b16edc3">atomic_compare_exchange</a> (int *dest, int *expected_val, int val) __CPU__ __HC__</td></tr>
<tr class="memdesc:a94caf1e8bdd84fc1561b114d3b16edc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">These functions attempt to perform these three steps atomically:  <a href="#a94caf1e8bdd84fc1561b114d3b16edc3">More...</a><br /></td></tr>
<tr class="separator:a94caf1e8bdd84fc1561b114d3b16edc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf212d3d5c87ebcf8f76db5fdf52247e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#acf212d3d5c87ebcf8f76db5fdf52247e">atomic_compare_exchange</a> (uint64_t *dest, uint64_t *expected_val, uint64_t val) __CPU__ __HC__</td></tr>
<tr class="memdesc:acf212d3d5c87ebcf8f76db5fdf52247e"><td class="mdescLeft">&#160;</td><td class="mdescRight">These functions attempt to perform these three steps atomically:  <a href="#acf212d3d5c87ebcf8f76db5fdf52247e">More...</a><br /></td></tr>
<tr class="separator:acf212d3d5c87ebcf8f76db5fdf52247e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a274ea927e0ba3eb9521d34d0541c5e23"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a274ea927e0ba3eb9521d34d0541c5e23">atomic_fetch_add</a> (unsigned *x, unsigned y) __CPU__ __HC__</td></tr>
<tr class="memdesc:a274ea927e0ba3eb9521d34d0541c5e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#a274ea927e0ba3eb9521d34d0541c5e23">More...</a><br /></td></tr>
<tr class="separator:a274ea927e0ba3eb9521d34d0541c5e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabde5a5c761fca9180c68ff0b67581d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#aabde5a5c761fca9180c68ff0b67581d1">atomic_fetch_add</a> (int *x, int y) __CPU__ __HC__</td></tr>
<tr class="memdesc:aabde5a5c761fca9180c68ff0b67581d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#aabde5a5c761fca9180c68ff0b67581d1">More...</a><br /></td></tr>
<tr class="separator:aabde5a5c761fca9180c68ff0b67581d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fafe40b108fe9caeef41dc3ab48732"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a79fafe40b108fe9caeef41dc3ab48732">atomic_fetch_add</a> (float *x, float y) __CPU__ __HC__</td></tr>
<tr class="memdesc:a79fafe40b108fe9caeef41dc3ab48732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#a79fafe40b108fe9caeef41dc3ab48732">More...</a><br /></td></tr>
<tr class="separator:a79fafe40b108fe9caeef41dc3ab48732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7e8685fa0f0cf7e510f2f90c01a618"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#acb7e8685fa0f0cf7e510f2f90c01a618">atomic_fetch_add</a> (uint64_t *x, uint64_t y) __CPU__ __HC__</td></tr>
<tr class="memdesc:acb7e8685fa0f0cf7e510f2f90c01a618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#acb7e8685fa0f0cf7e510f2f90c01a618">More...</a><br /></td></tr>
<tr class="separator:acb7e8685fa0f0cf7e510f2f90c01a618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9dc4efa51d801fd5d9c057f654a94e"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#aed9dc4efa51d801fd5d9c057f654a94e">atomic_fetch_sub</a> (unsigned *x, unsigned y) __CPU__ __HC__</td></tr>
<tr class="memdesc:aed9dc4efa51d801fd5d9c057f654a94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#aed9dc4efa51d801fd5d9c057f654a94e">More...</a><br /></td></tr>
<tr class="separator:aed9dc4efa51d801fd5d9c057f654a94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33be363818e6509bf74a890f633a7ad1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a33be363818e6509bf74a890f633a7ad1">atomic_fetch_sub</a> (int *x, int y) __CPU__ __HC__</td></tr>
<tr class="memdesc:a33be363818e6509bf74a890f633a7ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#a33be363818e6509bf74a890f633a7ad1">More...</a><br /></td></tr>
<tr class="separator:a33be363818e6509bf74a890f633a7ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7764569f1dacdec25734280a3ca917"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#aff7764569f1dacdec25734280a3ca917">atomic_fetch_sub</a> (float *x, float y) __CPU__ __HC__</td></tr>
<tr class="memdesc:aff7764569f1dacdec25734280a3ca917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#aff7764569f1dacdec25734280a3ca917">More...</a><br /></td></tr>
<tr class="separator:aff7764569f1dacdec25734280a3ca917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb737efa9cd1dc6a87ff5655b854733b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#adb737efa9cd1dc6a87ff5655b854733b">atomic_fetch_and</a> (unsigned *x, unsigned y) __CPU__ __HC__</td></tr>
<tr class="memdesc:adb737efa9cd1dc6a87ff5655b854733b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#adb737efa9cd1dc6a87ff5655b854733b">More...</a><br /></td></tr>
<tr class="separator:adb737efa9cd1dc6a87ff5655b854733b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf091f060490c4b7b75b4989c5b2eb90"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#aaf091f060490c4b7b75b4989c5b2eb90">atomic_fetch_and</a> (int *x, int y) __CPU__ __HC__</td></tr>
<tr class="memdesc:aaf091f060490c4b7b75b4989c5b2eb90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#aaf091f060490c4b7b75b4989c5b2eb90">More...</a><br /></td></tr>
<tr class="separator:aaf091f060490c4b7b75b4989c5b2eb90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7fdf2ecbb55fb48868a674ea9280da"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a0a7fdf2ecbb55fb48868a674ea9280da">atomic_fetch_and</a> (uint64_t *x, uint64_t y) __CPU__ __HC__</td></tr>
<tr class="memdesc:a0a7fdf2ecbb55fb48868a674ea9280da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#a0a7fdf2ecbb55fb48868a674ea9280da">More...</a><br /></td></tr>
<tr class="separator:a0a7fdf2ecbb55fb48868a674ea9280da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b97170bf81283b8a7b5ea321ce3164"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a87b97170bf81283b8a7b5ea321ce3164">atomic_fetch_or</a> (unsigned *x, unsigned y) __CPU__ __HC__</td></tr>
<tr class="memdesc:a87b97170bf81283b8a7b5ea321ce3164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#a87b97170bf81283b8a7b5ea321ce3164">More...</a><br /></td></tr>
<tr class="separator:a87b97170bf81283b8a7b5ea321ce3164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977ffea3db3f8e01dffbb4449466db9c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a977ffea3db3f8e01dffbb4449466db9c">atomic_fetch_or</a> (int *x, int y) __CPU__ __HC__</td></tr>
<tr class="memdesc:a977ffea3db3f8e01dffbb4449466db9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#a977ffea3db3f8e01dffbb4449466db9c">More...</a><br /></td></tr>
<tr class="separator:a977ffea3db3f8e01dffbb4449466db9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06889dba9386dfc367eae859cb344374"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a06889dba9386dfc367eae859cb344374">atomic_fetch_or</a> (uint64_t *x, uint64_t y) __CPU__ __HC__</td></tr>
<tr class="memdesc:a06889dba9386dfc367eae859cb344374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#a06889dba9386dfc367eae859cb344374">More...</a><br /></td></tr>
<tr class="separator:a06889dba9386dfc367eae859cb344374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49819dea09766b5c352ba77e9e414351"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a49819dea09766b5c352ba77e9e414351">atomic_fetch_xor</a> (unsigned *x, unsigned y) __CPU__ __HC__</td></tr>
<tr class="memdesc:a49819dea09766b5c352ba77e9e414351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#a49819dea09766b5c352ba77e9e414351">More...</a><br /></td></tr>
<tr class="separator:a49819dea09766b5c352ba77e9e414351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd2a337d195d0e31ee4104cf89e36586"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#abd2a337d195d0e31ee4104cf89e36586">atomic_fetch_xor</a> (int *x, int y) __CPU__ __HC__</td></tr>
<tr class="memdesc:abd2a337d195d0e31ee4104cf89e36586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#abd2a337d195d0e31ee4104cf89e36586">More...</a><br /></td></tr>
<tr class="separator:abd2a337d195d0e31ee4104cf89e36586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048ff814e41a1bc4f4381d87df880d0f"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a048ff814e41a1bc4f4381d87df880d0f">atomic_fetch_xor</a> (uint64_t *x, uint64_t y) __CPU__ __HC__</td></tr>
<tr class="memdesc:a048ff814e41a1bc4f4381d87df880d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#a048ff814e41a1bc4f4381d87df880d0f">More...</a><br /></td></tr>
<tr class="separator:a048ff814e41a1bc4f4381d87df880d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c53a9bc13395910d0cfdf9fef0da8e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#ad2c53a9bc13395910d0cfdf9fef0da8e">atomic_fetch_max</a> (int *dest, int val) __CPU__ __HC__</td></tr>
<tr class="memdesc:ad2c53a9bc13395910d0cfdf9fef0da8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#ad2c53a9bc13395910d0cfdf9fef0da8e">More...</a><br /></td></tr>
<tr class="separator:ad2c53a9bc13395910d0cfdf9fef0da8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3281bc15a0ff64de897db8b0c6a147f8"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a3281bc15a0ff64de897db8b0c6a147f8">atomic_fetch_max</a> (unsigned int *dest, unsigned int val) __CPU__ __HC__</td></tr>
<tr class="memdesc:a3281bc15a0ff64de897db8b0c6a147f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#a3281bc15a0ff64de897db8b0c6a147f8">More...</a><br /></td></tr>
<tr class="separator:a3281bc15a0ff64de897db8b0c6a147f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34220f1ab2503aaace02ade8004334a"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#af34220f1ab2503aaace02ade8004334a">atomic_fetch_max</a> (uint64_t *dest, uint64_t val) __CPU__ __HC__</td></tr>
<tr class="memdesc:af34220f1ab2503aaace02ade8004334a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#af34220f1ab2503aaace02ade8004334a">More...</a><br /></td></tr>
<tr class="separator:af34220f1ab2503aaace02ade8004334a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4eb2bb27caa8f01c7a082da18a29d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#abd4eb2bb27caa8f01c7a082da18a29d6">atomic_fetch_min</a> (int *dest, int val) __CPU__ __HC__</td></tr>
<tr class="memdesc:abd4eb2bb27caa8f01c7a082da18a29d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#abd4eb2bb27caa8f01c7a082da18a29d6">More...</a><br /></td></tr>
<tr class="separator:abd4eb2bb27caa8f01c7a082da18a29d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf3e399f98b3572126cb7e3d2a6468a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a5bf3e399f98b3572126cb7e3d2a6468a">atomic_fetch_min</a> (unsigned int *dest, unsigned int val) __CPU__ __HC__</td></tr>
<tr class="memdesc:a5bf3e399f98b3572126cb7e3d2a6468a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#a5bf3e399f98b3572126cb7e3d2a6468a">More...</a><br /></td></tr>
<tr class="separator:a5bf3e399f98b3572126cb7e3d2a6468a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480e9a1dda252ce5065dde830b7307ca"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a480e9a1dda252ce5065dde830b7307ca">atomic_fetch_min</a> (uint64_t *dest, uint64_t val) __CPU__ __HC__</td></tr>
<tr class="memdesc:a480e9a1dda252ce5065dde830b7307ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest.  <a href="#a480e9a1dda252ce5065dde830b7307ca">More...</a><br /></td></tr>
<tr class="separator:a480e9a1dda252ce5065dde830b7307ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a259d458ddd17fead0d7f045c7f263ed7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a259d458ddd17fead0d7f045c7f263ed7">atomic_fetch_inc</a> (int *_Dest) __CPU__ __HC__</td></tr>
<tr class="memdesc:a259d458ddd17fead0d7f045c7f263ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically increment or decrement the value stored at the location point to by dest.  <a href="#a259d458ddd17fead0d7f045c7f263ed7">More...</a><br /></td></tr>
<tr class="separator:a259d458ddd17fead0d7f045c7f263ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ff2db87bcd5d43a44b8f424fb9d9c9"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#af1ff2db87bcd5d43a44b8f424fb9d9c9">atomic_fetch_inc</a> (unsigned int *_Dest) __CPU__ __HC__</td></tr>
<tr class="memdesc:af1ff2db87bcd5d43a44b8f424fb9d9c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically increment or decrement the value stored at the location point to by dest.  <a href="#af1ff2db87bcd5d43a44b8f424fb9d9c9">More...</a><br /></td></tr>
<tr class="separator:af1ff2db87bcd5d43a44b8f424fb9d9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d570ab3c664db5060363371c026363"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#a25d570ab3c664db5060363371c026363">atomic_fetch_dec</a> (int *_Dest) __CPU__ __HC__</td></tr>
<tr class="memdesc:a25d570ab3c664db5060363371c026363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically increment or decrement the value stored at the location point to by dest.  <a href="#a25d570ab3c664db5060363371c026363">More...</a><br /></td></tr>
<tr class="separator:a25d570ab3c664db5060363371c026363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6cf3f5c4655e0bcf79cbf6165d9387c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehc.html#ae6cf3f5c4655e0bcf79cbf6165d9387c">atomic_fetch_dec</a> (unsigned int *_Dest) __CPU__ __HC__</td></tr>
<tr class="memdesc:ae6cf3f5c4655e0bcf79cbf6165d9387c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically increment or decrement the value stored at the location point to by dest.  <a href="#ae6cf3f5c4655e0bcf79cbf6165d9387c">More...</a><br /></td></tr>
<tr class="separator:ae6cf3f5c4655e0bcf79cbf6165d9387c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad00af07a907ddc2de2941981340ea544"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad00af07a907ddc2de2941981340ea544"></a>
const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>compute_domain</b></td></tr>
<tr class="separator:ad00af07a907ddc2de2941981340ea544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3281796648024457060676d254786e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; const Kernel &amp;f __CPU__&#160;</td><td class="memItemRight" valign="bottom"><b>__HC__</b></td></tr>
<tr class="separator:a1d3281796648024457060676d254786e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c51ad5238e479ca6da947b96316f09"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58c51ad5238e479ca6da947b96316f09"></a>
const <a class="el" href="classhc_1_1pfe__wrapper.html">pfe_wrapper</a>&lt; N, Kernel &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_pf</b> (compute_domain, f)</td></tr>
<tr class="separator:a58c51ad5238e479ca6da947b96316f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1016b62014804b7e3d426731d9c67014"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1016b62014804b7e3d426731d9c67014"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ext</b> = compute_domain[0]</td></tr>
<tr class="separator:a1016b62014804b7e3d426731d9c67014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51eff3b3910e1e2b2c4804385f85ab7d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51eff3b3910e1e2b2c4804385f85ab7d"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>tile</b> = compute_domain.tile_dim[0]</td></tr>
<tr class="separator:a51eff3b3910e1e2b2c4804385f85ab7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82436c27e2593fb01238f53493f94f8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82436c27e2593fb01238f53493f94f8d"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>kernel</b> = Kalmar::mcw_cxxamp_get_kernel&lt;Kernel&gt;(av.pQueue, f)</td></tr>
<tr class="separator:a82436c27e2593fb01238f53493f94f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab31f0af1827322a5bf7ce8c4e7d957"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abab31f0af1827322a5bf7ce8c4e7d957"></a>
<a class="el" href="classhc_1_1PrintfPacket.html">PrintfPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>printf_buffer</b></td></tr>
<tr class="separator:abab31f0af1827322a5bf7ce8c4e7d957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53296cbb2bb1a430e2e974550d2d4f23"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>cpu</b></td></tr>
<tr class="separator:a53296cbb2bb1a430e2e974550d2d4f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc5de29f28f6563b6d34b9dfb5f0493"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bc5de29f28f6563b6d34b9dfb5f0493"></a>
return&#160;</td><td class="memItemRight" valign="bottom"><b>size</b></td></tr>
<tr class="separator:a3bc5de29f28f6563b6d34b9dfb5f0493"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Heterogeneous C++ (HC) namespace. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aab139e9ba8ec1252213934fc4ba671f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__activelanecount_u32_b1 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of active work-items in the current wavefront that have a non-zero input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>An unsigned 32-bit integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of active work-items in the current wavefront that have a non-zero input. </dd></dl>

<p>References <a class="el" href="namespacehc.html#a48d507a896f9181568db3d14694c98ab">__activelanemask_v4_b64_b1()</a>, and <a class="el" href="namespacehc.html#a9a4ad6e19394f2c962632e4a1f2ba264">__popcount_u32_b64()</a>.</p>

<p>Referenced by <a class="el" href="namespacehc.html#af7dbc5986d520b78d440045a029bdd36">__all()</a>.</p>

</div>
</div>
<a class="anchor" id="a518b02705c95b77399f523b078960863"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__activelaneid_u32 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the count of the number of earlier (in flattened work-item order) active work-items within the same wavefront. </p>
<dl class="section return"><dt>Returns</dt><dd>The result will be in the range 0 to WAVESIZE - 1. </dd></dl>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a48d507a896f9181568db3d14694c98ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t hc::__activelanemask_v4_b64_b1 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a bit mask shows which active work-items in the wavefront have a non-zero input. </p>
<p>The affected bit position within the registers of dest corresponds to each work-item's lane ID.</p>
<p>The HSAIL instruction would return 4 64-bit registers but the current implementation would only return the 1st one and ignore the other 3 as right now all HSA agents have wavefront of size 64.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>An unsigned 32-bit integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bitmask calculated. </dd></dl>

<p>Referenced by <a class="el" href="namespacehc.html#aab139e9ba8ec1252213934fc4ba671f5">__activelanecount_u32_b1()</a>, <a class="el" href="namespacehc.html#af7dbc5986d520b78d440045a029bdd36">__all()</a>, <a class="el" href="namespacehc.html#a1feb90691ba66a88e32d41d7a426d60e">__any()</a>, <a class="el" href="namespacehc.html#a63928871bb9f5c1669df7fdb92e29a1a">__ballot()</a>, and <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="ad14ac2a59a38ec303a3d78c004469aff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__amdgcn_ds_bpermute </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct copy from indexed active work-item within a wavefront. </p>
<p>Work-items may only read data from another work-item which is active in the current wavefront. If the target work-item is inactive, the retrieved value is fixed as 0.</p>
<p>The function returns the value of var held by the work-item whose ID is given by srcLane. If width is less than <b>HSA_WAVEFRONT_SIZE</b> then each subsection of the wavefront behaves as a separate entity with a starting logical work-item ID of 0. If srcLane is outside the range [0:width-1], the value returned corresponds to the value of var held by: srcLane modulo width (i.e. within the same subsection).</p>
<p>The optional width parameter must have a value which is a power of 2; results are undefined if it is not a power of 2, or is number greater than <b>HSA_WAVEFRONT_SIZE</b>. </p>

<p>References <a class="el" href="namespacehc.html#ae7bd617cc88bef0ebd0a115e98f6a47e">__amdgcn_ds_bpermute()</a>.</p>

</div>
</div>
<a class="anchor" id="ae7bd617cc88bef0ebd0a115e98f6a47e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float hc::__amdgcn_ds_bpermute </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct copy from indexed active work-item within a wavefront. </p>
<p>Work-items may only read data from another work-item which is active in the current wavefront. If the target work-item is inactive, the retrieved value is fixed as 0.</p>
<p>The function returns the value of var held by the work-item whose ID is given by srcLane. If width is less than <b>HSA_WAVEFRONT_SIZE</b> then each subsection of the wavefront behaves as a separate entity with a starting logical work-item ID of 0. If srcLane is outside the range [0:width-1], the value returned corresponds to the value of var held by: srcLane modulo width (i.e. within the same subsection).</p>
<p>The optional width parameter must have a value which is a power of 2; results are undefined if it is not a power of 2, or is number greater than <b>HSA_WAVEFRONT_SIZE</b>. </p>

<p>References <a class="el" href="namespacehc.html#a58c99fa3bfc68ba5588181bd296b8329">__amdgcn_ds_permute()</a>.</p>

<p>Referenced by <a class="el" href="namespacehc.html#ad14ac2a59a38ec303a3d78c004469aff">__amdgcn_ds_bpermute()</a>, <a class="el" href="namespacehc.html#a1ee86debe02dc57b1b597920e0a73a1c">__lane_id()</a>, <a class="el" href="namespacehc.html#af4257770fdd620bc621f9776edd2b084">__shfl()</a>, <a class="el" href="namespacehc.html#ab2ba23c1a4fa1a5b223b26a87cc3b47e">__shfl_down()</a>, <a class="el" href="namespacehc.html#afb062a5f5d3ede692602a0317470ee51">__shfl_up()</a>, and <a class="el" href="namespacehc.html#a4d5476fe3a4689e1d8f4efb446f5b4ed">__shfl_xor()</a>.</p>

</div>
</div>
<a class="anchor" id="a54e4a5c411cc90ab684ff62811e4748b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__amdgcn_ds_permute </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct copy from indexed active work-item within a wavefront. </p>
<p>Work-items may only read data from another work-item which is active in the current wavefront. If the target work-item is inactive, the retrieved value is fixed as 0.</p>
<p>The function returns the value of var held by the work-item whose ID is given by srcLane. If width is less than <b>HSA_WAVEFRONT_SIZE</b> then each subsection of the wavefront behaves as a separate entity with a starting logical work-item ID of 0. If srcLane is outside the range [0:width-1], the value returned corresponds to the value of var held by: srcLane modulo width (i.e. within the same subsection).</p>
<p>The optional width parameter must have a value which is a power of 2; results are undefined if it is not a power of 2, or is number greater than <b>HSA_WAVEFRONT_SIZE</b>. </p>

<p>References <a class="el" href="namespacehc.html#a58c99fa3bfc68ba5588181bd296b8329">__amdgcn_ds_permute()</a>.</p>

</div>
</div>
<a class="anchor" id="a58c99fa3bfc68ba5588181bd296b8329"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float hc::__amdgcn_ds_permute </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct copy from indexed active work-item within a wavefront. </p>
<p>Work-items may only read data from another work-item which is active in the current wavefront. If the target work-item is inactive, the retrieved value is fixed as 0.</p>
<p>The function returns the value of var held by the work-item whose ID is given by srcLane. If width is less than <b>HSA_WAVEFRONT_SIZE</b> then each subsection of the wavefront behaves as a separate entity with a starting logical work-item ID of 0. If srcLane is outside the range [0:width-1], the value returned corresponds to the value of var held by: srcLane modulo width (i.e. within the same subsection).</p>
<p>The optional width parameter must have a value which is a power of 2; results are undefined if it is not a power of 2, or is number greater than <b>HSA_WAVEFRONT_SIZE</b>. </p>

<p>References <a class="el" href="namespacehc.html#a7a6de36b62e83bca03516bbe25c8c51c">__amdgcn_ds_swizzle()</a>.</p>

<p>Referenced by <a class="el" href="namespacehc.html#ae7bd617cc88bef0ebd0a115e98f6a47e">__amdgcn_ds_bpermute()</a>, and <a class="el" href="namespacehc.html#a54e4a5c411cc90ab684ff62811e4748b">__amdgcn_ds_permute()</a>.</p>

</div>
</div>
<a class="anchor" id="ab64ad7ba3b07ad2e47fa529b01264f9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__amdgcn_ds_swizzle </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct copy from indexed active work-item within a wavefront. </p>
<p>Work-items may only read data from another work-item which is active in the current wavefront. If the target work-item is inactive, the retrieved value is fixed as 0.</p>
<p>The function returns the value of var held by the work-item whose ID is given by srcLane. If width is less than <b>HSA_WAVEFRONT_SIZE</b> then each subsection of the wavefront behaves as a separate entity with a starting logical work-item ID of 0. If srcLane is outside the range [0:width-1], the value returned corresponds to the value of var held by: srcLane modulo width (i.e. within the same subsection).</p>
<p>The optional width parameter must have a value which is a power of 2; results are undefined if it is not a power of 2, or is number greater than <b>HSA_WAVEFRONT_SIZE</b>. </p>

<p>References <a class="el" href="namespacehc.html#a7a6de36b62e83bca03516bbe25c8c51c">__amdgcn_ds_swizzle()</a>.</p>

</div>
</div>
<a class="anchor" id="a7a6de36b62e83bca03516bbe25c8c51c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float hc::__amdgcn_ds_swizzle </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct copy from indexed active work-item within a wavefront. </p>
<p>Work-items may only read data from another work-item which is active in the current wavefront. If the target work-item is inactive, the retrieved value is fixed as 0.</p>
<p>The function returns the value of var held by the work-item whose ID is given by srcLane. If width is less than <b>HSA_WAVEFRONT_SIZE</b> then each subsection of the wavefront behaves as a separate entity with a starting logical work-item ID of 0. If srcLane is outside the range [0:width-1], the value returned corresponds to the value of var held by: srcLane modulo width (i.e. within the same subsection).</p>
<p>The optional width parameter must have a value which is a power of 2; results are undefined if it is not a power of 2, or is number greater than <b>HSA_WAVEFRONT_SIZE</b>. </p>

<p>References <a class="el" href="namespacehc.html#a84395cfc190228fd1f121c8b4e6a9386">__amdgcn_move_dpp()</a>, and <a class="el" href="namespacehc.html#a4258da8730aa98d0996aaf67ba8b8094">__amdgcn_wave_sr1()</a>.</p>

<p>Referenced by <a class="el" href="namespacehc.html#a58c99fa3bfc68ba5588181bd296b8329">__amdgcn_ds_permute()</a>, and <a class="el" href="namespacehc.html#ab64ad7ba3b07ad2e47fa529b01264f9b">__amdgcn_ds_swizzle()</a>.</p>

</div>
</div>
<a class="anchor" id="adb6fdbd8ba6f37680e1a8144d06da3f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hc::__amdgcn_mbcnt_hi </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direct copy from indexed active work-item within a wavefront. </p>
<p>Work-items may only read data from another work-item which is active in the current wavefront. If the target work-item is inactive, the retrieved value is fixed as 0.</p>
<p>The function returns the value of var held by the work-item whose ID is given by srcLane. If width is less than <b>HSA_WAVEFRONT_SIZE</b> then each subsection of the wavefront behaves as a separate entity with a starting logical work-item ID of 0. If srcLane is outside the range [0:width-1], the value returned corresponds to the value of var held by: srcLane modulo width (i.e. within the same subsection).</p>
<p>The optional width parameter must have a value which is a power of 2; results are undefined if it is not a power of 2, or is number greater than <b>HSA_WAVEFRONT_SIZE</b>. </p>

<p>Referenced by <a class="el" href="namespacehc.html#a1ee86debe02dc57b1b597920e0a73a1c">__lane_id()</a>.</p>

</div>
</div>
<a class="anchor" id="a0e971454707e60ea8a4c614a8732c0b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hc::__amdgcn_mbcnt_lo </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direct copy from indexed active work-item within a wavefront. </p>
<p>Work-items may only read data from another work-item which is active in the current wavefront. If the target work-item is inactive, the retrieved value is fixed as 0.</p>
<p>The function returns the value of var held by the work-item whose ID is given by srcLane. If width is less than <b>HSA_WAVEFRONT_SIZE</b> then each subsection of the wavefront behaves as a separate entity with a starting logical work-item ID of 0. If srcLane is outside the range [0:width-1], the value returned corresponds to the value of var held by: srcLane modulo width (i.e. within the same subsection).</p>
<p>The optional width parameter must have a value which is a power of 2; results are undefined if it is not a power of 2, or is number greater than <b>HSA_WAVEFRONT_SIZE</b>. </p>

<p>Referenced by <a class="el" href="namespacehc.html#a1ee86debe02dc57b1b597920e0a73a1c">__lane_id()</a>.</p>

</div>
</div>
<a class="anchor" id="a393e4103ec7c4aa3ae845d62531fdd1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hc::__amdgcn_wave_rl1 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotate the value of src to the left by one thread within a wavefront. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>variable being rotated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of src being rotated into from the neighboring lane </dd></dl>

</div>
</div>
<a class="anchor" id="a814af3a3ea80508a38bb2351fea5020b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__amdgcn_wave_rl1 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct copy from indexed active work-item within a wavefront. </p>
<p>Work-items may only read data from another work-item which is active in the current wavefront. If the target work-item is inactive, the retrieved value is fixed as 0.</p>
<p>The function returns the value of var held by the work-item whose ID is given by srcLane. If width is less than <b>HSA_WAVEFRONT_SIZE</b> then each subsection of the wavefront behaves as a separate entity with a starting logical work-item ID of 0. If srcLane is outside the range [0:width-1], the value returned corresponds to the value of var held by: srcLane modulo width (i.e. within the same subsection).</p>
<p>The optional width parameter must have a value which is a power of 2; results are undefined if it is not a power of 2, or is number greater than <b>HSA_WAVEFRONT_SIZE</b>. </p>

<p>References <a class="el" href="namespacehc.html#a64970c36551c0a321a050b5855149348">__amdgcn_wave_rl1()</a>.</p>

</div>
</div>
<a class="anchor" id="a64970c36551c0a321a050b5855149348"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float hc::__amdgcn_wave_rl1 </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct copy from indexed active work-item within a wavefront. </p>
<p>Work-items may only read data from another work-item which is active in the current wavefront. If the target work-item is inactive, the retrieved value is fixed as 0.</p>
<p>The function returns the value of var held by the work-item whose ID is given by srcLane. If width is less than <b>HSA_WAVEFRONT_SIZE</b> then each subsection of the wavefront behaves as a separate entity with a starting logical work-item ID of 0. If srcLane is outside the range [0:width-1], the value returned corresponds to the value of var held by: srcLane modulo width (i.e. within the same subsection).</p>
<p>The optional width parameter must have a value which is a power of 2; results are undefined if it is not a power of 2, or is number greater than <b>HSA_WAVEFRONT_SIZE</b>. </p>

<p>Referenced by <a class="el" href="namespacehc.html#a814af3a3ea80508a38bb2351fea5020b">__amdgcn_wave_rl1()</a>, and <a class="el" href="namespacehc.html#a82e4d9243e55e60f23a758149486ecc9">__amdgcn_wave_rr1()</a>.</p>

</div>
</div>
<a class="anchor" id="a4845fb0465b29b6be73ccec4314fe2fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hc::__amdgcn_wave_rr1 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotate the value of src to the right by one thread within a wavefront. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>variable being rotated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of src being rotated into from the neighboring lane </dd></dl>

</div>
</div>
<a class="anchor" id="a8ea180d659e0b8a786fda300035da39e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__amdgcn_wave_rr1 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct copy from indexed active work-item within a wavefront. </p>
<p>Work-items may only read data from another work-item which is active in the current wavefront. If the target work-item is inactive, the retrieved value is fixed as 0.</p>
<p>The function returns the value of var held by the work-item whose ID is given by srcLane. If width is less than <b>HSA_WAVEFRONT_SIZE</b> then each subsection of the wavefront behaves as a separate entity with a starting logical work-item ID of 0. If srcLane is outside the range [0:width-1], the value returned corresponds to the value of var held by: srcLane modulo width (i.e. within the same subsection).</p>
<p>The optional width parameter must have a value which is a power of 2; results are undefined if it is not a power of 2, or is number greater than <b>HSA_WAVEFRONT_SIZE</b>. </p>

<p>References <a class="el" href="namespacehc.html#a82e4d9243e55e60f23a758149486ecc9">__amdgcn_wave_rr1()</a>.</p>

</div>
</div>
<a class="anchor" id="a82e4d9243e55e60f23a758149486ecc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float hc::__amdgcn_wave_rr1 </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct copy from indexed active work-item within a wavefront. </p>
<p>Work-items may only read data from another work-item which is active in the current wavefront. If the target work-item is inactive, the retrieved value is fixed as 0.</p>
<p>The function returns the value of var held by the work-item whose ID is given by srcLane. If width is less than <b>HSA_WAVEFRONT_SIZE</b> then each subsection of the wavefront behaves as a separate entity with a starting logical work-item ID of 0. If srcLane is outside the range [0:width-1], the value returned corresponds to the value of var held by: srcLane modulo width (i.e. within the same subsection).</p>
<p>The optional width parameter must have a value which is a power of 2; results are undefined if it is not a power of 2, or is number greater than <b>HSA_WAVEFRONT_SIZE</b>. </p>

<p>References <a class="el" href="namespacehc.html#a64970c36551c0a321a050b5855149348">__amdgcn_wave_rl1()</a>.</p>

<p>Referenced by <a class="el" href="namespacehc.html#a8ea180d659e0b8a786fda300035da39e">__amdgcn_wave_rr1()</a>, and <a class="el" href="namespacehc.html#af5131be1cf78ab97dec3935e60385105">__amdgcn_wave_sl1()</a>.</p>

</div>
</div>
<a class="anchor" id="a31569f4de5723d39ace77f8f44beb7ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hc::__amdgcn_wave_sl1 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bound_ctrl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shift the value of src to the left by one thread within a wavefront. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>variable being shifted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bound_ctrl</td><td>When set to true, a zero will be shifted into thread 63; otherwise, the original value will be returned for thread 63 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of src being shifted into from the neighboring lane </dd></dl>

</div>
</div>
<a class="anchor" id="abe78d23ddade3786de560477a66badba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__amdgcn_wave_sl1 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bound_ctrl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct copy from indexed active work-item within a wavefront. </p>
<p>Work-items may only read data from another work-item which is active in the current wavefront. If the target work-item is inactive, the retrieved value is fixed as 0.</p>
<p>The function returns the value of var held by the work-item whose ID is given by srcLane. If width is less than <b>HSA_WAVEFRONT_SIZE</b> then each subsection of the wavefront behaves as a separate entity with a starting logical work-item ID of 0. If srcLane is outside the range [0:width-1], the value returned corresponds to the value of var held by: srcLane modulo width (i.e. within the same subsection).</p>
<p>The optional width parameter must have a value which is a power of 2; results are undefined if it is not a power of 2, or is number greater than <b>HSA_WAVEFRONT_SIZE</b>. </p>

<p>References <a class="el" href="namespacehc.html#af5131be1cf78ab97dec3935e60385105">__amdgcn_wave_sl1()</a>.</p>

</div>
</div>
<a class="anchor" id="af5131be1cf78ab97dec3935e60385105"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float hc::__amdgcn_wave_sl1 </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bound_ctrl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct copy from indexed active work-item within a wavefront. </p>
<p>Work-items may only read data from another work-item which is active in the current wavefront. If the target work-item is inactive, the retrieved value is fixed as 0.</p>
<p>The function returns the value of var held by the work-item whose ID is given by srcLane. If width is less than <b>HSA_WAVEFRONT_SIZE</b> then each subsection of the wavefront behaves as a separate entity with a starting logical work-item ID of 0. If srcLane is outside the range [0:width-1], the value returned corresponds to the value of var held by: srcLane modulo width (i.e. within the same subsection).</p>
<p>The optional width parameter must have a value which is a power of 2; results are undefined if it is not a power of 2, or is number greater than <b>HSA_WAVEFRONT_SIZE</b>. </p>

<p>References <a class="el" href="namespacehc.html#a82e4d9243e55e60f23a758149486ecc9">__amdgcn_wave_rr1()</a>.</p>

<p>Referenced by <a class="el" href="namespacehc.html#abe78d23ddade3786de560477a66badba">__amdgcn_wave_sl1()</a>, and <a class="el" href="namespacehc.html#a4258da8730aa98d0996aaf67ba8b8094">__amdgcn_wave_sr1()</a>.</p>

</div>
</div>
<a class="anchor" id="ace6ddb7251cf1330068e49cf997b4354"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hc::__amdgcn_wave_sr1 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bound_ctrl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shift the value of src to the right by one thread within a wavefront. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>variable being shifted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bound_ctrl</td><td>When set to true, a zero will be shifted into thread 0; otherwise, the original value will be returned for thread 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of src being shifted into from the neighboring lane </dd></dl>

</div>
</div>
<a class="anchor" id="a1faea6490dda1d240de723cae16cc645"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__amdgcn_wave_sr1 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bound_ctrl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct copy from indexed active work-item within a wavefront. </p>
<p>Work-items may only read data from another work-item which is active in the current wavefront. If the target work-item is inactive, the retrieved value is fixed as 0.</p>
<p>The function returns the value of var held by the work-item whose ID is given by srcLane. If width is less than <b>HSA_WAVEFRONT_SIZE</b> then each subsection of the wavefront behaves as a separate entity with a starting logical work-item ID of 0. If srcLane is outside the range [0:width-1], the value returned corresponds to the value of var held by: srcLane modulo width (i.e. within the same subsection).</p>
<p>The optional width parameter must have a value which is a power of 2; results are undefined if it is not a power of 2, or is number greater than <b>HSA_WAVEFRONT_SIZE</b>. </p>

<p>References <a class="el" href="namespacehc.html#a4258da8730aa98d0996aaf67ba8b8094">__amdgcn_wave_sr1()</a>.</p>

</div>
</div>
<a class="anchor" id="a4258da8730aa98d0996aaf67ba8b8094"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float hc::__amdgcn_wave_sr1 </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bound_ctrl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct copy from indexed active work-item within a wavefront. </p>
<p>Work-items may only read data from another work-item which is active in the current wavefront. If the target work-item is inactive, the retrieved value is fixed as 0.</p>
<p>The function returns the value of var held by the work-item whose ID is given by srcLane. If width is less than <b>HSA_WAVEFRONT_SIZE</b> then each subsection of the wavefront behaves as a separate entity with a starting logical work-item ID of 0. If srcLane is outside the range [0:width-1], the value returned corresponds to the value of var held by: srcLane modulo width (i.e. within the same subsection).</p>
<p>The optional width parameter must have a value which is a power of 2; results are undefined if it is not a power of 2, or is number greater than <b>HSA_WAVEFRONT_SIZE</b>. </p>

<p>References <a class="el" href="namespacehc.html#af5131be1cf78ab97dec3935e60385105">__amdgcn_wave_sl1()</a>.</p>

<p>Referenced by <a class="el" href="namespacehc.html#a7a6de36b62e83bca03516bbe25c8c51c">__amdgcn_ds_swizzle()</a>, and <a class="el" href="namespacehc.html#a1faea6490dda1d240de723cae16cc645">__amdgcn_wave_sr1()</a>.</p>

</div>
</div>
<a class="anchor" id="aa01f045e1ab6336e7776d3bbdadb65bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__atomic_wrapdec </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically do the following operations: </p>
<ul>
<li>reads the 32-bit value (original) from address pointer in global or group segment</li>
<li>computes ((original == 0) || (original &gt; val)) ? val : (original - 1)</li>
<li>stores the result back to the address</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>The original value retrieved from address pointer.</dd></dl>
<p>Please refer to <a href="http://www.hsafoundation.com/html/HSA_Library.htm#PRM/Topics/06_Memory/atomic.htm">atomic_wrapdec in HSA PRM 6.6</a> for more detailed specification of the function. </p>

<p>Referenced by <a class="el" href="namespacehc.html#abfca81adfdf1af6f9724114f095b3d5b">copy_async()</a>.</p>

</div>
</div>
<a class="anchor" id="adbc6976a1ea23546bbf65ecb4cd2caa8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__atomic_wrapinc </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically do the following operations: </p>
<ul>
<li>reads the 32-bit value (original) from address pointer in global or group segment</li>
<li>computes ((original &gt;= val) ? 0 : (original + 1))</li>
<li>stores the result back to the address</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>The original value retrieved from address pointer.</dd></dl>
<p>Please refer to <a href="http://www.hsafoundation.com/html/HSA_Library.htm#PRM/Topics/06_Memory/atomic.htm">atomic_wrapinc in HSA PRM 6.6</a> for more detailed specification of the function. </p>

<p>Referenced by <a class="el" href="namespacehc.html#abfca81adfdf1af6f9724114f095b3d5b">copy_async()</a>.</p>

</div>
</div>
<a class="anchor" id="a790eb8855c4d34602b382ac9a2777600"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__bitalign_b32 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Align 32 bits within 64 bits of data on an arbitrary bit boundary. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/multimedia.htm">HSA PRM 5.15</a> for more detailed specification. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a2336cdaba01761e44fbefddbcd078170"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hc::__bitextract_s32 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a range of bits. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/bit_string.htm">HSA PRM 5.7</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#ab7d68af33b943427dfd864f21be8c1a7">__bitextract_u32()</a>.</p>

</div>
</div>
<a class="anchor" id="a9a2c18450fe385de1be4f3db29b55671"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t hc::__bitextract_s64 </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a range of bits. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/bit_string.htm">HSA PRM 5.7</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#ab7d68af33b943427dfd864f21be8c1a7">__bitextract_u32()</a>.</p>

</div>
</div>
<a class="anchor" id="ab7d68af33b943427dfd864f21be8c1a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__bitextract_u32 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a range of bits. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/bit_string.htm">HSA PRM 5.7</a> for more detailed specification of these functions. </p>

<p>References <a class="el" href="namespacehc.html#a2336cdaba01761e44fbefddbcd078170">__bitextract_s32()</a>, <a class="el" href="namespacehc.html#a9a2c18450fe385de1be4f3db29b55671">__bitextract_s64()</a>, <a class="el" href="namespacehc.html#a5c067ff1962e65bf38ab1b6ad8ba45c6">__bitextract_u64()</a>, <a class="el" href="namespacehc.html#a97e425f01102241414c6daf8a4353617">__bitinsert_s32()</a>, <a class="el" href="namespacehc.html#af8a1e61a0026a81e5883b3fa0d69faf3">__bitinsert_s64()</a>, <a class="el" href="namespacehc.html#a961ff948dde14859acb29aa1ce1c7988">__bitinsert_u32()</a>, <a class="el" href="namespacehc.html#a4837929d10e0e5e3b2c6d46e72d2413f">__bitinsert_u64()</a>, <a class="el" href="namespacehc.html#a3eb60d1735ef8a9e657048776ec18de6">__bitmask_b32()</a>, <a class="el" href="namespacehc.html#a3a73bfdc3c8a9d202125a697e542cee9">__bitmask_b64()</a>, <a class="el" href="namespacehc.html#a368bdf36391edbcf3648416366aebca0">__bitrev_b32()</a>, <a class="el" href="namespacehc.html#aa6c7b8a0fdf82f087223f1a606b5992c">__bitrev_b64()</a>, <a class="el" href="namespacehc.html#a53b190f8e293c4991d3443910bb3c35d">__bitselect_b32()</a>, and <a class="el" href="namespacehc.html#a156fe3e818d24651a33a659b5e61790d">__bitselect_b64()</a>.</p>

</div>
</div>
<a class="anchor" id="a5c067ff1962e65bf38ab1b6ad8ba45c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t hc::__bitextract_u64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a range of bits. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/bit_string.htm">HSA PRM 5.7</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#ab7d68af33b943427dfd864f21be8c1a7">__bitextract_u32()</a>.</p>

</div>
</div>
<a class="anchor" id="a97e425f01102241414c6daf8a4353617"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hc::__bitinsert_s32 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a range of bits. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/bit_string.htm">HSA PRM 5.7</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#ab7d68af33b943427dfd864f21be8c1a7">__bitextract_u32()</a>.</p>

</div>
</div>
<a class="anchor" id="af8a1e61a0026a81e5883b3fa0d69faf3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t hc::__bitinsert_s64 </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a range of bits. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/bit_string.htm">HSA PRM 5.7</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#ab7d68af33b943427dfd864f21be8c1a7">__bitextract_u32()</a>.</p>

</div>
</div>
<a class="anchor" id="a961ff948dde14859acb29aa1ce1c7988"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__bitinsert_u32 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a range of bits. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/bit_string.htm">HSA PRM 5.7</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#ab7d68af33b943427dfd864f21be8c1a7">__bitextract_u32()</a>.</p>

</div>
</div>
<a class="anchor" id="a4837929d10e0e5e3b2c6d46e72d2413f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t hc::__bitinsert_u64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a range of bits. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/bit_string.htm">HSA PRM 5.7</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#ab7d68af33b943427dfd864f21be8c1a7">__bitextract_u32()</a>.</p>

</div>
</div>
<a class="anchor" id="a3eb60d1735ef8a9e657048776ec18de6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__bitmask_b32 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a bit mask that can be used with bitselect. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/bit_string.htm">HSA PRM 5.7</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#ab7d68af33b943427dfd864f21be8c1a7">__bitextract_u32()</a>.</p>

</div>
</div>
<a class="anchor" id="a3a73bfdc3c8a9d202125a697e542cee9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t hc::__bitmask_b64 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a bit mask that can be used with bitselect. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/bit_string.htm">HSA PRM 5.7</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#ab7d68af33b943427dfd864f21be8c1a7">__bitextract_u32()</a>.</p>

</div>
</div>
<a class="anchor" id="a368bdf36391edbcf3648416366aebca0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__bitrev_b32 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src0</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse the bits. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/bit_string.htm">HSA PRM 5.7</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#ab7d68af33b943427dfd864f21be8c1a7">__bitextract_u32()</a>.</p>

</div>
</div>
<a class="anchor" id="aa6c7b8a0fdf82f087223f1a606b5992c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t hc::__bitrev_b64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>src0</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse the bits. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/bit_string.htm">HSA PRM 5.7</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#ab7d68af33b943427dfd864f21be8c1a7">__bitextract_u32()</a>.</p>

</div>
</div>
<a class="anchor" id="a53b190f8e293c4991d3443910bb3c35d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__bitselect_b32 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do bit field selection. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/bit_string.htm">HSA PRM 5.7</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#ab7d68af33b943427dfd864f21be8c1a7">__bitextract_u32()</a>.</p>

</div>
</div>
<a class="anchor" id="a156fe3e818d24651a33a659b5e61790d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t hc::__bitselect_b64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do bit field selection. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/bit_string.htm">HSA PRM 5.7</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#ab7d68af33b943427dfd864f21be8c1a7">__bitextract_u32()</a>.</p>

</div>
</div>
<a class="anchor" id="a4dbaeaed929e26f2a768c72f1e39104b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__bytealign_b32 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Align 32 bits within 64 bis of data on an arbitrary byte boundary. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/multimedia.htm">HSA PRM 5.15</a> for more detailed specification. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="addedc07838df1e5ecf1a78ccc1df3716"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t hc::__cycle_u64 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get hardware cycle count. </p>
<p>Notice the return value of this function is implementation defined. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a21c8d47e6b5159b2bfff1acbac7a3112"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__firstbit_u32_s32 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count leading zero bits in the input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>An signed 32-bit integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Finds the first bit set in a positive integer starting from the most significant bit, or finds the first bit clear in a negative integer from the most significant bit. If no bits in the input are set, then dest is set to -1. </dd></dl>

<p>References <a class="el" href="namespacehc.html#af39c28e56a9368c546ffb07489f39623">__firstbit_u32_u32()</a>.</p>

</div>
</div>
<a class="anchor" id="a36408fe848adef2b9030bc6bd2761bf4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__firstbit_u32_s64 </td>
          <td>(</td>
          <td class="paramtype">long long int&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count leading zero bits in the input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>An signed 64-bit integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Finds the first bit set in a positive integer starting from the most significant bit, or finds the first bit clear in a negative integer from the most significant bit. If no bits in the input are set, then dest is set to -1. </dd></dl>

<p>References <a class="el" href="namespacehc.html#ae0c9f4d9d7bc665fb83ac5c8797f2720">__firstbit_u32_u64()</a>.</p>

</div>
</div>
<a class="anchor" id="af39c28e56a9368c546ffb07489f39623"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__firstbit_u32_u32 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count leading zero bits in the input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>An unsigned 32-bit integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of 0 bits until a 1 bit is found, counting start from the most significant bit. -1 if there is no 0 bit. </dd></dl>

<p>Referenced by <a class="el" href="namespacehc.html#a21c8d47e6b5159b2bfff1acbac7a3112">__firstbit_u32_s32()</a>.</p>

</div>
</div>
<a class="anchor" id="ae0c9f4d9d7bc665fb83ac5c8797f2720"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__firstbit_u32_u64 </td>
          <td>(</td>
          <td class="paramtype">unsigned long long int&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count leading zero bits in the input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>An unsigned 64-bit integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of 0 bits until a 1 bit is found, counting start from the most significant bit. -1 if there is no 0 bit. </dd></dl>

<p>Referenced by <a class="el" href="namespacehc.html#a36408fe848adef2b9030bc6bd2761bf4">__firstbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a1ee86debe02dc57b1b597920e0a73a1c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int hc::__lane_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct copy from indexed active work-item within a wavefront. </p>
<p>Work-items may only read data from another work-item which is active in the current wavefront. If the target work-item is inactive, the retrieved value is fixed as 0.</p>
<p>The function returns the value of var held by the work-item whose ID is given by srcLane. If width is less than <b>HSA_WAVEFRONT_SIZE</b> then each subsection of the wavefront behaves as a separate entity with a starting logical work-item ID of 0. If srcLane is outside the range [0:width-1], the value returned corresponds to the value of var held by: srcLane modulo width (i.e. within the same subsection).</p>
<p>The optional width parameter must have a value which is a power of 2; results are undefined if it is not a power of 2, or is number greater than <b>HSA_WAVEFRONT_SIZE</b>. </p>

<p>References <a class="el" href="namespacehc.html#ae7bd617cc88bef0ebd0a115e98f6a47e">__amdgcn_ds_bpermute()</a>, <a class="el" href="namespacehc.html#adb6fdbd8ba6f37680e1a8144d06da3f2">__amdgcn_mbcnt_hi()</a>, and <a class="el" href="namespacehc.html#a0e971454707e60ea8a4c614a8732c0b5">__amdgcn_mbcnt_lo()</a>.</p>

<p>Referenced by <a class="el" href="namespacehc.html#af4257770fdd620bc621f9776edd2b084">__shfl()</a>, <a class="el" href="namespacehc.html#ab2ba23c1a4fa1a5b223b26a87cc3b47e">__shfl_down()</a>, <a class="el" href="namespacehc.html#afb062a5f5d3ede692602a0317470ee51">__shfl_up()</a>, and <a class="el" href="namespacehc.html#a4d5476fe3a4689e1d8f4efb446f5b4ed">__shfl_xor()</a>.</p>

</div>
</div>
<a class="anchor" id="a452a1c0f3cf4ae8e39daae6a53631c94"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__lastbit_u32_s32 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first bit set to 1 in a number starting from the least significant bit. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/bit_string.htm">HSA PRM 5.7</a> for more detailed specification of these functions. </p>

<p>References <a class="el" href="namespacehc.html#a53c79d41462733762d069c2504b268e0">__lastbit_u32_u32()</a>.</p>

</div>
</div>
<a class="anchor" id="aa72edf96f4a16e7a02c5463e9b2d11b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__lastbit_u32_s64 </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first bit set to 1 in a number starting from the least significant bit. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/bit_string.htm">HSA PRM 5.7</a> for more detailed specification of these functions. </p>

<p>References <a class="el" href="namespacehc.html#a518b02705c95b77399f523b078960863">__activelaneid_u32()</a>, <a class="el" href="namespacehc.html#a48d507a896f9181568db3d14694c98ab">__activelanemask_v4_b64_b1()</a>, <a class="el" href="namespacehc.html#a790eb8855c4d34602b382ac9a2777600">__bitalign_b32()</a>, <a class="el" href="namespacehc.html#a4dbaeaed929e26f2a768c72f1e39104b">__bytealign_b32()</a>, <a class="el" href="namespacehc.html#aee0a139af8b91b2f5394564449e9034b">__clock_u64()</a>, <a class="el" href="namespacehc.html#addedc07838df1e5ecf1a78ccc1df3716">__cycle_u64()</a>, <a class="el" href="namespacehc.html#adc37037b1bc07f391d8255ac2e44cb7e">__lastbit_u32_u64()</a>, <a class="el" href="namespacehc.html#a575ed483f89436a35d0827c90e23934f">__lerp_u8x4()</a>, <a class="el" href="namespacehc.html#af72a1a20e16f9b4431e6204f817b5523">__pack_f32x2_f32()</a>, <a class="el" href="namespacehc.html#a0d11f5bd959c92354da6bbedb835e621">__pack_s16x2_s32()</a>, <a class="el" href="namespacehc.html#a75c9a7ae8cea0d921b7dee18a94370cc">__pack_s16x4_s32()</a>, <a class="el" href="namespacehc.html#aa0671c523932e4c1bca5d54e94e5d84d">__pack_s32x2_s32()</a>, <a class="el" href="namespacehc.html#ae2fc627085fdf04e35363ec4c1cd870f">__pack_s8x4_s32()</a>, <a class="el" href="namespacehc.html#a08a3f6de4a4582ddeb2d084b13414b9b">__pack_s8x8_s32()</a>, <a class="el" href="namespacehc.html#a3557c5dd4b9cfd7b5f03296ff73e5606">__pack_u16x2_u32()</a>, <a class="el" href="namespacehc.html#acaa102308ba50dc87f1923a47b8d5b89">__pack_u16x4_u32()</a>, <a class="el" href="namespacehc.html#aa8ee0dd4d3b076079efe964561f6df2f">__pack_u32x2_u32()</a>, <a class="el" href="namespacehc.html#a6e1faff89347656244ec48d999fbc69e">__pack_u8x4_u32()</a>, <a class="el" href="namespacehc.html#a62656c02cc32a8a7ae6ac5345f233bbe">__pack_u8x8_u32()</a>, <a class="el" href="namespacehc.html#af9b9b99aa1ada58dfe25b00c6b06950a">__packcvt_u8x4_f32()</a>, <a class="el" href="namespacehc.html#a097611f2a6b2a9101010d20477a93266">__sad_u32_u16x2()</a>, <a class="el" href="namespacehc.html#a0fe54df1c124d07a3fcef8eac770d61f">__sad_u32_u32()</a>, <a class="el" href="namespacehc.html#a91b7a2c676f36a9a11fe95adc26b6839">__sad_u32_u8x4()</a>, <a class="el" href="namespacehc.html#a3b684a9f630186124fab2494a080963b">__sadhi_u16x2_u8x4()</a>, <a class="el" href="namespacehc.html#a98052b106b6eea9667cd19b7e9bb71f4">__unpack_f32_f32x2()</a>, <a class="el" href="namespacehc.html#a08889e4ea03eca5f8f1a0f83973da032">__unpack_s32_s16x2()</a>, <a class="el" href="namespacehc.html#a8bcd498c879dc731c3d1696c10c1f5d2">__unpack_s32_s16x4()</a>, <a class="el" href="namespacehc.html#a4dd5f399232544c74be95df91c8bbc84">__unpack_s32_s3x2()</a>, <a class="el" href="namespacehc.html#a9f4e769cca3f7b9ccbf14af2415d0e7e">__unpack_s32_s8x4()</a>, <a class="el" href="namespacehc.html#a37818d9eaf45ecfd6068ce58518179ad">__unpack_s32_s8x8()</a>, <a class="el" href="namespacehc.html#ad38f5dc8bcae5ad6aa8822a898d684cd">__unpack_u32_u16x2()</a>, <a class="el" href="namespacehc.html#ab936a88a2ee5095d2726124b5abf9e0c">__unpack_u32_u16x4()</a>, <a class="el" href="namespacehc.html#a3291dae53730b38e155469772499893a">__unpack_u32_u32x2()</a>, <a class="el" href="namespacehc.html#aa89504c0311e6ccc0af7bd5998b99b1a">__unpack_u32_u8x4()</a>, <a class="el" href="namespacehc.html#aae064e8de38365d170b75ca2b5c91630">__unpack_u32_u8x8()</a>, <a class="el" href="namespacehc.html#a398e80d3ecd8163acc99b97ed2a4e699">__unpackcvt_f32_u8x4()</a>, <a class="el" href="namespacehc.html#ac9aa819cac89ce8e050498b6b7d871a1">__unpackhi_s16x2()</a>, <a class="el" href="namespacehc.html#a3fe971dbc1279815910e3f8a7296e04b">__unpackhi_s16x4()</a>, <a class="el" href="namespacehc.html#ad28c8309f3cc71369839b06d43dfe9d6">__unpackhi_s32x2()</a>, <a class="el" href="namespacehc.html#ac6c213e05d1139301491527f5eb4d5de">__unpackhi_s8x4()</a>, <a class="el" href="namespacehc.html#a7d1d7b458e0641d8ec408aa7cc56eb8e">__unpackhi_s8x8()</a>, <a class="el" href="namespacehc.html#a922cf3fff83656b785769e349c178960">__unpackhi_u16x2()</a>, <a class="el" href="namespacehc.html#a38241ba7a0072f08e4e6a35edeec8242">__unpackhi_u16x4()</a>, <a class="el" href="namespacehc.html#a0b9405bd932d73b6cec17f2dafb03fe0">__unpackhi_u32x2()</a>, <a class="el" href="namespacehc.html#a3d76bf79cfeec4b886e5e7827bc979dc">__unpackhi_u8x4()</a>, <a class="el" href="namespacehc.html#a1846a4d2c7867799368ad136fcae43c3">__unpackhi_u8x8()</a>, <a class="el" href="namespacehc.html#a1b2fc5d4b019ca1b2058971d21998972">__unpacklo_s16x2()</a>, <a class="el" href="namespacehc.html#a81e7134973ebb73059739023a9c040a3">__unpacklo_s16x4()</a>, <a class="el" href="namespacehc.html#a524d7a4aa0c87bf1d32d61780394a73b">__unpacklo_s32x2()</a>, <a class="el" href="namespacehc.html#a1b7c8cda5a28d0c9bf32308b07d25431">__unpacklo_s8x4()</a>, <a class="el" href="namespacehc.html#afc6eeec8da4ad7af7775dca688aa3a5b">__unpacklo_s8x8()</a>, <a class="el" href="namespacehc.html#a198ca447a0f8c664706332c5d6855ea9">__unpacklo_u16x2()</a>, <a class="el" href="namespacehc.html#aba1ffe2751b1462b5dc4d7814f718f8b">__unpacklo_u16x4()</a>, <a class="el" href="namespacehc.html#ac115a01fcebfbc8cef346363a89f7807">__unpacklo_u32x2()</a>, <a class="el" href="namespacehc.html#a1c352973da30d1e147c499519d1e6f82">__unpacklo_u8x4()</a>, and <a class="el" href="namespacehc.html#a2b3047ffa8f9223ec5a798462eb1b9a1">__unpacklo_u8x8()</a>.</p>

</div>
</div>
<a class="anchor" id="a53c79d41462733762d069c2504b268e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__lastbit_u32_u32 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first bit set to 1 in a number starting from the least significant bit. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/bit_string.htm">HSA PRM 5.7</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#a452a1c0f3cf4ae8e39daae6a53631c94">__lastbit_u32_s32()</a>.</p>

</div>
</div>
<a class="anchor" id="adc37037b1bc07f391d8255ac2e44cb7e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__lastbit_u32_u64 </td>
          <td>(</td>
          <td class="paramtype">unsigned long long int&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first bit set to 1 in a number starting from the least significant bit. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/bit_string.htm">HSA PRM 5.7</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a575ed483f89436a35d0827c90e23934f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__lerp_u8x4 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do linear interpolation and computes the unsigned 8-bit average of packed data. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/multimedia.htm">HSA PRM 5.15</a> for more detailed specification. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a4dbf9fbafaeb0fb18e68fbdeb8291b7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__mad24 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply two unsigned integers (x,y) but only the lower 24 bits will be used in the multiplication and then add the product to a 32-bit unsigned integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>24-bit unsigned integer multiplier </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>24-bit unsigned integer multiplicand </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>32-bit unsigned integer to be added to the product </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>32-bit unsigned integer result of mad24 </dd></dl>

<p>References <a class="el" href="namespacehc.html#ab90dd9e111f0404723d3dcd48c3c427f">__mul24()</a>.</p>

</div>
</div>
<a class="anchor" id="aec3ff833b8dfd488fe9f29cfb29c1334"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int hc::__mad24 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply two integers (x,y) but only the lower 24 bits will be used in the multiplication and then add the product to a 32-bit integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>24-bit integer multiplier </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>24-bit integer multiplicand </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>32-bit integer to be added to the product </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>32-bit integer result of mad24 </dd></dl>

<p>References <a class="el" href="namespacehc.html#ab90dd9e111f0404723d3dcd48c3c427f">__mul24()</a>, <a class="el" href="namespacehc.html#a630288ca281db35cfb1b4d6c79c74bb5">get_dynamic_group_segment_base_pointer()</a>, <a class="el" href="namespacehc.html#a5e86c303e95a21cdbcf9c7019694c3d9">get_group_segment_base_pointer()</a>, <a class="el" href="namespacehc.html#a10d125c77255cf875e818f574fd6255d">get_group_segment_size()</a>, and <a class="el" href="namespacehc.html#a8ad0b4e17bb8c7c73107b5d9b383a2d3">get_static_group_segment_size()</a>.</p>

</div>
</div>
<a class="anchor" id="a71e28f0ab139f835c645ab905128dfb1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__mul24 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply two unsigned integers (x,y) but only the lower 24 bits will be used in the multiplication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>24-bit unsigned integer multiplier </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>24-bit unsigned integer multiplicand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>32-bit unsigned integer product </dd></dl>

</div>
</div>
<a class="anchor" id="ab90dd9e111f0404723d3dcd48c3c427f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int hc::__mul24 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply two integers (x,y) but only the lower 24 bits will be used in the multiplication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>24-bit integer multiplier </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>24-bit integer multiplicand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>32-bit integer product </dd></dl>

<p>Referenced by <a class="el" href="namespacehc.html#a4dbf9fbafaeb0fb18e68fbdeb8291b7c">__mad24()</a>.</p>

</div>
</div>
<a class="anchor" id="af72a1a20e16f9b4431e6204f817b5523"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double hc::__pack_f32x2_f32 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the elements of the packed value in src0, replacing the element specified by src2 with the value from src1. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a0d11f5bd959c92354da6bbedb835e621"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hc::__pack_s16x2_s32 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the elements of the packed value in src0, replacing the element specified by src2 with the value from src1. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a75c9a7ae8cea0d921b7dee18a94370cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t hc::__pack_s16x4_s32 </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the elements of the packed value in src0, replacing the element specified by src2 with the value from src1. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="aa0671c523932e4c1bca5d54e94e5d84d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t hc::__pack_s32x2_s32 </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the elements of the packed value in src0, replacing the element specified by src2 with the value from src1. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="ae2fc627085fdf04e35363ec4c1cd870f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hc::__pack_s8x4_s32 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the elements of the packed value in src0, replacing the element specified by src2 with the value from src1. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a08a3f6de4a4582ddeb2d084b13414b9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t hc::__pack_s8x8_s32 </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the elements of the packed value in src0, replacing the element specified by src2 with the value from src1. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a3557c5dd4b9cfd7b5f03296ff73e5606"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned hc::__pack_u16x2_u32 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the elements of the packed value in src0, replacing the element specified by src2 with the value from src1. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="acaa102308ba50dc87f1923a47b8d5b89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t hc::__pack_u16x4_u32 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the elements of the packed value in src0, replacing the element specified by src2 with the value from src1. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="aa8ee0dd4d3b076079efe964561f6df2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t hc::__pack_u32x2_u32 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the elements of the packed value in src0, replacing the element specified by src2 with the value from src1. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a6e1faff89347656244ec48d999fbc69e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__pack_u8x4_u32 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the elements of the packed value in src0, replacing the element specified by src2 with the value from src1. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a62656c02cc32a8a7ae6ac5345f233bbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t hc::__pack_u8x8_u32 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the elements of the packed value in src0, replacing the element specified by src2 with the value from src1. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="af9b9b99aa1ada58dfe25b00c6b06950a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__packcvt_u8x4_f32 </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>src3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes four floating-point number, convers them to unsigned integer values, and packs them into a packed u8x4 value. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/multimedia.htm">HSA PRM 5.15</a> for more detailed specification. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="aa5ad4d92e0a809d37a40c2c327b4cccc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__popcount_u32_b32 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count number of 1 bits in the input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>An unsinged 32-bit integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of 1 bits in the input. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a4ad6e19394f2c962632e4a1f2ba264"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__popcount_u32_b64 </td>
          <td>(</td>
          <td class="paramtype">unsigned long long int&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count number of 1 bits in the input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>An unsinged 64-bit integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of 1 bits in the input. </dd></dl>

<p>Referenced by <a class="el" href="namespacehc.html#aab139e9ba8ec1252213934fc4ba671f5">__activelanecount_u32_b1()</a>, <a class="el" href="namespacehc.html#af7dbc5986d520b78d440045a029bdd36">__all()</a>, and <a class="el" href="namespacehc.html#a1feb90691ba66a88e32d41d7a426d60e">__any()</a>.</p>

</div>
</div>
<a class="anchor" id="a097611f2a6b2a9101010d20477a93266"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__sad_u32_u16x2 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the sum of the absolute differences of src0 and src1 and then adds src2 to the result. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/multimedia.htm">HSA PRM 5.15</a> for more detailed specification. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a0fe54df1c124d07a3fcef8eac770d61f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__sad_u32_u32 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the sum of the absolute differences of src0 and src1 and then adds src2 to the result. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/multimedia.htm">HSA PRM 5.15</a> for more detailed specification. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a91b7a2c676f36a9a11fe95adc26b6839"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__sad_u32_u8x4 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the sum of the absolute differences of src0 and src1 and then adds src2 to the result. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/multimedia.htm">HSA PRM 5.15</a> for more detailed specification. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a3b684a9f630186124fab2494a080963b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__sadhi_u16x2_u8x4 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is mostly the same as sad except the sum of absolute differences is added to the most significant 16 bits of the result. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/multimedia.htm">HSA PRM 5.15</a> for more detailed specification. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="af4257770fdd620bc621f9776edd2b084"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int hc::__shfl </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcLane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code><a class="el" href="hc_8hpp.html#ab71c5e1746e89bffb56cfa5cd507ca24">__HSA_WAVEFRONT_SIZE__</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct copy from indexed active work-item within a wavefront. </p>
<p>Work-items may only read data from another work-item which is active in the current wavefront. If the target work-item is inactive, the retrieved value is fixed as 0.</p>
<p>The function returns the value of var held by the work-item whose ID is given by srcLane. If width is less than <b>HSA_WAVEFRONT_SIZE</b> then each subsection of the wavefront behaves as a separate entity with a starting logical work-item ID of 0. If srcLane is outside the range [0:width-1], the value returned corresponds to the value of var held by: srcLane modulo width (i.e. within the same subsection).</p>
<p>The optional width parameter must have a value which is a power of 2; results are undefined if it is not a power of 2, or is number greater than <b>HSA_WAVEFRONT_SIZE</b>. </p>

<p>References <a class="el" href="namespacehc.html#ae7bd617cc88bef0ebd0a115e98f6a47e">__amdgcn_ds_bpermute()</a>, and <a class="el" href="namespacehc.html#a1ee86debe02dc57b1b597920e0a73a1c">__lane_id()</a>.</p>

</div>
</div>
<a class="anchor" id="abe5d4f77623cdc85dfadf5f428749ef7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__shfl </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcLane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code><a class="el" href="hc_8hpp.html#ab71c5e1746e89bffb56cfa5cd507ca24">__HSA_WAVEFRONT_SIZE__</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct copy from indexed active work-item within a wavefront. </p>
<p>Work-items may only read data from another work-item which is active in the current wavefront. If the target work-item is inactive, the retrieved value is fixed as 0.</p>
<p>The function returns the value of var held by the work-item whose ID is given by srcLane. If width is less than <b>HSA_WAVEFRONT_SIZE</b> then each subsection of the wavefront behaves as a separate entity with a starting logical work-item ID of 0. If srcLane is outside the range [0:width-1], the value returned corresponds to the value of var held by: srcLane modulo width (i.e. within the same subsection).</p>
<p>The optional width parameter must have a value which is a power of 2; results are undefined if it is not a power of 2, or is number greater than <b>HSA_WAVEFRONT_SIZE</b>. </p>

<p>References <a class="el" href="namespacehc.html#a00c07da4556093fc8d39ca28e233bd8b">__shfl()</a>.</p>

</div>
</div>
<a class="anchor" id="a00c07da4556093fc8d39ca28e233bd8b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float hc::__shfl </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcLane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code><a class="el" href="hc_8hpp.html#ab71c5e1746e89bffb56cfa5cd507ca24">__HSA_WAVEFRONT_SIZE__</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct copy from indexed active work-item within a wavefront. </p>
<p>Work-items may only read data from another work-item which is active in the current wavefront. If the target work-item is inactive, the retrieved value is fixed as 0.</p>
<p>The function returns the value of var held by the work-item whose ID is given by srcLane. If width is less than <b>HSA_WAVEFRONT_SIZE</b> then each subsection of the wavefront behaves as a separate entity with a starting logical work-item ID of 0. If srcLane is outside the range [0:width-1], the value returned corresponds to the value of var held by: srcLane modulo width (i.e. within the same subsection).</p>
<p>The optional width parameter must have a value which is a power of 2; results are undefined if it is not a power of 2, or is number greater than <b>HSA_WAVEFRONT_SIZE</b>. </p>

<p>Referenced by <a class="el" href="namespacehc.html#abe5d4f77623cdc85dfadf5f428749ef7">__shfl()</a>.</p>

</div>
</div>
<a class="anchor" id="ab2ba23c1a4fa1a5b223b26a87cc3b47e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int hc::__shfl_down </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>width</em> = <code><a class="el" href="hc_8hpp.html#ab71c5e1746e89bffb56cfa5cd507ca24">__HSA_WAVEFRONT_SIZE__</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy from an active work-item with higher ID relative to caller within a wavefront. </p>
<p>Work-items may only read data from another work-item which is active in the current wavefront. If the target work-item is inactive, the retrieved value is fixed as 0.</p>
<p>The function calculates a source work-item ID by adding delta from the caller's work-item ID within the wavefront. The value of var held by the resulting lane ID is returned: this has the effect of shifting var up the wavefront by delta work-items. If width is less than <b>HSA_WAVEFRONT_SIZE</b> then each subsection of the wavefront behaves as a separate entity with a starting logical work-item ID of 0. The ID number of the source work-item index will not wrap around the value of width, so the upper delta work-items will remain unchanged.</p>
<p>The optional width parameter must have a value which is a power of 2; results are undefined if it is not a power of 2, or is number greater than <b>HSA_WAVEFRONT_SIZE</b>. </p>

<p>References <a class="el" href="namespacehc.html#ae7bd617cc88bef0ebd0a115e98f6a47e">__amdgcn_ds_bpermute()</a>, and <a class="el" href="namespacehc.html#a1ee86debe02dc57b1b597920e0a73a1c">__lane_id()</a>.</p>

</div>
</div>
<a class="anchor" id="aa12b5e4f903cb07d4cd8db915fe4e8d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__shfl_down </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>width</em> = <code><a class="el" href="hc_8hpp.html#ab71c5e1746e89bffb56cfa5cd507ca24">__HSA_WAVEFRONT_SIZE__</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy from an active work-item with higher ID relative to caller within a wavefront. </p>
<p>Work-items may only read data from another work-item which is active in the current wavefront. If the target work-item is inactive, the retrieved value is fixed as 0.</p>
<p>The function calculates a source work-item ID by adding delta from the caller's work-item ID within the wavefront. The value of var held by the resulting lane ID is returned: this has the effect of shifting var up the wavefront by delta work-items. If width is less than <b>HSA_WAVEFRONT_SIZE</b> then each subsection of the wavefront behaves as a separate entity with a starting logical work-item ID of 0. The ID number of the source work-item index will not wrap around the value of width, so the upper delta work-items will remain unchanged.</p>
<p>The optional width parameter must have a value which is a power of 2; results are undefined if it is not a power of 2, or is number greater than <b>HSA_WAVEFRONT_SIZE</b>. </p>

<p>References <a class="el" href="namespacehc.html#ac2b8c020c86085928c96cc3a56b24691">__shfl_down()</a>.</p>

</div>
</div>
<a class="anchor" id="ac2b8c020c86085928c96cc3a56b24691"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float hc::__shfl_down </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>width</em> = <code><a class="el" href="hc_8hpp.html#ab71c5e1746e89bffb56cfa5cd507ca24">__HSA_WAVEFRONT_SIZE__</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy from an active work-item with higher ID relative to caller within a wavefront. </p>
<p>Work-items may only read data from another work-item which is active in the current wavefront. If the target work-item is inactive, the retrieved value is fixed as 0.</p>
<p>The function calculates a source work-item ID by adding delta from the caller's work-item ID within the wavefront. The value of var held by the resulting lane ID is returned: this has the effect of shifting var up the wavefront by delta work-items. If width is less than <b>HSA_WAVEFRONT_SIZE</b> then each subsection of the wavefront behaves as a separate entity with a starting logical work-item ID of 0. The ID number of the source work-item index will not wrap around the value of width, so the upper delta work-items will remain unchanged.</p>
<p>The optional width parameter must have a value which is a power of 2; results are undefined if it is not a power of 2, or is number greater than <b>HSA_WAVEFRONT_SIZE</b>. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa12b5e4f903cb07d4cd8db915fe4e8d6">__shfl_down()</a>.</p>

</div>
</div>
<a class="anchor" id="afb062a5f5d3ede692602a0317470ee51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int hc::__shfl_up </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>width</em> = <code><a class="el" href="hc_8hpp.html#ab71c5e1746e89bffb56cfa5cd507ca24">__HSA_WAVEFRONT_SIZE__</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy from an active work-item with lower ID relative to caller within a wavefront. </p>
<p>Work-items may only read data from another work-item which is active in the current wavefront. If the target work-item is inactive, the retrieved value is fixed as 0.</p>
<p>The function calculates a source work-item ID by subtracting delta from the caller's work-item ID within the wavefront. The value of var held by the resulting lane ID is returned: in effect, var is shifted up the wavefront by delta work-items. If width is less than <b>HSA_WAVEFRONT_SIZE</b> then each subsection of the wavefront behaves as a separate entity with a starting logical work-item ID of 0. The source work-item index will not wrap around the value of width, so effectively the lower delta work-items will be unchanged.</p>
<p>The optional width parameter must have a value which is a power of 2; results are undefined if it is not a power of 2, or is number greater than <b>HSA_WAVEFRONT_SIZE</b>. </p>

<p>References <a class="el" href="namespacehc.html#ae7bd617cc88bef0ebd0a115e98f6a47e">__amdgcn_ds_bpermute()</a>, and <a class="el" href="namespacehc.html#a1ee86debe02dc57b1b597920e0a73a1c">__lane_id()</a>.</p>

</div>
</div>
<a class="anchor" id="aca0b282a4db453d0d3312b851f004889"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__shfl_up </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>width</em> = <code><a class="el" href="hc_8hpp.html#ab71c5e1746e89bffb56cfa5cd507ca24">__HSA_WAVEFRONT_SIZE__</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy from an active work-item with lower ID relative to caller within a wavefront. </p>
<p>Work-items may only read data from another work-item which is active in the current wavefront. If the target work-item is inactive, the retrieved value is fixed as 0.</p>
<p>The function calculates a source work-item ID by subtracting delta from the caller's work-item ID within the wavefront. The value of var held by the resulting lane ID is returned: in effect, var is shifted up the wavefront by delta work-items. If width is less than <b>HSA_WAVEFRONT_SIZE</b> then each subsection of the wavefront behaves as a separate entity with a starting logical work-item ID of 0. The source work-item index will not wrap around the value of width, so effectively the lower delta work-items will be unchanged.</p>
<p>The optional width parameter must have a value which is a power of 2; results are undefined if it is not a power of 2, or is number greater than <b>HSA_WAVEFRONT_SIZE</b>. </p>

<p>References <a class="el" href="namespacehc.html#a36288c8c55dcc69769ec2f50713b61ea">__shfl_up()</a>.</p>

</div>
</div>
<a class="anchor" id="a36288c8c55dcc69769ec2f50713b61ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float hc::__shfl_up </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>width</em> = <code><a class="el" href="hc_8hpp.html#ab71c5e1746e89bffb56cfa5cd507ca24">__HSA_WAVEFRONT_SIZE__</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy from an active work-item with lower ID relative to caller within a wavefront. </p>
<p>Work-items may only read data from another work-item which is active in the current wavefront. If the target work-item is inactive, the retrieved value is fixed as 0.</p>
<p>The function calculates a source work-item ID by subtracting delta from the caller's work-item ID within the wavefront. The value of var held by the resulting lane ID is returned: in effect, var is shifted up the wavefront by delta work-items. If width is less than <b>HSA_WAVEFRONT_SIZE</b> then each subsection of the wavefront behaves as a separate entity with a starting logical work-item ID of 0. The source work-item index will not wrap around the value of width, so effectively the lower delta work-items will be unchanged.</p>
<p>The optional width parameter must have a value which is a power of 2; results are undefined if it is not a power of 2, or is number greater than <b>HSA_WAVEFRONT_SIZE</b>. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aca0b282a4db453d0d3312b851f004889">__shfl_up()</a>.</p>

</div>
</div>
<a class="anchor" id="a4d5476fe3a4689e1d8f4efb446f5b4ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int hc::__shfl_xor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>laneMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code><a class="el" href="hc_8hpp.html#ab71c5e1746e89bffb56cfa5cd507ca24">__HSA_WAVEFRONT_SIZE__</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy from an active work-item based on bitwise XOR of caller work-item ID within a wavefront. </p>
<p>Work-items may only read data from another work-item which is active in the current wavefront. If the target work-item is inactive, the retrieved value is fixed as 0.</p>
<p>THe function calculates a source work-item ID by performing a bitwise XOR of the caller's work-item ID with laneMask: the value of var held by the resulting work-item ID is returned.</p>
<p>The optional width parameter must have a value which is a power of 2; results are undefined if it is not a power of 2, or is number greater than <b>HSA_WAVEFRONT_SIZE</b>. </p>

<p>References <a class="el" href="namespacehc.html#ae7bd617cc88bef0ebd0a115e98f6a47e">__amdgcn_ds_bpermute()</a>, <a class="el" href="namespacehc.html#a1ee86debe02dc57b1b597920e0a73a1c">__lane_id()</a>, and <a class="el" href="namespacehc.html#a4d5476fe3a4689e1d8f4efb446f5b4ed">__shfl_xor()</a>.</p>

<p>Referenced by <a class="el" href="namespacehc.html#a4d5476fe3a4689e1d8f4efb446f5b4ed">__shfl_xor()</a>.</p>

</div>
</div>
<a class="anchor" id="afa554d33a2e4aa842ecbd254f42fb65f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float hc::__shfl_xor </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>laneMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code><a class="el" href="hc_8hpp.html#ab71c5e1746e89bffb56cfa5cd507ca24">__HSA_WAVEFRONT_SIZE__</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy from an active work-item based on bitwise XOR of caller work-item ID within a wavefront. </p>
<p>Work-items may only read data from another work-item which is active in the current wavefront. If the target work-item is inactive, the retrieved value is fixed as 0.</p>
<p>THe function calculates a source work-item ID by performing a bitwise XOR of the caller's work-item ID with laneMask: the value of var held by the resulting work-item ID is returned.</p>
<p>The optional width parameter must have a value which is a power of 2; results are undefined if it is not a power of 2, or is number greater than <b>HSA_WAVEFRONT_SIZE</b>. </p>

<p>References <a class="el" href="hc_8hpp.html#ab71c5e1746e89bffb56cfa5cd507ca24">__HSA_WAVEFRONT_SIZE__</a>, and <a class="el" href="namespacehc.html#a4d5476fe3a4689e1d8f4efb446f5b4ed">__shfl_xor()</a>.</p>

</div>
</div>
<a class="anchor" id="a98052b106b6eea9667cd19b7e9bb71f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float hc::__unpack_f32_f32x2 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the elements specified by src1 from the packed value in src0. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a08889e4ea03eca5f8f1a0f83973da032"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hc::__unpack_s32_s16x2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the elements specified by src1 from the packed value in src0. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a8bcd498c879dc731c3d1696c10c1f5d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hc::__unpack_s32_s16x4 </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the elements specified by src1 from the packed value in src0. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a4dd5f399232544c74be95df91c8bbc84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hc::__unpack_s32_s3x2 </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the elements specified by src1 from the packed value in src0. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a9f4e769cca3f7b9ccbf14af2415d0e7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hc::__unpack_s32_s8x4 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the elements specified by src1 from the packed value in src0. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a37818d9eaf45ecfd6068ce58518179ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hc::__unpack_s32_s8x8 </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the elements specified by src1 from the packed value in src0. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="ad38f5dc8bcae5ad6aa8822a898d684cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__unpack_u32_u16x2 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the elements specified by src1 from the packed value in src0. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="ab936a88a2ee5095d2726124b5abf9e0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__unpack_u32_u16x4 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the elements specified by src1 from the packed value in src0. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a3291dae53730b38e155469772499893a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__unpack_u32_u32x2 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the elements specified by src1 from the packed value in src0. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="aa89504c0311e6ccc0af7bd5998b99b1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__unpack_u32_u8x4 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the elements specified by src1 from the packed value in src0. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="aae064e8de38365d170b75ca2b5c91630"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__unpack_u32_u8x8 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the elements specified by src1 from the packed value in src0. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a398e80d3ecd8163acc99b97ed2a4e699"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float hc::__unpackcvt_f32_u8x4 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unpacks a single element from a packed u8x4 value and converts it to an f32. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/multimedia.htm">HSA PRM 5.15</a> for more detailed specification. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="ac9aa819cac89ce8e050498b6b7d871a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hc::__unpackhi_s16x2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy and interleave the upper half of the elements from each source into the desitionation. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a3fe971dbc1279815910e3f8a7296e04b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t hc::__unpackhi_s16x4 </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>src1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy and interleave the upper half of the elements from each source into the desitionation. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="ad28c8309f3cc71369839b06d43dfe9d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t hc::__unpackhi_s32x2 </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>src1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy and interleave the upper half of the elements from each source into the desitionation. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="ac6c213e05d1139301491527f5eb4d5de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hc::__unpackhi_s8x4 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy and interleave the upper half of the elements from each source into the desitionation. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a7d1d7b458e0641d8ec408aa7cc56eb8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t hc::__unpackhi_s8x8 </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>src1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy and interleave the upper half of the elements from each source into the desitionation. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a922cf3fff83656b785769e349c178960"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__unpackhi_u16x2 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy and interleave the upper half of the elements from each source into the desitionation. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a38241ba7a0072f08e4e6a35edeec8242"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t hc::__unpackhi_u16x4 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>src1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy and interleave the upper half of the elements from each source into the desitionation. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a0b9405bd932d73b6cec17f2dafb03fe0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t hc::__unpackhi_u32x2 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>src1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy and interleave the upper half of the elements from each source into the desitionation. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a3d76bf79cfeec4b886e5e7827bc979dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__unpackhi_u8x4 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy and interleave the upper half of the elements from each source into the desitionation. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a1846a4d2c7867799368ad136fcae43c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t hc::__unpackhi_u8x8 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>src1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy and interleave the upper half of the elements from each source into the desitionation. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a1b2fc5d4b019ca1b2058971d21998972"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hc::__unpacklo_s16x2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy and interleave the lower half of the elements from each source into the desitionation. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a81e7134973ebb73059739023a9c040a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t hc::__unpacklo_s16x4 </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>src1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy and interleave the lower half of the elements from each source into the desitionation. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a524d7a4aa0c87bf1d32d61780394a73b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t hc::__unpacklo_s32x2 </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>src1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy and interleave the lower half of the elements from each source into the desitionation. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a1b7c8cda5a28d0c9bf32308b07d25431"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hc::__unpacklo_s8x4 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy and interleave the lower half of the elements from each source into the desitionation. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="afc6eeec8da4ad7af7775dca688aa3a5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t hc::__unpacklo_s8x8 </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>src1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy and interleave the lower half of the elements from each source into the desitionation. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a198ca447a0f8c664706332c5d6855ea9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__unpacklo_u16x2 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy and interleave the lower half of the elements from each source into the desitionation. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="aba1ffe2751b1462b5dc4d7814f718f8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t hc::__unpacklo_u16x4 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>src1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy and interleave the lower half of the elements from each source into the desitionation. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="ac115a01fcebfbc8cef346363a89f7807"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t hc::__unpacklo_u32x2 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>src1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy and interleave the lower half of the elements from each source into the desitionation. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a1c352973da30d1e147c499519d1e6f82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::__unpacklo_u8x4 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy and interleave the lower half of the elements from each source into the desitionation. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a2b3047ffa8f9223ec5a798462eb1b9a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t hc::__unpacklo_u8x8 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>src1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy and interleave the lower half of the elements from each source into the desitionation. </p>
<p>Please refer to <a href="http://www.hsafoundation.com/html/Content/PRM/Topics/05_Arithmetic/packed_data.htm">HSA PRM 5.9</a> for more detailed specification of these functions. </p>

<p>Referenced by <a class="el" href="namespacehc.html#aa72edf96f4a16e7a02c5463e9b2d11b7">__lastbit_u32_s64()</a>.</p>

</div>
</div>
<a class="anchor" id="a76d96b992f50f35a84598b4a0e98d26b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hc::all_memory_fence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1tile__barrier.html">tile_barrier</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a thread-tile scoped memory fence for both global and tile-static memory operations. </p>
<p>This function does not imply a barrier and is therefore permitted in divergent code. </p>

<p>Referenced by <a class="el" href="classhc_1_1tile__barrier.html#a65f19da07bb613ddfd3171540a576208">hc::tile_barrier::wait_with_tile_static_memory_fence()</a>.</p>

</div>
</div>
<a class="anchor" id="aac045d9e161761a2f6f4c23e85783841"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto__voidp.html">auto_voidp</a> hc::am_aligned_alloc </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhc_1_1accelerator.html">hc::accelerator</a> &amp;&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>alignment</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a block of <code>size</code> bytes of memory on the specified <code>acc</code>. </p>
<p>The contents of the newly allocated block of memory are not initialized.</p>
<p>If <code>size</code> == 0, 0 is returned.</p>
<p>Flags: amHostPinned : Allocated pinned host memory and map it into the address space of the specified accelerator.</p>
<dl class="section return"><dt>Returns</dt><dd>: On success, pointer to the newly allocated memory is returned. The pointer is typecast to the desired return type.</dd></dl>
<p>If an error occurred trying to allocate the requested memory, 0 is returned.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacehc.html#a860681199cb960b9786dd39350fddbad" title="Free a block of memory previously allocated with am_alloc. ">am_free</a>, am_copy </dd></dl>

</div>
</div>
<a class="anchor" id="af27438ff723607db97264d499bb159ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto__voidp.html">auto_voidp</a> hc::am_alloc </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhc_1_1accelerator.html">hc::accelerator</a> &amp;&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a block of <code>size</code> bytes of memory on the specified <code>acc</code>. </p>
<p>The contents of the newly allocated block of memory are not initialized.</p>
<p>If <code>size</code> == 0, 0 is returned.</p>
<p>Flags: amHostPinned : Allocated pinned host memory and map it into the address space of the specified accelerator.</p>
<dl class="section return"><dt>Returns</dt><dd>: On success, pointer to the newly allocated memory is returned. The pointer is typecast to the desired return type.</dd></dl>
<p>If an error occurred trying to allocate the requested memory, 0 is returned.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacehc.html#a860681199cb960b9786dd39350fddbad" title="Free a block of memory previously allocated with am_alloc. ">am_free</a>, am_copy </dd></dl>

</div>
</div>
<a class="anchor" id="a860681199cb960b9786dd39350fddbad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">am_status_t hc::am_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a block of memory previously allocated with am_alloc. </p>
<dl class="section return"><dt>Returns</dt><dd>AM_SUCCESS </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacehc.html#af27438ff723607db97264d499bb159ff" title="Allocate a block of size bytes of memory on the specified acc. ">am_alloc</a>, am_copy </dd></dl>

</div>
</div>
<a class="anchor" id="a144a13f65f39ce2970a2dbfdfaabbe28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hc::atomic_compare_exchange </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>expected_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These functions attempt to perform these three steps atomically: </p>
<ol type="1">
<li>Read the value stored in the location pointed to by dest</li>
<li>Compare the value read in the previous step with the value contained in the location pointed by expected_val</li>
<li>Carry the following operations depending on the result of the comparison of the previous step: a. If the values are identical, then the function tries to atomically change the value pointed by dest to the value in val. The function indicates by its return value whether this transformation has been successful or not. b. If the values are not identical, then the function stores the value read in step (1) into the location pointed to by expected_val, and returns false.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">expected_val</td><td>A pointer to a local variable or function parameter. Upon calling the function, the location pointed by expected_val contains the value the caller expects dest to contain. Upon return from the function, expected_val will contain the most recent value read from dest. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The new value to be stored in the location pointed to be dest </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value indicates whether the function has been successful in atomically reading, comparing and modifying the contents of the memory location. </dd></dl>

</div>
</div>
<a class="anchor" id="a94caf1e8bdd84fc1561b114d3b16edc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hc::atomic_compare_exchange </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>expected_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These functions attempt to perform these three steps atomically: </p>
<ol type="1">
<li>Read the value stored in the location pointed to by dest</li>
<li>Compare the value read in the previous step with the value contained in the location pointed by expected_val</li>
<li>Carry the following operations depending on the result of the comparison of the previous step: a. If the values are identical, then the function tries to atomically change the value pointed by dest to the value in val. The function indicates by its return value whether this transformation has been successful or not. b. If the values are not identical, then the function stores the value read in step (1) into the location pointed to by expected_val, and returns false.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">expected_val</td><td>A pointer to a local variable or function parameter. Upon calling the function, the location pointed by expected_val contains the value the caller expects dest to contain. Upon return from the function, expected_val will contain the most recent value read from dest. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The new value to be stored in the location pointed to be dest </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value indicates whether the function has been successful in atomically reading, comparing and modifying the contents of the memory location. </dd></dl>

</div>
</div>
<a class="anchor" id="acf212d3d5c87ebcf8f76db5fdf52247e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hc::atomic_compare_exchange </td>
          <td>(</td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>expected_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These functions attempt to perform these three steps atomically: </p>
<ol type="1">
<li>Read the value stored in the location pointed to by dest</li>
<li>Compare the value read in the previous step with the value contained in the location pointed by expected_val</li>
<li>Carry the following operations depending on the result of the comparison of the previous step: a. If the values are identical, then the function tries to atomically change the value pointed by dest to the value in val. The function indicates by its return value whether this transformation has been successful or not. b. If the values are not identical, then the function stores the value read in step (1) into the location pointed to by expected_val, and returns false.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">expected_val</td><td>A pointer to a local variable or function parameter. Upon calling the function, the location pointed by expected_val contains the value the caller expects dest to contain. Upon return from the function, expected_val will contain the most recent value read from dest. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The new value to be stored in the location pointed to be dest </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value indicates whether the function has been successful in atomically reading, comparing and modifying the contents of the memory location. </dd></dl>

<p>Referenced by <a class="el" href="namespacehc.html#abfca81adfdf1af6f9724114f095b3d5b">copy_async()</a>.</p>

</div>
</div>
<a class="anchor" id="ab3b10c0076f2ec59ae99dbd532a2bc31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::atomic_exchange </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest , replace it with the value given in val and return the old value to the caller. </p>
<p>This function provides overloads for int , unsigned int and float parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>A pointer to the location which needs to be atomically modified. The location may reside within a <a class="el" href="classhc_1_1array.html" title="Represents an N-dimensional region of memory (with type T) located on an accelerator. ">hc::array</a> or <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">hc::array_view</a> or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The new value to be stored in the location pointed to be dest </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

</div>
</div>
<a class="anchor" id="adbdad78734bea33c98f111e543932d00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hc::atomic_exchange </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest , replace it with the value given in val and return the old value to the caller. </p>
<p>This function provides overloads for int , unsigned int and float parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>A pointer to the location which needs to be atomically modified. The location may reside within a <a class="el" href="classhc_1_1array.html" title="Represents an N-dimensional region of memory (with type T) located on an accelerator. ">hc::array</a> or <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">hc::array_view</a> or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The new value to be stored in the location pointed to be dest </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

</div>
</div>
<a class="anchor" id="a4c28a7a010d35956ed009b7c1b39428c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float hc::atomic_exchange </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest , replace it with the value given in val and return the old value to the caller. </p>
<p>This function provides overloads for int , unsigned int and float parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>A pointer to the location which needs to be atomically modified. The location may reside within a <a class="el" href="classhc_1_1array.html" title="Represents an N-dimensional region of memory (with type T) located on an accelerator. ">hc::array</a> or <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">hc::array_view</a> or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The new value to be stored in the location pointed to be dest </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

</div>
</div>
<a class="anchor" id="a815fe01bcd422a1308da8141a71b62fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t hc::atomic_exchange </td>
          <td>(</td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest , replace it with the value given in val and return the old value to the caller. </p>
<p>This function provides overloads for int , unsigned int and float parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>A pointer to the location which needs to be atomically modified. The location may reside within a <a class="el" href="classhc_1_1array.html" title="Represents an N-dimensional region of memory (with type T) located on an accelerator. ">hc::array</a> or <a class="el" href="classhc_1_1array__view.html" title="The array_view&lt;T,N&gt; type represents a possibly cached view into the data held in an array&lt;T...">hc::array_view</a> or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The new value to be stored in the location pointed to be dest </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

<p>Referenced by <a class="el" href="namespacehc.html#abfca81adfdf1af6f9724114f095b3d5b">copy_async()</a>.</p>

</div>
</div>
<a class="anchor" id="a274ea927e0ba3eb9521d34d0541c5e23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned hc::atomic_fetch_add </td>
          <td>(</td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

</div>
</div>
<a class="anchor" id="aabde5a5c761fca9180c68ff0b67581d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hc::atomic_fetch_add </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

</div>
</div>
<a class="anchor" id="a79fafe40b108fe9caeef41dc3ab48732"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float hc::atomic_fetch_add </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

</div>
</div>
<a class="anchor" id="acb7e8685fa0f0cf7e510f2f90c01a618"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t hc::atomic_fetch_add </td>
          <td>(</td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

<p>Referenced by <a class="el" href="namespacehc.html#abfca81adfdf1af6f9724114f095b3d5b">copy_async()</a>.</p>

</div>
</div>
<a class="anchor" id="adb737efa9cd1dc6a87ff5655b854733b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned hc::atomic_fetch_and </td>
          <td>(</td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

</div>
</div>
<a class="anchor" id="aaf091f060490c4b7b75b4989c5b2eb90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hc::atomic_fetch_and </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

</div>
</div>
<a class="anchor" id="a0a7fdf2ecbb55fb48868a674ea9280da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t hc::atomic_fetch_and </td>
          <td>(</td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

<p>Referenced by <a class="el" href="namespacehc.html#abfca81adfdf1af6f9724114f095b3d5b">copy_async()</a>.</p>

</div>
</div>
<a class="anchor" id="a25d570ab3c664db5060363371c026363"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hc::atomic_fetch_dec </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>_Dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically increment or decrement the value stored at the location point to by dest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

</div>
</div>
<a class="anchor" id="ae6cf3f5c4655e0bcf79cbf6165d9387c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::atomic_fetch_dec </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>_Dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically increment or decrement the value stored at the location point to by dest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

<p>Referenced by <a class="el" href="namespacehc.html#abfca81adfdf1af6f9724114f095b3d5b">copy_async()</a>.</p>

</div>
</div>
<a class="anchor" id="a259d458ddd17fead0d7f045c7f263ed7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hc::atomic_fetch_inc </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>_Dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically increment or decrement the value stored at the location point to by dest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

</div>
</div>
<a class="anchor" id="af1ff2db87bcd5d43a44b8f424fb9d9c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::atomic_fetch_inc </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>_Dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically increment or decrement the value stored at the location point to by dest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

<p>Referenced by <a class="el" href="namespacehc.html#abfca81adfdf1af6f9724114f095b3d5b">copy_async()</a>.</p>

</div>
</div>
<a class="anchor" id="ad2c53a9bc13395910d0cfdf9fef0da8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hc::atomic_fetch_max </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

</div>
</div>
<a class="anchor" id="a3281bc15a0ff64de897db8b0c6a147f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::atomic_fetch_max </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

</div>
</div>
<a class="anchor" id="af34220f1ab2503aaace02ade8004334a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t hc::atomic_fetch_max </td>
          <td>(</td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

<p>Referenced by <a class="el" href="namespacehc.html#abfca81adfdf1af6f9724114f095b3d5b">copy_async()</a>.</p>

</div>
</div>
<a class="anchor" id="abd4eb2bb27caa8f01c7a082da18a29d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hc::atomic_fetch_min </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

</div>
</div>
<a class="anchor" id="a5bf3e399f98b3572126cb7e3d2a6468a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::atomic_fetch_min </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

</div>
</div>
<a class="anchor" id="a480e9a1dda252ce5065dde830b7307ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t hc::atomic_fetch_min </td>
          <td>(</td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

<p>Referenced by <a class="el" href="namespacehc.html#abfca81adfdf1af6f9724114f095b3d5b">copy_async()</a>.</p>

</div>
</div>
<a class="anchor" id="a87b97170bf81283b8a7b5ea321ce3164"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned hc::atomic_fetch_or </td>
          <td>(</td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

</div>
</div>
<a class="anchor" id="a977ffea3db3f8e01dffbb4449466db9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hc::atomic_fetch_or </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

</div>
</div>
<a class="anchor" id="a06889dba9386dfc367eae859cb344374"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t hc::atomic_fetch_or </td>
          <td>(</td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

<p>Referenced by <a class="el" href="namespacehc.html#abfca81adfdf1af6f9724114f095b3d5b">copy_async()</a>.</p>

</div>
</div>
<a class="anchor" id="aed9dc4efa51d801fd5d9c057f654a94e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned hc::atomic_fetch_sub </td>
          <td>(</td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

</div>
</div>
<a class="anchor" id="a33be363818e6509bf74a890f633a7ad1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hc::atomic_fetch_sub </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

</div>
</div>
<a class="anchor" id="aff7764569f1dacdec25734280a3ca917"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float hc::atomic_fetch_sub </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

<p>Referenced by <a class="el" href="namespacehc.html#abfca81adfdf1af6f9724114f095b3d5b">copy_async()</a>.</p>

</div>
</div>
<a class="anchor" id="a49819dea09766b5c352ba77e9e414351"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned hc::atomic_fetch_xor </td>
          <td>(</td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

</div>
</div>
<a class="anchor" id="abd2a337d195d0e31ee4104cf89e36586"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hc::atomic_fetch_xor </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

</div>
</div>
<a class="anchor" id="a048ff814e41a1bc4f4381d87df880d0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t hc::atomic_fetch_xor </td>
          <td>(</td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically read the value stored in dest, apply the binary numerical operation specific to the function with the read value and val serving as input operands, and store the result back to the location pointed by dest. </p>
<p>In terms of sequential semantics, the operation performed by any of the above function is described by the following piece of pseudo-code:</p>
<p>*dest = *dest <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> val;</p>
<p>Where the operation denoted by <img class="formulaInl" alt="$\otimes$" src="form_2.png"/> is one of: addition (atomic_fetch_add), subtraction (atomic_fetch_sub), find maximum (atomic_fetch_max), find minimum (atomic_fetch_min), bit-wise AND (atomic_fetch_and), bit-wise OR (atomic_fetch_or), bit-wise XOR (atomic_fetch_xor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An pointer to the location which needs to be atomically modified. The location may reside within a concurrency::array or concurrency::array_view or within a tile_static variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The second operand which participates in the calculation of the binary operation whose result is stored into the location pointed to be dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These functions return the old value which was previously stored at dest, and that was atomically replaced. These functions always succeed. </dd></dl>

<p>Referenced by <a class="el" href="namespacehc.html#abfca81adfdf1af6f9724114f095b3d5b">copy_async()</a>.</p>

</div>
</div>
<a class="anchor" id="aa475300aad804b607f74f86de266a2b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hc::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; const T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array_view&lt;T,N&gt; (or <a class="el" href="classhc_1_1array__view_3_01const_01T_00_01N_01_4.html" title="The partial specialization array_view&lt;const T,N&gt; represents a view over elements of type const T with...">array_view&lt;const T, N&gt;</a>) to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array_view&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classhc_1_1array__view.html#aeb513133615616bad75ee61aec8f2f5d">hc::array_view&lt; T, N &gt;::get_extent()</a>.</p>

</div>
</div>
<a class="anchor" id="a754f84098173418069020cd34da33be6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hc::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array_view&lt;T,N&gt; (or <a class="el" href="classhc_1_1array__view_3_01const_01T_00_01N_01_4.html" title="The partial specialization array_view&lt;const T,N&gt; represents a view over elements of type const T with...">array_view&lt;const T, N&gt;</a>) to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array_view&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespacehc.html#a33b400529b72d0e9c26c4b9083e2d681">copy()</a>.</p>

</div>
</div>
<a class="anchor" id="a3b37a30d5090d17acba67652635182ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hc::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array&lt;T,N&gt; to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array_view&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classhc_1_1array__view.html#aeb513133615616bad75ee61aec8f2f5d">hc::array_view&lt; T, N &gt;::get_extent()</a>.</p>

</div>
</div>
<a class="anchor" id="a54e59f3d3f5f72ca01b81e9e1bccf92f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hc::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>The source and destination may reside on different accelerators. If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array&lt;T,N&gt; to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a05652136ace69ed76a177983a1cdef45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hc::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; const T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array_view&lt;T,N&gt; (or <a class="el" href="classhc_1_1array__view_3_01const_01T_00_01N_01_4.html" title="The partial specialization array_view&lt;const T,N&gt; represents a view over elements of type const T with...">array_view&lt;const T, N&gt;</a>) to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classhc_1_1array.html#a81381e99ff73f2314e2c32a5f196aa6a">hc::array&lt; T, N &gt;::get_extent()</a>.</p>

</div>
</div>
<a class="anchor" id="a89cd26765005205fa62a0f7f692f00fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hc::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array_view&lt;T,N&gt; (or <a class="el" href="classhc_1_1array__view_3_01const_01T_00_01N_01_4.html" title="The partial specialization array_view&lt;const T,N&gt; represents a view over elements of type const T with...">array_view&lt;const T, N&gt;</a>) to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespacehc.html#a33b400529b72d0e9c26c4b9083e2d681">copy()</a>.</p>

</div>
</div>
<a class="anchor" id="aae5de40faeaa7e8737f0fc7c1a054c78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIter , typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hc::copy </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>srcBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>srcEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest". </p>
<p>If the number of elements in the iterator range is not equal to "dest.extent.size()", an exception is thrown.</p>
<p>In the overloads which don't take an end-iterator it is assumed that the source iterator is able to provide at least dest.extent.size() elements, but no checking is performed (nor possible).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBegin</td><td>An iterator to the first element of a source container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcEnd</td><td>An interator to the end of a source container. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array_view&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6f8b9ccbe0fead355a79d4eb81d076ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIter , typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hc::copy </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>srcBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>srcEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest". </p>
<p>If the number of elements in the iterator range is not equal to "dest.extent.size()", an exception is thrown.</p>
<p>In the overloads which don't take an end-iterator it is assumed that the source iterator is able to provide at least dest.extent.size() elements, but no checking is performed (nor possible).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBegin</td><td>An iterator to the first element of a source container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcEnd</td><td>An interator to the end of a source container. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classhc_1_1array.html#a81381e99ff73f2314e2c32a5f196aa6a">hc::array&lt; T, N &gt;::get_extent()</a>.</p>

</div>
</div>
<a class="anchor" id="a9c5da881f88351946b9c26e3485d278b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIter , typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hc::copy </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>srcBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest". </p>
<p>If the number of elements in the iterator range is not equal to "dest.extent.size()", an exception is thrown.</p>
<p>In the overloads which don't take an end-iterator it is assumed that the source iterator is able to provide at least dest.extent.size() elements, but no checking is performed (nor possible).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBegin</td><td>An iterator to the first element of a source container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcEnd</td><td>An interator to the end of a source container. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array_view&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespacehc.html#a33b400529b72d0e9c26c4b9083e2d681">copy()</a>, and <a class="el" href="classhc_1_1array__view.html#aeb513133615616bad75ee61aec8f2f5d">hc::array_view&lt; T, N &gt;::get_extent()</a>.</p>

</div>
</div>
<a class="anchor" id="ae38b2c139229fdb0935fdb9b71a323a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIter , typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hc::copy </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>srcBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest". </p>
<p>If the number of elements in the iterator range is not equal to "dest.extent.size()", an exception is thrown.</p>
<p>In the overloads which don't take an end-iterator it is assumed that the source iterator is able to provide at least dest.extent.size() elements, but no checking is performed (nor possible).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBegin</td><td>An iterator to the first element of a source container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcEnd</td><td>An interator to the end of a source container. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespacehc.html#a33b400529b72d0e9c26c4b9083e2d681">copy()</a>, and <a class="el" href="classhc_1_1array.html#a81381e99ff73f2314e2c32a5f196aa6a">hc::array&lt; T, N &gt;::get_extent()</a>.</p>

</div>
</div>
<a class="anchor" id="a5fc1fb2ba55b46d9b3456fc7c5456e7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputIter , typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hc::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIter&#160;</td>
          <td class="paramname"><em>destBegin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of a source array are copied into "dest" starting with iterator destBegin. </p>
<p>If the number of elements in the range starting destBegin in the destination container is smaller than "src.extent.size()", the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array_view&lt;T,N&gt; to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destBegin</td><td>An output iterator addressing the position of the first element in the destination container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2e1434fa4cb5b5c60ed2a302ec0837f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputIter , typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hc::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIter&#160;</td>
          <td class="paramname"><em>destBegin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of a source array are copied into "dest" starting with iterator destBegin. </p>
<p>If the number of elements in the range starting destBegin in the destination container is smaller than "src.extent.size()", the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array&lt;T,N&gt; to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destBegin</td><td>An output iterator addressing the position of the first element in the destination container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abc44d4113d75572503077bb07ba08362"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hc::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array.html">array</a>&lt; T, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array&lt;T,N&gt; to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array_view&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classhc_1_1array__view.html#aeb513133615616bad75ee61aec8f2f5d">hc::array_view&lt; T, N &gt;::get_extent()</a>.</p>

</div>
</div>
<a class="anchor" id="a7ed609690ebe1915a9773d67e2d4862e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hc::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; const T, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhc_1_1array.html">array</a>&lt; T, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array_view&lt;T,N&gt; (or <a class="el" href="classhc_1_1array__view_3_01const_01T_00_01N_01_4.html" title="The partial specialization array_view&lt;const T,N&gt; represents a view over elements of type const T with...">array_view&lt;const T, N&gt;</a>) to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classhc_1_1array.html#a81381e99ff73f2314e2c32a5f196aa6a">hc::array&lt; T, N &gt;::get_extent()</a>.</p>

</div>
</div>
<a class="anchor" id="a33b400529b72d0e9c26c4b9083e2d681"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hc::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; const T, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array_view&lt;T,N&gt; (or <a class="el" href="classhc_1_1array__view_3_01const_01T_00_01N_01_4.html" title="The partial specialization array_view&lt;const T,N&gt; represents a view over elements of type const T with...">array_view&lt;const T, N&gt;</a>) to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array_view&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classhc_1_1array__view.html#aeb513133615616bad75ee61aec8f2f5d">hc::array_view&lt; T, N &gt;::get_extent()</a>.</p>

<p>Referenced by <a class="el" href="classhc_1_1array.html#acd2e1485261e542906dd64034e90f2e7">hc::array&lt; T, N &gt;::array()</a>, <a class="el" href="namespacehc.html#a89cd26765005205fa62a0f7f692f00fc">copy()</a>, <a class="el" href="namespacehc.html#a19c4d08885e472810f7dab21e5c44a1c">copy_async()</a>, <a class="el" href="classhc_1_1array.html#a72f836ba50899147d2300ba291fc8f7a">hc::array&lt; T, N &gt;::copy_to()</a>, <a class="el" href="classhc_1_1array__view.html#a48c9bbd83803a522396c077c35ba33cb">hc::array_view&lt; T, N &gt;::copy_to()</a>, <a class="el" href="classhc_1_1array__view_3_01const_01T_00_01N_01_4.html#ace776d97239cba8a63c1938a9d45ada8">hc::array_view&lt; const T, N &gt;::copy_to()</a>, <a class="el" href="classhc_1_1array.html#aa6b1bba0704d6351d06ec7a773c98b69">hc::array&lt; T, N &gt;::operator std::vector&lt; T &gt;()</a>, <a class="el" href="classhc_1_1array.html#a18e9893385151138f09d1ada3add6732">hc::array&lt; T, N &gt;::view_as()</a>, <a class="el" href="classhc_1_1array__view.html#adea0281f34efd256986e1692613b43fd">hc::array_view&lt; T, N &gt;::view_as()</a>, and <a class="el" href="classhc_1_1array__view_3_01const_01T_00_01N_01_4.html#a7e1841a2460d69438e9b57702c62b46c">hc::array_view&lt; const T, N &gt;::view_as()</a>.</p>

</div>
</div>
<a class="anchor" id="a19c4d08885e472810f7dab21e5c44a1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1completion__future.html">completion_future</a> hc::copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>The source and destination may reside on different accelerators. If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array&lt;T,N&gt; to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespacehc.html#a33b400529b72d0e9c26c4b9083e2d681">copy()</a>.</p>

</div>
</div>
<a class="anchor" id="a9e7285314bc81e56f1fc641f1e33efc8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1completion__future.html">completion_future</a> hc::copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array&lt;T,N&gt; to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array_view&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespacehc.html#a33b400529b72d0e9c26c4b9083e2d681">copy()</a>.</p>

</div>
</div>
<a class="anchor" id="a2cc6fbd8ba2c9341e800c124348566d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1completion__future.html">completion_future</a> hc::copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; const T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array_view&lt;T,N&gt; (or <a class="el" href="classhc_1_1array__view_3_01const_01T_00_01N_01_4.html" title="The partial specialization array_view&lt;const T,N&gt; represents a view over elements of type const T with...">array_view&lt;const T, N&gt;</a>) to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespacehc.html#a33b400529b72d0e9c26c4b9083e2d681">copy()</a>.</p>

</div>
</div>
<a class="anchor" id="a8c2ec164e3dfd5513688772498fc4e4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1completion__future.html">completion_future</a> hc::copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array_view&lt;T,N&gt; (or <a class="el" href="classhc_1_1array__view_3_01const_01T_00_01N_01_4.html" title="The partial specialization array_view&lt;const T,N&gt; represents a view over elements of type const T with...">array_view&lt;const T, N&gt;</a>) to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespacehc.html#a33b400529b72d0e9c26c4b9083e2d681">copy()</a>.</p>

</div>
</div>
<a class="anchor" id="a0a9eee4d952b2e2ad6098686dea61619"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1completion__future.html">completion_future</a> hc::copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; const T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array_view&lt;T,N&gt; (or <a class="el" href="classhc_1_1array__view_3_01const_01T_00_01N_01_4.html" title="The partial specialization array_view&lt;const T,N&gt; represents a view over elements of type const T with...">array_view&lt;const T, N&gt;</a>) to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array_view&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespacehc.html#a33b400529b72d0e9c26c4b9083e2d681">copy()</a>.</p>

</div>
</div>
<a class="anchor" id="a6846df06fc19ef5989afdd9cc683f514"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1completion__future.html">completion_future</a> hc::copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of "src" are copied into "dest". </p>
<p>If the extents of "src" and "dest" don't match, a runtime exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array_view&lt;T,N&gt; (or <a class="el" href="classhc_1_1array__view_3_01const_01T_00_01N_01_4.html" title="The partial specialization array_view&lt;const T,N&gt; represents a view over elements of type const T with...">array_view&lt;const T, N&gt;</a>) to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array_view&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespacehc.html#a33b400529b72d0e9c26c4b9083e2d681">copy()</a>.</p>

</div>
</div>
<a class="anchor" id="a4c7f44927641a2cb0f3af03cbbb7bfc1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIter , typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1completion__future.html">completion_future</a> hc::copy_async </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>srcBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>srcEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest". </p>
<p>If the number of elements in the iterator range is not equal to "dest.extent.size()", an exception is thrown.</p>
<p>In the overloads which don't take an end-iterator it is assumed that the source iterator is able to provide at least dest.extent.size() elements, but no checking is performed (nor possible).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBegin</td><td>An iterator to the first element of a source container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcEnd</td><td>An interator to the end of a source container. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespacehc.html#a33b400529b72d0e9c26c4b9083e2d681">copy()</a>.</p>

</div>
</div>
<a class="anchor" id="a1f81bd4317a53fd880de223079561667"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIter , typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1completion__future.html">completion_future</a> hc::copy_async </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>srcBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest". </p>
<p>If the number of elements in the iterator range is not equal to "dest.extent.size()", an exception is thrown.</p>
<p>In the overloads which don't take an end-iterator it is assumed that the source iterator is able to provide at least dest.extent.size() elements, but no checking is performed (nor possible).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBegin</td><td>An iterator to the first element of a source container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcEnd</td><td>An interator to the end of a source container. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespacehc.html#a33b400529b72d0e9c26c4b9083e2d681">copy()</a>.</p>

</div>
</div>
<a class="anchor" id="abf01554001426ff112473a5e6843b454"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIter , typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1completion__future.html">completion_future</a> hc::copy_async </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>srcBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>srcEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest". </p>
<p>If the number of elements in the iterator range is not equal to "dest.extent.size()", an exception is thrown.</p>
<p>In the overloads which don't take an end-iterator it is assumed that the source iterator is able to provide at least dest.extent.size() elements, but no checking is performed (nor possible).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBegin</td><td>An iterator to the first element of a source container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcEnd</td><td>An interator to the end of a source container. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array_view&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespacehc.html#a33b400529b72d0e9c26c4b9083e2d681">copy()</a>.</p>

</div>
</div>
<a class="anchor" id="aa245b722b9ce411c62e781fb4a171de2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIter , typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1completion__future.html">completion_future</a> hc::copy_async </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>srcBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of a source container from the iterator range [srcBegin,srcEnd) are copied into "dest". </p>
<p>If the number of elements in the iterator range is not equal to "dest.extent.size()", an exception is thrown.</p>
<p>In the overloads which don't take an end-iterator it is assumed that the source iterator is able to provide at least dest.extent.size() elements, but no checking is performed (nor possible).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBegin</td><td>An iterator to the first element of a source container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcEnd</td><td>An interator to the end of a source container. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>An object of type array_view&lt;T,N&gt; to be copied to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespacehc.html#a33b400529b72d0e9c26c4b9083e2d681">copy()</a>.</p>

</div>
</div>
<a class="anchor" id="a2ac2ad6f6af293f315ccf83843d5338f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputIter , typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1completion__future.html">completion_future</a> hc::copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIter&#160;</td>
          <td class="paramname"><em>destBegin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of a source array are copied into "dest" starting with iterator destBegin. </p>
<p>If the number of elements in the range starting destBegin in the destination container is smaller than "src.extent.size()", the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array&lt;T,N&gt; to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destBegin</td><td>An output iterator addressing the position of the first element in the destination container. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespacehc.html#a33b400529b72d0e9c26c4b9083e2d681">copy()</a>.</p>

</div>
</div>
<a class="anchor" id="abfca81adfdf1af6f9724114f095b3d5b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputIter , typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1completion__future.html">completion_future</a> hc::copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1array__view.html">array_view</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIter&#160;</td>
          <td class="paramname"><em>destBegin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The contents of a source array are copied into "dest" starting with iterator destBegin. </p>
<p>If the number of elements in the range starting destBegin in the destination container is smaller than "src.extent.size()", the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>An object of type array_view&lt;T,N&gt; to be copied from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destBegin</td><td>An output iterator addressing the position of the first element in the destination container. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespacehc.html#aa01f045e1ab6336e7776d3bbdadb65bc">__atomic_wrapdec()</a>, <a class="el" href="namespacehc.html#adbc6976a1ea23546bbf65ecb4cd2caa8">__atomic_wrapinc()</a>, <a class="el" href="namespacehc.html#acf212d3d5c87ebcf8f76db5fdf52247e">atomic_compare_exchange()</a>, <a class="el" href="namespacehc.html#a815fe01bcd422a1308da8141a71b62fc">atomic_exchange()</a>, <a class="el" href="namespacehc.html#acb7e8685fa0f0cf7e510f2f90c01a618">atomic_fetch_add()</a>, <a class="el" href="namespacehc.html#a0a7fdf2ecbb55fb48868a674ea9280da">atomic_fetch_and()</a>, <a class="el" href="namespacehc.html#ae6cf3f5c4655e0bcf79cbf6165d9387c">atomic_fetch_dec()</a>, <a class="el" href="namespacehc.html#af1ff2db87bcd5d43a44b8f424fb9d9c9">atomic_fetch_inc()</a>, <a class="el" href="namespacehc.html#af34220f1ab2503aaace02ade8004334a">atomic_fetch_max()</a>, <a class="el" href="namespacehc.html#a480e9a1dda252ce5065dde830b7307ca">atomic_fetch_min()</a>, <a class="el" href="namespacehc.html#a06889dba9386dfc367eae859cb344374">atomic_fetch_or()</a>, <a class="el" href="namespacehc.html#aff7764569f1dacdec25734280a3ca917">atomic_fetch_sub()</a>, <a class="el" href="namespacehc.html#a048ff814e41a1bc4f4381d87df880d0f">atomic_fetch_xor()</a>, and <a class="el" href="namespacehc.html#a33b400529b72d0e9c26c4b9083e2d681">copy()</a>.</p>

</div>
</div>
<a class="anchor" id="a10d125c77255cf875e818f574fd6255d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::get_group_segment_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the size of group segment. </p>
<p>This includes both static group segment and dynamic group segment.</p>
<dl class="section return"><dt>Returns</dt><dd>The size of group segment used by the kernel in bytes. The value includes both static group segment and dynamic group segment. </dd></dl>

<p>Referenced by <a class="el" href="namespacehc.html#aec3ff833b8dfd488fe9f29cfb29c1334">__mad24()</a>.</p>

</div>
</div>
<a class="anchor" id="a8ad0b4e17bb8c7c73107b5d9b383a2d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hc::get_static_group_segment_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the size of static group segment. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of static group segment used by the kernel in bytes. </dd></dl>

<p>Referenced by <a class="el" href="namespacehc.html#aec3ff833b8dfd488fe9f29cfb29c1334">__mad24()</a>.</p>

</div>
</div>
<a class="anchor" id="af20faf82c2dbdd0030c10a6f0984a2a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t hc::get_system_ticks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current tick count for the GPU platform. </p>
<dl class="section return"><dt>Returns</dt><dd>An implementation-defined tick count </dd></dl>

</div>
</div>
<a class="anchor" id="ab206a54bb54ac1169e26f46034110938"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t hc::get_tick_frequency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the frequency of ticks per second for the underlying asynchrnous operation. </p>
<dl class="section return"><dt>Returns</dt><dd>An implementation-defined frequency in Hz in case the instance is created by a kernel dispatch or a barrier packet. 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a60fb6bc2cb74e9120b6d444ea0dbf125"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hc::global_memory_fence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1tile__barrier.html">tile_barrier</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a thread-tile scoped memory fence for global (but not tile-static) memory operations. </p>
<p>This function does not imply a barrier and is therefore permitted in divergent code. </p>

<p>Referenced by <a class="el" href="classhc_1_1tile__barrier.html#a65f19da07bb613ddfd3171540a576208">hc::tile_barrier::wait_with_tile_static_memory_fence()</a>.</p>

</div>
</div>
<a class="anchor" id="ac97a24725253fb9cd8c6dc906ac1deac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1extent.html">extent</a>&lt;N&gt; hc::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands. </p>
<p>The result extent&lt;N&gt; is such that for a given operator <img class="formulaInl" alt="$\oplus$" src="form_1.png"/>, result[i] = ext[i] <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> value or result[i] = value <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> ext[i] for every i from 0 to N-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ext</td><td>The extent&lt;N&gt; operand </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The integer operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4756e26a413eed7b072c76a16d5cb283"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1extent.html">extent</a>&lt;N&gt; hc::operator% </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>ext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands. </p>
<p>The result extent&lt;N&gt; is such that for a given operator <img class="formulaInl" alt="$\oplus$" src="form_1.png"/>, result[i] = ext[i] <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> value or result[i] = value <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> ext[i] for every i from 0 to N-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ext</td><td>The extent&lt;N&gt; operand </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The integer operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9d71e064695bdbaa607737fb7136af86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1extent.html">extent</a>&lt;N&gt; hc::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands. </p>
<p>The result extent&lt;N&gt; is such that for a given operator <img class="formulaInl" alt="$\oplus$" src="form_1.png"/>, result[i] = ext[i] <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> value or result[i] = value <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> ext[i] for every i from 0 to N-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ext</td><td>The extent&lt;N&gt; operand </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The integer operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3f515e67671ea7683322f90a73ce07f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1extent.html">extent</a>&lt;N&gt; hc::operator* </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>ext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands. </p>
<p>The result extent&lt;N&gt; is such that for a given operator <img class="formulaInl" alt="$\oplus$" src="form_1.png"/>, result[i] = ext[i] <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> value or result[i] = value <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> ext[i] for every i from 0 to N-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ext</td><td>The extent&lt;N&gt; operand </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The integer operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4d3e42654ea30b4f586595e6d7c1b0ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1extent.html">extent</a>&lt;N&gt; hc::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds (or subtracts) two objects of extent&lt;N&gt; to form a new extent. </p>
<p>The result extent&lt;N&gt; is such that for a given operator <img class="formulaInl" alt="$\oplus$" src="form_1.png"/>, result[i] = leftExt[i] <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> rightExt[i] for every i from 0 to N-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The left-hand extent&lt;N&gt; to be compared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The right-hand extent&lt;N&gt; to be compared. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa1d1f514a90e532aa0736b1b33e134b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1extent.html">extent</a>&lt;N&gt; hc::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands. </p>
<p>The result extent&lt;N&gt; is such that for a given operator <img class="formulaInl" alt="$\oplus$" src="form_1.png"/>, result[i] = ext[i] <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> value or result[i] = value <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> ext[i] for every i from 0 to N-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ext</td><td>The extent&lt;N&gt; operand </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The integer operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4535cf3e8ab396987a0b02af1caa14c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1extent.html">extent</a>&lt;N&gt; hc::operator+ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>ext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands. </p>
<p>The result extent&lt;N&gt; is such that for a given operator <img class="formulaInl" alt="$\oplus$" src="form_1.png"/>, result[i] = ext[i] <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> value or result[i] = value <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> ext[i] for every i from 0 to N-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ext</td><td>The extent&lt;N&gt; operand </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The integer operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a49c9f9a9e42b162e941f6bb8cceec26e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1extent.html">extent</a>&lt;N&gt; hc::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds (or subtracts) two objects of extent&lt;N&gt; to form a new extent. </p>
<p>The result extent&lt;N&gt; is such that for a given operator <img class="formulaInl" alt="$\oplus$" src="form_1.png"/>, result[i] = leftExt[i] <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> rightExt[i] for every i from 0 to N-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The left-hand extent&lt;N&gt; to be compared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The right-hand extent&lt;N&gt; to be compared. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8e2463747f107a246000b7cd15bc1bc9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1extent.html">extent</a>&lt;N&gt; hc::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands. </p>
<p>The result extent&lt;N&gt; is such that for a given operator <img class="formulaInl" alt="$\oplus$" src="form_1.png"/>, result[i] = ext[i] <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> value or result[i] = value <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> ext[i] for every i from 0 to N-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ext</td><td>The extent&lt;N&gt; operand </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The integer operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa72e890fd253412f24b4b2920855053e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1extent.html">extent</a>&lt;N&gt; hc::operator- </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>ext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands. </p>
<p>The result extent&lt;N&gt; is such that for a given operator <img class="formulaInl" alt="$\oplus$" src="form_1.png"/>, result[i] = ext[i] <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> value or result[i] = value <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> ext[i] for every i from 0 to N-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ext</td><td>The extent&lt;N&gt; operand </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The integer operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8038167eedd9bce712ce8523bd9a05ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1extent.html">extent</a>&lt;N&gt; hc::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands. </p>
<p>The result extent&lt;N&gt; is such that for a given operator <img class="formulaInl" alt="$\oplus$" src="form_1.png"/>, result[i] = ext[i] <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> value or result[i] = value <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> ext[i] for every i from 0 to N-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ext</td><td>The extent&lt;N&gt; operand </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The integer operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a974a4b7fb5625be322063b97b0dbe244"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhc_1_1extent.html">extent</a>&lt;N&gt; hc::operator/ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhc_1_1extent.html">extent</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>ext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary arithmetic operations that produce a new extent&lt;N&gt; that is the result of performing the corresponding binary arithmetic operation on the elements of the extent operands. </p>
<p>The result extent&lt;N&gt; is such that for a given operator <img class="formulaInl" alt="$\oplus$" src="form_1.png"/>, result[i] = ext[i] <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> value or result[i] = value <img class="formulaInl" alt="$\oplus$" src="form_1.png"/> ext[i] for every i from 0 to N-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ext</td><td>The extent&lt;N&gt; operand </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The integer operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a34d1958ac18966c6c4ce871956bdfa0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hc::tile_static_memory_fence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhc_1_1tile__barrier.html">tile_barrier</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a thread-tile scoped memory fence for tile-static (but not global) memory operations. </p>
<p>This function does not imply a barrier and is therefore permitted in divergent code. </p>

<p>Referenced by <a class="el" href="classhc_1_1tile__barrier.html#a65f19da07bb613ddfd3171540a576208">hc::tile_barrier::wait_with_tile_static_memory_fence()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a1d3281796648024457060676d254786e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classhc_1_1tiled__extent.html">tiled_extent</a>&lt; 3 &gt; const Kernel &amp;f __CPU__ hc::__HC__</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0 ; i &lt; N ; i++)</div><div class="line">    {</div><div class="line">      </div><div class="line">      <span class="keywordflow">if</span> (compute_domain[i] == 0)</div><div class="line">        <span class="keywordflow">return</span> completion_future();</div><div class="line">      <span class="keywordflow">if</span> (compute_domain[i] &lt; 0)</div><div class="line">        <span class="keywordflow">throw</span> invalid_compute_domain(<span class="stringliteral">&quot;Extent is less than 0.&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (static_cast&lt;size_t&gt;(compute_domain[i]) &gt; 4294967295L)</div><div class="line">        <span class="keywordflow">throw</span> invalid_compute_domain(<span class="stringliteral">&quot;Extent size too large.&quot;</span>);</div><div class="line">    }</div><div class="line">    <span class="keywordtype">size_t</span> ext[3] = {<span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(compute_domain[N - 1]),</div><div class="line">        static_cast&lt;size_t&gt;(compute_domain[N - 2]),</div><div class="line">        <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(compute_domain[N - 3])}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a53296cbb2bb1a430e2e974550d2d4f23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void hc::cpu</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = 0</div></div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 13 2017 13:11:18 for HCC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
